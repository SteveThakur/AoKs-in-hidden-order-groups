\documentclass[11pt, lettersize, notitlepage, leqno, footskip=0.6cm]{article}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}	
%\usepackage{graphicx}
\usepackage{amscd}
%\usepackage{mathabx}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

%\usepackage[T1]{fontenc}% http://ctan.org/pkg/fontenc
%\usepackage[outline]{contour}% http://ctan.org/pkg/contour
%\usepackage{xcolor}% http://ctan.org/pkg/xcolor

\usepackage{authblk}

\usepackage{fancyvrb}

% This the preamble, load any packages you're going to use here
%\usepackage{physics} % provides lots of nice features and commands often used in physics, it also loads some other packages (like AMSmath)
%\usepackage{siunitx} % typesets numbers with units very nicely
\usepackage{enumerate} % allows us to customize our lists
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tikz}
%\usetikzlibrary{decorations.pathreplacing}
%\usepackage[colorinlistoftodos]{todonotes}
%\usepackage{pgfplots} 
%\pgfplotsset{width=10cm,compat=1.9} 
\usepackage{verbatim}

\usepackage{thmtools}
\usepackage[none]{hyphenat}

\usepackage{indentfirst}

\usepackage{braket}

\usepackage[shortlabels]{enumitem}

\usepackage{appendix}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}
\DeclareMathAccent{\wideparen}{0}{mathx}{"75}

\def\cs#1{\texttt{\char`\\#1}}



\addtolength{\textwidth}{100pt}
\addtolength{\evensidemargin}{-50pt}
\addtolength{\oddsidemargin}{-50pt}
\addtolength{\topmargin}{-60pt}
\addtolength{\textheight}{1.6in}
%\setlength{\parindent}{0in}
\setlength{\parskip}{2pt}


\setlength{\abovedisplayskip}{0cm}
\setlength{\belowdisplayskip}{0cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Begin user defined commands


\newcommand{\bc}{\mathbb C}
\newcommand{\bF}{\mathbb F}
\newcommand{\bH}{\mathbb H}
\newcommand{\bn}{\mathbb N}
\newcommand{\bz}{\mathbb Z}
\newcommand{\bp}{\mathbb{P}}
\newcommand{\bq}{\mathbb Q}
\newcommand{\br}{\mathbb R}
\newcommand{\bS}{\mathbb S}

\newcommand{\bFp}{\mathbb{F}_p}
\newcommand{\bFP}{\ov{\mathbb{F}}_p}
\newcommand{\bFl}{\mathbb{F}_l}
\newcommand{\bFq}{\mathbb{F}_q}
\newcommand{\bFQ}{\ov{\mathbb{F}}_q}
\newcommand{\bFpk}{\mathbb{F}_{p^k}}


\newcommand{\pl}{\prod\limits}
\newcommand{\slim}{\sum\limits}
\newcommand{\bcup}{\bigcup\limits}
\newcommand{\bcap}{\bigcap\limits}

\newcommand{\ttt}{\texttt}

\newcommand{\bT}{\mathbf T}
\newcommand{\bTl}{\mathbf T_{{\bq_l}}}
\newcommand{\bTlbar}{\mathbf T_{{\qbar_l}}}

\newcommand{\G}{\mathcal G}

\newcommand{\Gal}{\mathrm{Gal}}
\newcommand{\scl}{\mathcal L}

\newcommand{\W}{\mathcal W}
\newcommand{\WA}{\mathcal{W}_{A_v}}

\newcommand{\zbar}{\overline {\mathbb{Z}}}
\newcommand{\qbar}{\overline {\mathbb{Q}}}

\newcommand{\Fbar}{\overline {F}}
\newcommand{\Kbar}{\overline {K}}

\newcommand{\bark}{\overline {k}}

\newcommand{\bg}{\mathbb{G}}
\newcommand{\bG}{\mathbb{G}}

\newcommand{\st}{\mathrm{st}}

\newcommand{\uni}{\mathrm{uni}}

\newcommand{\lcm}{\mathrm{lcm}}

\newcommand{\negl}{\ttt{{negl}}}

\newcommand{\pr}{\protect}

\newcommand{\Acc}{\mbf{Acc}}

\newcommand{\sett}{\ttt{Set}}

\newcommand{\mult}{\mr{mult}}
\newcommand{\mul}{\mr{mult}}


\newcommand{\absq}{\mathrm{Gal}_{\bq}}
\newcommand{\absql}{\mathrm{Gal}_{\bq_l}}
\newcommand{\absqp}{\mathrm{Gal}_{\bq_p}}
\newcommand{\absqph}{\mathrm{Gal}_{\bq_{p^h}}}

\newcommand{\absf}{\mathrm{Gal}_F}
\newcommand{\absfv}{\mathrm{Gal}_{F_v}}
\newcommand{\abse}{\mathrm{Gal}_E}
\newcommand{\absk}{\mathrm{Gal}_K}
\newcommand{\absl}{\mathrm{Gal}_L}


\newcommand{\Gm}{\mathbb{G}_m}

\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\rarrrow}{\rightarrow}
\newcommand{\lra}{\longrightarrow}
\newcommand{\llra}{\longleftrightarrow}
\newcommand{\xra}{\xrightarrow}
\newcommand{\hra}{\hookrightarrow}
\newcommand{\LRA}{\Longleftrightarrow}
\newcommand{\RA}{\Longrightarrow}
\newcommand{\harrow}{\hookrightarrow}
\newcommand{\lhra}{\hooklongrightarrow}

\newcommand{\imp}{\Longrightarrow}

\newcommand{\impop}{\overset{\;\;\mr{o.p.}\;\;}{\Longrightarrow}}

\newcommand{\eqlam}{\equiv_{\lam}}

\newcommand{\lameq}{\equiv_{\lam}}


\newcommand{\bs}{\backslash}
\newcommand{\ti}{\tilde}
\newcommand{\wti}{\widetilde}
\newcommand{\mf}{\mathfrak}
\newcommand{\mc}{\mathcal}
\newcommand{\mb}{\mathbb}
\newcommand{\mbf}{\mathbf} 
\newcommand{\mr}{\mathrm}
\newcommand{\mfp}{\mathfrak{p}}
\newcommand{\tmfp}{\ti{\mc{P}}}
\newcommand{\mfm}{\mathfrak{m}}
\newcommand{\mfn}{\mathfrak{n}}

\newcommand{\pro}{\protect\verb}


\newcommand{\mfl}{\mathfrak{l}}

\newcommand{\zetamn}{\zeta_{mn}}

\newcommand{\setm}{\setminus}
\newcommand{\sm}{\setminus}

\newcommand{\Br}{\mr{Br}}

\newcommand{\Jac}{\mr{Jac}}

\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\Ga}{\Gamma}
\newcommand{\Gam}{\Gamma}
\newcommand{\lam}{\lambda}
\newcommand{\lamb}{\lambda}
\newcommand{\Lam}{\Lambda}
\newcommand{\Lamb}{\Lambda}
\newcommand{\del}{\delta}
\newcommand{\Del}{\Delta}
\newcommand{\si}{\sigma}
\newcommand{\tsi}{\tilde{\sigma}}
\newcommand{\om}{\omega}
\newcommand{\Om}{\Omega}
\newcommand{\what}{\widehat}
\newcommand{\weck}{\widecheck}


\newcommand{\ov}{\overline}


\newcommand{\bzlam}{\bz_{(\lam)}}

\newcommand{\sub}{\subseteq}

\newcommand{\nsub}{\nsubseteq}

\newcommand{\dlog}{\mbf{dlog}}

\newcommand{\Prob}{\mbf{Prob}}

\newcommand{\bO}{\mbf{O}}

\newcommand{\mP}{\mc{P}}

\newcommand{\V}{\mc{V}}

\newcommand{\mcM}{\mc{M}}


\newcommand{\Com}{\ttt{Com}}

\newcommand{\vs}{\vspace{-0.15cm}}

\newcommand{\para}{\;\;\;\;\;\;}

\newcommand{\noin}{\noindent}

\newcommand{\op}{overwhelming probability}

\newcommand{\np}{negligible probability}

\newcommand{\non}{non-interactive proof}
\newcommand{\nons}{non-interactive proofs}

\newcommand{\sta}{\stackrel{?}{=}}

\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}

\newcommand{\LCM}{\mbf{lcm}}

\newcommand{\GCD}{\mbf{gcd}}

\newcommand{\intt}{\ttt{int}}

\newcommand{\un}{\ttt{uni}}

\newcommand{\new}{\ttt{new}}



%  End user defined commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These establish different environments for stating Theorems, Lemmas, Remarks, etc.

\newtheorem{Thm}{Theorem}[section]
\newtheorem{Prop}[Thm]{Proposition}
\newtheorem{Lem}[Thm]{Lemma}
\newtheorem{Corr}[Thm]{Corollary}
\newtheorem{Algo}[Thm]{Algorithm}
\newtheorem{Example}[Thm]{Example}

\newtheorem{Prot}[Thm]{Protocol}

\newtheorem{Def}{Definition}[section]

\newtheorem{Assumption}[Thm]{Assumption}

\newtheorem{Rem}[Thm]{Remark}

\declaretheorem{theorem} 
\declaretheoremstyle[%
  spaceabove=-2pt,%
  spacebelow=8pt,%
  headfont=\normalfont\itshape,%
  postheadspace=1em,%
  qed=\qedsymbol%
]{mystyle} 
\declaretheorem[name={Proof},style=mystyle,unnumbered,
]{prf}

\declaretheorem[name={Step},style=bold,unnumbered, %postheadspace=1em,%
qed=\qedsymbol%
]{prf1}

\numberwithin{equation}{section}


%\renewcommand{\labelenumi}{(\alphaph{enumi})}

% End environments 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Now we're ready to start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\linespread{1.00}




\begin{document}
 
\title{Arguments of Knowledge\\ in hidden order groups}
\author{Steve Thakur}
\affil{}
\date{\vspace{-6ex}}
 
\maketitle

\begin{abstract} We study non-interactive arguments of knowledge (AoKs) in groups of hidden order. We provide protocols whereby a Prover can demonstrate certain relations between committed sets/multisets with succinct proofs. These proofs can be publicly verified against the\\ constant-sized commitments to the sets/multisets. In particular, we provide AoKs for the disjointness of sets/multisets in cryptographic accumulators, with a view toward applications to sharded blockchains and verifiably outsourcing data storage. 

Recent work ([DGS20]) suggests that the hidden order groups need to be substantially larger in size that previously thought. Thus, in order to keep the communication complexity between the Prover and the the Verifier to a minimum, we have designed the protocols so that the proofs consist of a constant number of group elements, independent of the number of the committed sets/multisets rather than just independent of the sizes of these set/multisets. We build on the techniques from [BBF19] and [Wes18].

If the underlying group of hidden order is an imaginary quadratic class group or a genus three Jacobian, the argument systems are transparent (trrustless). Furthermore, since all challenges are public coin, the protocols can be made non-interactive using the Fiat-Shamir heuristic.\end{abstract}

\section{\fontsize{12}{12}\selectfont Introduction  }


Finite abelian groups of hidden order have seen a surging interest within cryptography in the last few years. The adaptive root assumption in such groups yields a cryptographic accumulator which is universal and dynamic with batchable membership and non-membership proofs ([BBF19]). One of the best known verifiable delay functions is that constructed in [Wes18], which can be instantiated with any group of unknown order in which the adaptive root assumption holds. Such groups also form the basis for the transparent polynomial commitment constructed in [BFS19]. This is a polynomial commitment with logarithmic sized proofs and verification time and can be instantiated with any group of hidden order.

In this paper, we explore non-interactive arguments of knowledge in groups of hidden order. We provide protocols whereby a Prover who stores data in the form of sets/multisets can prove relationships between these sets/multisets with communication complexity independent of the size of this data. These proofs can be publicly verified against the constant-sized commitments held by the Verifier. Our primary goal is to provide protocols for proofs of  disjointness of sets in accumulators. The primary use case for these AoKs is potential applications to sharded blockchains and to verifiable outsourcing of data.

As was the case with previously studied arguments of knowledge in hidden order groups ([BBF19], [CFGNK20] etc.), the proofs consist of elements of the group $\mb{G}$ and $\lam$-bit integers, where $\lam$ is the security parameter. The proofs are succinct in the sense that the proof sizes are independent of the size of the committed data sets/multisets and. Recent work ([DGS20]) suggests that the hidden order groups need to be substantially larger in size that previously thought, in order to ensure the desired security level. Furthermore, the two known candidates for transparent hidden order groups - imaginary quadratic class groups and genus three Jacobians - are not as well studied as RSA groups when it comes to potential attacks against the adaptive root and strong-RSA assumptions. Hence, it is conceivable that these groups might need to be even larger than presently believed. Bearing this in mind and with a view toward keeping the communication complexity between the Prover and the the Verifier to a minimum, we have designed the protocols so that the proofs consist of a constant number of group elements, independent of the number of committed sets/multisets involved, rather than just independent of the sizes of these sets/multisets. %At times, this comes at the cost of a higher (albeit superlinear in the size of the data) computational burden on the Prover.



\begin{comment}

\subsection{\fontsize{11}{11}\selectfont Notations and terminology}

\begin{Def} An argument system between a Prover and a Verifier is \textbf{non-interactive} if it consists of a single round of interaction. \end{Def}

\begin{Def} An argument of knowledge is said to be \textbf{public coin} if all challenges sent from the Verifier to the Prover are chosen uniformly at random and independently of the Prover's messages.\end{Def}

\noindent If the challenges are public coin, any interactive argument of knowledge can be converted into a non-interactive argument using a Fiat-Shamir heuristic ([FS86]).

\end{comment}}

\subsection{\fontsize{11}{11}\selectfont Candidates for hidden order groups }

At the moment, there are only three known families of finite abelian groups of unknown order. We briefly discuss them here.\vspace{0.2cm} \begin{enumerate}[wide, labelwidth=!, labelindent=0pt]

\item \textbf{RSA groups:} For distinct $1536$-bit primes $p$, $q$, define $N:= pq$. The group $(\bz/N\bz)^*$ has order $\phi(N) = (p-1)(q-1)$ which can only be computed by factorizing $N$. The strong-RSA assumption is believed to hold in the RS group. However, the group does contain the element $-1\Mod{N}$ of a known order $2$. For the adaptive root assumption to hold, the group has to be replaced by its quotient group $(\bz/N\bz)^*/\{\pm 1\}$ of order $\frac{(p-1)(q-1)}{2}.$ 

The RSA groups suffer from the need for a trusted setup. In practice, this is usually mitigated by a one-time secure multi-party computation. At the moment, a $3300$-bit RSA modulus yields a security level of $128$-bits.\vspace{0.2cm}


\item \textbf{Class groups:} Computing the class group of a number field is a long-standing problem in algorithmic number theory. Hence, class groups are natural candidates for hidden order groups. At the moment, the only class groups that allow for efficient group operations are those of imaginary quadratic fields.

For a square-free integer $d > 0$, the field $\bq(\sqrt{-d})$ has a class group of size roughly $\sqrt{d}$. This group is believed to fulfill the strong-RSA assumption. Furthermore, if $d$ is a prime $\equiv 3 \Mod{4}$, the $2$-torsion group is trivial, which eliminates the possibility of known elements of order $2$. Such a group is believed to fulfill the adaptive root assumption unless the integer $d$ lies within a certain thin set of integers.

A $6656$-bit discriminant $d$ yields a security level of $128$-bits at the moment. Unlike RSA groups, class groups allow for a transparent (trustless) setup. The downside is that for the same level of security, the group operations are roughly 10 times slower than modular multiplication.\vspace{0.2cm}

\item \textbf{Jacobians:} Recently, the group of $\bFp$-valued points of the Jacobian of a genus three hyperelliptic curve over a prime field $\bFp$ has been proposed as a candidate ([DGS20]). While this idea needs more scrutiny, it seems promising because of the transparent setup, the smaller key sizes and the fact that the group operations are 28 times faster than those in class groups for the same level of security.

For an irreducible polynomial $f(X)\in \bz[X]$ of degree $7$ with Galois group $S_7$ and a prime $p$ such that $f(X)\Mod{p}$ is separable, the hyperelliptic curve $C:Y^2 = f(X)$ over $\bFp$ yields a Jacobian that is resistant to the known attacks. At the moment, such a genus three hyperelliptic Jacobian over a prime field $\bFp$ of bit-size $1100$ allows for a security level of $128$-bits. This group $\Jac(C)(\bFp)$ is roughly of size $p^3$. \end{enumerate}


\subsection{\fontsize{11}{11} Cryptographic assumptions}

\begin{Def} We say that the \textbf{adaptive root assumption} holds for a group $\mb{G}$ if there is no efficient probabilistic polynomial time $($PPT$)$ adversary $(\mc{A}_0, \mc{A}_1)$ that succeeds in the following task. $\mc{A}_0$ outputs an element $w\in \mb{G}$ and some state. Then a random prime $l$ is chosen and $\mc{A}_1(l, \mr{state})$ outputs $w^{1/l}\in \mb{G}$. \end{Def}
 

\begin{Def} We say $\mb{G}$ satisfies the \textbf{strong-RSA} assumption if no PPT algorithm $\mc{A}$ is able to compute $($except with negligible probability$)$ the $l$-th root of a chosen element $w\in \mb{G}$ for some randomly chosen prime $l$.\end{Def}

\begin{Def} We say $\mb{G}$ satisfies the \textbf{low order assumption} if no PPT algorithm can generate $($except with negligible probability$)$ an element $a\in\mb{G}\setminus\{1\}$ and an integer $n< 2^{\mr{poly}(\lam)}$ such that $a^n = 1$.\end{Def}

\begin{Def} We say $\mb{G}$ satisfies the \textbf{fractional root assumption} if for a randomly generated element $g\in \mb{G}$, a PPT algorithm cannot output $h\in\mb{G}$ and $d_1,d_2\in\bz$ such that \vs $$g^{d_1} = h^{d_2}\;\wedge\; d_2 \nmid d_1$$ except with negligible probability.\end{Def}

\noin The assumptions bear the following relations: \vs $$\text{\{Adaptive root assumption\} }\imp \text{ \{Low order assumption\} } \imp \text{ \{Fractional root assumption\} },$$ \vspace{-0.6cm} $$\text{\{Strong-RSA assumption\} }\imp \text{ \{Fractional root assumption\}}. $$ We refer the reader to the appendix of [BBF19] for further details.

\subsection{\fontsize{11}{11}\selectfont Argument Systems }
\begin{comment}

\begin{Def} \normalfont We say an argument system $\protect{(\verb|Pgen,;P,V|)}$ is \textit{sound} if for all PPT adversaries $\mc{A} = (\mc{A}_0, \mc{A}_1)$, the probability of $\mc{A}$ forging a fake proof is negligible.\end{Def}

\begin{Def} \normalfont An argument system is \textit{non-interactive} if it consists of a single round of interaction between the Prover and the Verifier.\end{Def}

\noin \textbf{This subsection needs to be completed}


\end{comment}


\subsection{\fontsize{11}{11}\selectfont Multiset notations}


We first recall/introduce a few basic definitions and notations concerning multisets. For a multiset $\mc{M}$, we denote by $\sett(\mc{M})$ the underlying set of $\mc{M}$. For any element $x$, we denote by $\mul(\mc{M},x)$ the multiplicity of $x$ in $\mc{M}$. Thus, $\mc{M} = \{ \mult(\mc{M},x)\times x: \; x\in \sett(\mc{M})\}$. For brevity, we write \vs $$\Pi(\mc{M}):= \pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M},x)}.$$ For two multisets $\mc{M}, \mc{N}$, we have the following operations:\vspace{0.1cm}

\noin - The sum $\mc{M}+\mc{N} := \{(\mul(\mc{M},x)+\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N}) \}$

\noin - The union $\mc{M}\cup \mc{N} := \{\max(\mul(\mc{M},x),\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$

\noin - The intersection $\mc{M}\cap \mc{N} := \{\min(\mul(\mc{M},x),\;\mul(\mc{N},x))\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$

\noin - The difference $\mc{M}\sm \mc{N} := \{\min(\mul(\mc{M},x)-\mul(\mc{N},x),\; 0)\times x:\;x\in \sett(\mc{M})\cup\sett(\mc{N})\}$.\vspace{0.1cm}

\noin The function $\Pi(.)$ clearly has the following properties:

\noin- $\Pi(\mc{M}+\mc{N})= \Pi(\mc{M})\cdot\Pi(\mc{N})$

\noin - $\Pi(\mc{M}\cup \mc{N}) = \LCM(\Pi(\mc{M}), \Pi(\mc{M}))$

\noin - $\Pi(\mc{M}\cap \mc{N}) = \GCD(\Pi(\mc{M}), \Pi(\mc{M}))$

\noin - $\Pi(\mc{M}\sm \mc{N}) = {\Pi(\mc{M})}/{\Pi(\mc{M}\cap \mc{N})}$\vspace{0.1cm}

For a multiset $\mc{M}$ represented by $\lam$-bit primes and a hidden order group $\bG$, a \textit{commitment to a multiset} $\mc{M}$ is a pair $(g, h)\in\bG^2$ such that $g^{\Pi(\mc{M})} = h$. The hardness of the discrete logarithm problem implies that this commitment is \textit{hiding} in the sense that no PPT algorithm can compute $\mcM$ from the pair $[g,h]$. The low order assumption implies that it is \textit{binding} in the sense that no PPT algorithm can compute another multiset $\mcM'$ with the same commitment.

\subsection{\fontsize{11}{11}\selectfont Cryptographic Accumulators }

A cryptographic accumulator [Bd94] is a primitive that produces a short binding commitment to a set (or multiset) of elements together with short membership and/or non-membership proofs for any element in the set. These proofs can be publicly verified against the commitment. Broadly, there are three known types of accumulators at the moment: 

\noin - Merkle trees\\
- pairing-based (aka bilinear) accumulators \\  
- accumulators based on groups of unknown order, which we study in this paper. 

Let $\mb{G}$ be a group of hidden order and fix an element $g \in\mb{G}$. Let $\mc{M}= \{\mfm_1\times d_1,\cdots, \mfm_m\times d_m\}$ be a multiset, where $\{d_1,\cdots, d_n \}$ is the underlyling set $\sett(\mc{M})$ of $\mc{M}$ and $\mfm_i$ is the multiplicity of $d_i$. Using an appropriate hashing algorithm, we may assume the elements $d_i$ are distinct $\lam$-bit primes. The \textbf{accumulated digest} of $\mc{M}$ is given by \vs $$\Acc(\mc{M}):= g^{\Pi(\mc{M})} ,$$ where $$\Pi(\mc{M}) = \pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M},x)} .$$ Let $\mc{M}_0$ be a multiset contained in $\mc{M}$, so that  $\mfm_{0,i}\leq \mfm_i\;\forall\;i$. The element \vs $$w(\mc{M}_0):= g^{\pl_{x\in \sett(\mc{M})} x^{\mult(\mc{M},x)-\mult(\mc{M}_0,x)} .}\;\in\;\mb{G} $$ is called \textit{the membership witness} of $\mc{M}_0$. Given this element, a Verifier can verify membership of $\mc{M}_0$ in $\mc{M}$ by verifying the equation \vs $$w(\mc{M}_0)^{\Pi(\mc{M}_0)} \sta \Acc(\mc{D}).$$ When the multiset $\mc{M}_0$ is large, this verification can be sped up using Wesolowki's \textit{Proof of Exponentiation} (\verb|PoE|) protocol ([Wes18]).

Shamir's trick allows for aggregation of membership witnesses in accumulators based on hidden order groups. This is not possible with Merkle trees, which is the primary reason other families of accumulators have been explored as authentication data structures for stateless blockchains. With bilinear accumulators, aggregation of membership witnesses has a linear runtime complexity, which is impractical for most use cases. Thus, accumulators based on hidden order groups have a major advantage in this regard.

These accumulators also allow for non-membership proofs [LLX07]. In [BBF19], the authors used a non-interactive argument of knowledge to compress batched non-membership proofs into constant-sized proofs, i.e. independent of the number of elements involved. This yields the first known Vector Commitment with constant-sized openings as well as  constant-sized public parameters.\vspace{0.1cm}

\noin \textbf{Hashing the data to primes:} The security of cryptographic accumulators and vector\\ commitments hinges on the assumption that for disjoint data sets $\mc{D},\mc{E}$, the integers $\Pi(\mc{D}), \Pi(\mc{E})$ are relatively prime. The easiest way to ensure this is to map the data elements to distinct $\lam$-bit primes. This is usually done by hashing the data to $\lam$-bit integers and subjecting the output to a probabilistic primality test such as the Miller-Rabin test. The prime number theorem states that the number of primes less than $n$ is $\mbf{O}(\frac{n}{\log(n)})$ and hence, implies that the expected runtime for finding a prime is $\mbf{O}(\lam)$.

Dirichlet's theorem on primes in arithmetic progressions combined with the prime number theorem implies that for relatively prime integers $k,r$ and an integer $n$, the number of primes less than $n$ that are $\equiv r\Mod{k}$ is roughly $\frac{n}{\log(n)\phi(k)}$. Thus, we can modify the hashing algorithm so that for any element inserted into the accumulator, the prime reveals the position in which it was inserted. We proceed as follows.\vspace{0.1cm} \begin{enumerate}[wide, labelwidth=!, labelindent=0pt] 

\item Fix a prime $p$ of size $\frac{\lam}{2}$. 

\item For an string inserted in position $i$, we map the string to the first prime of size $\lam$ which is $\equiv i\Mod{p}$. This (pseudo-)prime obtained by subjecting the integers $p\bz+i$ to the probabilistic Miller-Rabin test. \end{enumerate} \vspace{0.1cm}

\noin The number of such primes is roughly \vs $\frac{2^{\lam}}{\lam (p-1)}$ and hence, the expected runtime is $\mbf{O}(\lam)$.






\subsection{\fontsize{11}{11} Aggregating and disaggregating membership witnesses}

\noindent \textbf{Shamir's trick:} Given elements $a_1, a_2, A\in \mb{G}$ and integers $d_1, d_2$ such that $a_1^{d_1} = a_2^{d_2} = A$, Shamir's trick allows us to compute the $\LCM(d_1, d_2)$-th root of $A$ as follows. \begin{enumerate}[wide, labelwidth=!, labelindent=0pt] 

\item Compute integers $e_1, e_2$ such that \vs $$e_1d_1+e_2d_2 = \GCD(d_1, d_2).$$

\item Set $a_{1,2}:= a_1^{e_2}a_2^{e_1} $. \end{enumerate}

\noindent Then \vspace{-0.15cm}$$a_{1,2}^{d_1d_2} = A^{d_2e_2 + d_1e_1} = A^{\GCD(d_1,d_2)}$$ and hence, \vspace{-0.15cm}$$a_{1,2}^{\LCM(d_1,d_2)} = A.$$ More generally, given elements $a_1,\cdots,a_n$ such that \vs $$a_1^{d_1} = \cdots = a_n^{d_n} = A, $$ we can use Shamir's trick repeatedly to compute an element $a\in\mb{G}$ such that \vs $$a^{\LCM(d_1,\cdots,d_n)} = A.$$ The runtime for this algorithm is $\mbf{O}(n\log(n))$.

The most important special case is when $A$ is the accumulated digest $g^{\Pi(\mc{M})}$ for a multiset $\mc{M}$ and $w_1,\cdots,w_n$ are membership witnesses for multisets $\mc{M}_1,\cdots,\mc{M}_n\sub \mc{M}$. Shamir's trick allows us to compute a membership witness for the union $\bigcup\limits_{i=1}^n \mc{M}_i$. 

\begin{comment} Conversely, for any element $b = \pl_{i=1}^n a_i^{x_i}$ $(x_i\in\bz)$, we have \vs $$ b^{\LCM(d_1,\cdots,d_n)} = A^{\slim_{i=1}^n  \frac{\LCM(d_1,\cdots,d_n)x_i}{d_i}} $$ and the low order assumption implies that with \op, \vs $$b =  a^{\slim_{i=1}^n  \frac{\LCM(d_1,\cdots,d_n)x_i}{d_i}}.$$ Thus, $b$ is expressible as a power of $a$. 

\end{comment}

\vspace{0.2cm}


\noindent \textbf{The RootFactor Algorithm:} Given elements $a, A\in\mb{G}$ and integers $d_1,\cdots, d_n$, $D$ such that \vs $$D= \pl_{i=1}^n d_i\; ,\; a^{D} = A,$$ the RootFactor algorithm ([BBF19], [STY01]) allows us to compute elements $a_1,\cdots, a_n$ such that \vs $$a_1^{d_1}=\cdots = a_n^{d_n} = A$$ in runtime $\mbf{O}(\log(D)\log(\log(D)))$. Naively, this would take runtime $\mbf{O}(\log^2(D))$.


\subsection{\fontsize{11}{11}\selectfont $\bz_{(\lamb)}$-integers and the equivalence relation $\mathbf{(\equiv_{\lam})}$}

% \textbf{This subsection can be skipped for the time being. The protocols have been modified so that they do not involve this equivalence relation.}

\begin{Def} For elements $a, b\in\mb{G}$ and a rational $\al\in\bq$, we say $a^{\al} = \be$ with respect to a Prover $\mP$ if $\mP$ verifiably possesses integers $d_1,d_2\in\bz$ such that $\al = \frac{d_1}{d_2}$ and  $a^{d_1} = b^{d_2}$.\end{Def}

\noin Note that if there exists an element $a\in\mb{G}$ and distinct rationals $\frac{d_1}{d_2}, \frac{d_3}{d_4}\;(d_i\in\bz)$ such that \vs $$a^{\frac{d_1}{d_2}} = a^{\frac{d_3}{d_4}},$$ then $a^{d_1d_4-d_2d_3} = 1$ and $d_1d_4-d_2d_3\neq 0$. So the adaptive root assumption implies that a PPT algorithm cannot generate such a tuple $(a,d_1,d_2,d_3,d_4)$ except with negligible probability. Furthermore, by Shamir's trick, the condition is equivalent to the Prover $\mP$ being able to compute an element $a_0\in\mb{G}$ and co-prime integers $d_1,d_2$ such that \vs $$\al = \frac{d_1}{d_2}\;\;,\;\;a_0^{d_2} =a\;,\; a_0^{d_1} =b\;,\; $$


\begin{Def} An integer is said to be \textbf{$\lamb$-smooth} is all of its prime divisors are $\leq 2^{\lamb-1}$. An integer is said to be \textbf{$\lamb$-rough} is all of its prime divisors are $> 2^{\lam-1}$.\end{Def}

Similarly, we say a set/multiset $\mcM$ of primes is $\lam$-rough if the integer $\Pi(\mcM)$ is $\lam$-rough. This is equivalent to each prime of $\mcM$ being larger than $2^{\lam-1}$.

The properties of $\lamb$-smoothness and $\lamb$-roughness are clearly preserved under products, greatest common divisors and least common multiples. Furthermore, any positive integer $n$ is uniquely expressible as a product $n_{{\lam,s}}n_{{\lam,r}}$ of a $\lam$-smooth integer $n_{{\lam,s}}\geq 0$ and a $\lam$-rough integer $n_{{\lam,r}}\geq 0$.

\begin{Def} For a security parameter $\lamb$, we denote by $\bz_{(\lamb)}$ the integral domain obtained by localizing $\bz$ away from all primes $\geq 2^{\lamb-1}$. \end{Def}

\noindent Thus, \vs $$\bz_{(\lamb)} = \left\{\frac{\al}{\be}:\; \al,\be\in\bz,\;\GCD(\al,\be) = 1,\; \be \text{ is } \lamb\text{-smooth}\right\}.$$ Note that $\bz_{(\lamb)}$ inherits the structure of a principal ideal domain. The group of units of $\bzlam$ is given by $$\bzlam^{\times} := \left\{\frac{\al}{\be}:\; \al,\be\in\bz,\;\GCD(\al,\be) = 1,\; \al, \be \text{ are } \lamb\text{-smooth}\right\}. $$ The prime ideals of $\bz_{(\lamb)}$ are the principal ideals generated by rational primes larger than $2^{\lamb}$.

\begin{Def} For $\bzlam$-integers $d_1,d_2$ we say $d_1\eqlam d_2$ if $\frac{d_1}{d_2}$ is a unit in $\bzlam$.\end{Def}

\noin This is clearly a homomorphic equivalence relation.

\begin{Def} For $\bzlam$-integers $d_1,d_2$, we denote by $\GCD_{\lam}(d_1,d_2)$ the largest $\lam$-rough integer that divides both $d_1$ and $d_2$ in the principal ideal domain $\bzlam$. Similarly, we denote by $\LCM_{\lam}(d_1,d_2)$ the smallest $\lam$-rough integer divisible by $d_1$ and $d_2$ in $\bzlam$.\end{Def}

\noin Let $d_1,\cdots,d_n$ be $\bzlam$-integers and write $d_i = \wti{d}_i\frac{\al_i}{\be_i}$ with $\wti{d}_i$ a $\lam$-rough integer and $\al_i$, $\be_i$ co-prime $\lam$-smooth integers. Clearly, for each pair $i,j$, we have the equivalence \vs $$\GCD(\wti{d}_i,\wti{d_j}) = 1\LRA d_i,d_j\text{ co-prime in }\bzlam. $$

\begin{Def} For elements $a, b$ in a hidden order group $\mb{G}$, we say \vs $$ a \equiv_{\lam} b$$ with respect to a Prover $\mc{P}$ if $\mc{P}$ verifiably possesses  relatively prime $\lamb$-smooth integers $d_1, d_2$ such that $a^{d_1} = b^{d_2}.$\end{Def}

\noindent Because of Shamir's trick, this is equivalent to $\mc{P}$ being able to generate an element $a_0\in \mb{G}$ and relatively prime $\lamb$-smooth integers $d_1, d_2$ such that \vs $$a_0^{d_2} = a, \; a_0^{d_1} = b.$$ It is easy to see that this an equivalence relation.

\begin{Prop} The relation $(\equiv_{\lam})$ is an equivalence relation.\end{Prop}

\begin{prf} Since the reflexivity and the symmetry are obvious, it suffices to show that the relation is transitive.

\noindent (Transitivity): Suppose $a \equiv_{\lam} b$ and $b \equiv_{\lam} c$ for elements $a, b, c\in\mb{G}$. Then $\mc{P}$ possesses $\lam$-smooth integers $d_1,d_2, d_3, d_4$ such that \vs $$a^{d_1} = b^{d_2}\;,\; b^{d_3} = c^{d_4}\;,\;\GCD(d_1,d_2) = \GCD(d_3,d_4) = 1.$$ Now, \vs $$a^{d_1d_3} = b^{d_2d_3} = c^{d_2 d_4}$$ and clearly, the integers $d_1d_3, d_2 d_4$ are $\lam$-smooth. Set $d:= \GCD(d_1d_3, d_2 d_4)$ and $e_1:= d_1d_3/d, d_2 d_4/d$. Then $e_1,e_2$ are co-prime and $\lam$-smooth and \vs $$ a^{e_1} = c^{e_2} .$$ Thus, $a \equiv_{\lam} c$.\end{prf}

For elements $a,b\in\mb{G}$ the following are equivalent:\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] 

\item $a^d\eqlam b$ for some integer $d$.\vs
\item $a^d\eqlam b$ for some $\lam$-rough integer $d$.\vs
\item $b = a^{d_1}$ for some $\bzlam$-integer $d_1$.\end{enumerate}

Furthermore, if a PPT algorithm is able to output an element $a\in\mb{G}$ and integers $d_1,d_2$ such that $a^{d_1}\eqlam a^{d_2}$, then with \op, $\frac{d_1}{d_2}\in\bzlam^{\times}$. In particular, no PPT algorithm can output an element $a\in \mb{G}$ and distinct $\lam$-rough integers $d_1,d_2$ such that $a^{d_1}\eqlam a^{d_2}$.

We note, however, that the relation $(\equiv_{\lam})$ is not homomorphic, meaning that $a_1 \equiv_{\lam} a_2$, $b_1 \equiv_{\lam} b_2$ does not imply $a_1a_2 \eqlam b_1b_2$. But the relation is \textit{partly} homomorphic in the sense that for any integer $d$, \vs $$ a \equiv_{\lam} b \LRA a^d \equiv_{\lam} b^d .$$ \vspace{0.1cm}


\noin \textbf{Non-membership proofs in accumulators:} The  best-known application of the knowledge of exponent protocol is constant-sized batched non-membership proofs in accumulators ([BBF19]). We discuss the implications of replacing equality of $\mb{G}$-elements with the equivalence relation $\eqlam$ in this regard. 

Let $g \in \mb{G}$ denote the genesis state of the accumulator, $\mc{D}$ the inserted data set and $A = g^{\pl_{d\in \mc{D}}}$ the accumulated digest. For brevity, we write $D:= \pl_{d\in \mc{D}} d$. Given a data set $\mc{D}_0$ disjoint with $\mc{D}$ and the product $D_0:= \pl_{d\in \mc{D}_0} d,$ the Prover demonstrates non-membership for all elements of $\mc{D}_0$ by sending the following to the Verifier:

\noin - Elements $w, A_1\in\mb{G}$ such that $w^{D_0}A_1 = g$.\\
- A non-interactive proof for \verb|PoKE|$[A,\; A_1]$.

Suppose, instead of \verb|PoKE|$[A,\; A_1]$, the Prover proves the weaker statement that he possesses an integer $k$ such that $A^k \eqlam A_1$. By definition, there exist an integer $k$ and a $\lam$-smooth integer $e$ such that $\GCD(k,e) = 1$ and $A^{k} = A_1^e$.

Write $w = g^x$. Then \vs $$ x D_0 +  
\frac{kD}{e} = 1 $$ and hence, \vs $$ex D_0 +  kD = e .$$ Thus, $\GCD(D_0, D)$ divides $e$ which is a $\lam$-smooth integer. Since each element of $\mc{D}$ is a $\lam$-bit prime, it follows that $\mc{D}\cap \mc{D}_0 = \emptyset$, despite $\frac{k}{e}$ possibly not being an integer.

\subsection{\fontsize{11}{11}\selectfont Some preliminary lemmas }

\noin We will need the next two lemmas repeatedly in the subsequent protocols.

\begin{Lem} Let $p$ be a prime and let $f(X)$ be a univariate degree $n$ polynomial in $\bz[X]$ such that not all coefficients are divisible by $p$. For a randomly generated integer $\gamma$, the probability that $f(\gamma)\equiv 0\Mod{p^{n\lam}}$ is \normalfont $\ttt{negl}(\lam)$. \end{Lem}

\begin{prf} Let $F$ be a splitting field of $f(X)$ and let \vs $${f}(X) = \pl_{i=1}^n (X-\al_i)$$ be the factorization of ${f}(X)$ over $F$. Let $\mfp_{1},\cdots,\mfp_g$ be the distinct primes of $F$ lying over $p$. Since the extension $F/\bq$ is Galois, we have \vs $$p\mc{O}_F = \pl_{i=1}^{g} \mfp_i^e = \bigcap\limits_{i=1}^{g} \mfp_i^e$$ where $e\geq 1$ is the ramification degree and the Galois group $\Gal(F/\bq)$ acts transitively on the set $\{ \mfp_1,\cdots,\mfp_g\}$.

We note that for any integer $k\geq 1$, $\mfp_1^{ek}\cap \bz = p^{k}\bz$. The inclusion $p^{k}\bz\sub \mfp_1^{ek}\cap \bz$ is obvious. For the reverse inclusion, let $x\in \mfp_1^{ek}\cap \bz$. For any index $i$, there exists an automorphism $\sigma_i\in \Gal(F/\bq)$ such that $\sigma_i(\mfp_1) = \mfp_i$. So $x = \sigma(x) \in \mfp_i^e$. Hence, $x\in \bigcap\limits_{i=1}^g \mfp_i^{ek} = p^{k}\bz$.

For any two integers $x_1,x_2\in \bz$, we have \vs $$x_1-x_2\in \mfp_1^{e\lam}\LRA x_1-x_2\in \mfp_1^{e\lam}\cap \bz = p^{\lam}\bz.$$ Hence, the set \vs $$ S_{\lam}:= \{x + {\mfp_1^{e\lam}}:\;x\in\bz \}\sub \mc{O}_F/\mfp^{e\lam} $$ has cardinality $p^{\lam}$. Now, for any integer $\gamma$, \vs $$f(\gamma)\equiv 0 \Mod{p^{n\lam}} \LRA f(\gamma)\equiv 0 \Mod{\mfp_1^{en\lam}}  \Longrightarrow \gamma\equiv \al_i \Mod{\mfp_1^{e\lam}}\text{ for at least one index } i. $$  Since $\gamma$ is randomly generated, $\gamma\Mod{\mfp_1^{e\lam}}$ is randomly and uniformly distributed over the set $S_{\lam}$. Hence, \vs $$ \mbf{Prob}\big( f(\gamma)\equiv 0 \Mod{p^{n\lam}} \big)\leq \frac{n}{p^{\lam}} = \negl(\lam),$$ which completes the proof.\end{prf}

\begin{Lem}$\mbf{1}$. For rationals $d_1,\cdots, d_n\in \bq$ and a randomly generated $\lam$-bit integer $\gamma$, if \vs$$\sum\limits_{i=1}^n d_i\gamma^i\; \in \;\bzlam,$$ with \op, $(d_1,\cdots, d_n)\in \bzlam^n$.\vspace{0.1cm}

\noin $\mbf{2}$. For rationals $d_1,\cdots, d_n\in \bq$ and a randomly generated $\lam$-bit integer $\gamma$, if \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i\; \in \;\bz,$$ with \op, $(d_1,\cdots, d_n)\in \bz^n$.\end{Lem}

\begin{prf} $\mbf{1}$. Let $D$ be the least common denominator for $d_1,\cdots, d_n$ and write \vs $$d_i = \frac{c_i}{D}\;,\; c_i\in\bz\; \;\;(i=1,\cdots, n).$$ Suppose, by way of contradiction that $(d_1,\cdots, d_n )\notin \bzlam^n$. Then $D$ is divisible by some prime $p>2^{\lam}$ and \vs $$\sum\limits_{i=1}^n  {c_i\gamma^i} \equiv 0\Mod{p}.$$ Now, the polynomial $\sum\limits_{i=1}^n c_iX^i \in \bFp[X]$ has at most $n$ distinct zeros in $\bFp$ and since $\gamma$ is uniformly distributed modulo $p$, the probability of this occurring is $\negl(\lamb)$, a contradiction.\vspace{0.15cm} 

\noin $\mbf{2}$. Let $D$ be the least common denominator for $d_1,\cdots, d_n$ and write $d_i = \frac{c_i}{D}$ for $i=1,\cdots, n.$ Suppose, by way of contradiction that $(d_1^{n\lam},\cdots, d_n^{n\lam} )\notin \bz^n$ and let $p$ be a prime dividing $D$. Then $$\slim_{i=1}^n c_i^{n\lam}\gamma^i \equiv 0\Mod{p^{n\lam}}.$$ Now, the polynomial $f(X):= \slim_{i=1}^n c_i^{n\lam} X^i$ has degree $n$ and by the preceding lemma, \vs $$\mbf{Prob}\big(h(\gamma)\equiv 0\Mod{p^{n\lam}} \big) = \negl(\lam).$$ Thus, with \op, the rationals $d_i^{n\lam}$ are integers, which in turn implies that the $d_i$ are integers.\end{prf}


\begin{comment}
For the second part, note that \vs $$\Prob\big(\sum\limits_{i=1}^n d_i\gamma_j^i\in \bz\;\forall j\big|\; (d_1,\cdots,d_n)\notin \bz\big ) = \Prob\big(\sum\limits_{i=1}^n d_i\gamma^i\in \bz\big|\; (d_1,\cdots,d_n)\notin \bz\big )^{\lam} = \negl(\lam).$$\end{comment}

\noindent In particular, \vs $$\mbf{Prob}\big((d_1,\cdots, d_n)\notin \bzlam^n \;\Big|\;\sum\limits_{i=1}^n d_i\gamma^i\; \in \;\bz \big) = \negl(\lamb).$$ Similarly, \vs $$ \mbf{Prob}\big((d_1,\cdots, d_n)\notin \bz^n \;\Big|\;\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\; \in \;\bz \big) = \negl(\lamb). $$


In a setting where the Verifier is not satisfied with the elements $d_1,\cdots, d_n$ being $\bzlam$-integers and needs a probabilistic proof that they are, in fact, rational integers, the Prover could demonstrate that $\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$. The resulting trade-off is a higher computational burden for the Prover. Computing \vs $$g^{\slim_{i=1}^n d_i^{n\lam} \gamma^i}$$ entails \vs $$\mbf{O}\big(\log(\slim_{i=1}^n d_i^{n\lam} \gamma^i)\big) = \mbf{O}\big(n\log(n)\lam\max\{\log(d_i)\}\big) $$ exponentiations in $\mb{G}$. On the other hand, computing $g^{\slim_{i=1}^n d_i\gamma^i}$ entails \vs $$\mbf{O}\big(\log(\slim_{i=1}^n d_i\gamma^i)\big) = \mbf{O}\big(\log(n)\max\{\log(d_i)\}) \big)$$ group exponentiations. Given a randomly generated element $g\in \mb{G}$, if the Prover outputs an element $\wti{g} = g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$, then the fractional root assumption implies that $\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$ except with negligible probability. Lemma 1.3 then implies that with \op, $(d_1,\cdots,d_n)\in \bz^n$.



\section{\fontsize{12}{12}\selectfont Arguments of Knowledge  }

\noindent We briefly review the protocol \verb|PoKE| from [BBF19]. 

\begin{Prot} \normalfont \textit{Proof of Knowledge of the Exponent} (\verb|PoKE|) \end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$

\noindent \textbf{Inputs:} $u, w \in \mb{G}$.

\noindent \textbf{Claim:} The Prover posseses an integer $x$ such that $u^x = w$

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $z:= g^x$ and sends it to the Verifier $\mc{V}$.

\noindent 2. The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$.

\noindent 3. $\mc{P}$ computes the integers $q, r$ such that  \vspace{-0.15cm}$$x = ql+r,\;\; r\in [l].$$

\noindent 4. $\mc{P}$ computes $Q:= u^q,\; Q' = g^q$ and sends $(Q, Q', g^x, r)$ to $\mc{V}$.

\noindent 5. $\mc{V}$ accepts if and only if \vspace{-0.15cm}$$r\in [l],\;\; Q^lu^r w,\;\; Q'^lg^r = z.$$\qed \end{enumerate}

The part where $\mc{P}$ computes $g^x$ and sends it to $\mc{V}$ \textit{before} receiving the challenge $l$ is necessary for the security of the protocol. Without this step, a malicious Prover could convince the Verifier that $x$ is an integer, which might not necessarily be the case.

Clearly, the relation \textit{Knowledge of the Exponent} is transitive in the sense that for elements $a_1,a_2,a_3\in\mb{G}$, if a prover $\mP$ possesses integers $d_1,d_2$ such that $a_1^{d_1} = a_2\;,\;a_2^{d_2} = a_3$, then he possesses the integer $d_1d_2$ which fulfills the equation $a_1^{d_1d_2} = a_3$. Henceforth, we denote the proof of knowledge of the discrete logarithm between $a,b\in\mb{G}$ by $\verb|PoKE|[a,b]$. 

In the following protocol, we show how a Prover could probabilistically demonstrate that two discrete logarithms are equal with a constant-sized proof. We provide an argument of knowledge for  the following relation:

\[
  \mc{R}_{\ttt{EqDLog}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1),\; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}: \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\]

\noin The protocol hinges on the observation that for two integers $d_1,d_2$, if we have $d_1\equiv d_2\Mod{l}$ for a randomly generated $\lam$-bit prime $l$, then with \op, $d_1= d_2$.

\vspace{0.15cm}


\begin{Prot}\label{EqDLog} \normalfont \textit{Proof of equality of discrete logarithms} (\verb|PoEqDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} $a_1, a_2, b_1, b_2 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses an integer $d$ such that $a_1^d = b_1$ and $a_2^d = b_2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ sends $\wti{g}:= g^d$ to the Verifier $\mc{V}$. \vs

\item The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$. \vs

\item $\mc{P}$ computes the integers $q, r$ such that $d = ql+r$, $r\in [l]$ and the group elements \vs $$Q_1:= a_1^q,\;\; Q_2:= a_2^q,\;\; \weck{g}:= g^q.$$ He sends $(Q_1, Q_2, \weck{g}, r)$ to $\mc{V}$. \vs

\item $\mc{V}$ verifies the equations \vs $$r\in [l],\;\;Q_1^la_1^r \sta  b_1, \;\; Q_2^la_2^r \sta  b_2, \;\; (\weck{g})^lg^r \sta \wti{g}.$$ He accepts if and only if all equations hold.\qed \end{enumerate}

\noin Thus, the proof consists of four $\mb{G}$-elements and one $\lam$-bit integer. 

\begin{Prop} The protocol \verb|EqDLog|$[(a_1, b_1),\; (a_2, b_2)]$ is an argument of knowledge for the relation $\mc{R}_{{\tt{{EqDLog}}}}$ in the generic group model.\end{Prop}

\begin{prf} Since the protocol \verb|PoKE| is secure ([BBF19]), the validity of the equations \vs $$Q_1^la_1^r \stackrel{?}{=}  b_1, \;\; Q_2^la_2^r \stackrel{?}{=} b_2, \;\; (\weck{g})^l g^r \stackrel{?}{=} \wti{g}$$ proves that $\mc{P}$ possesses the discrete logarithms between $a_1, b_1$ and $a_2, b_2$. Suppose, by way of contradiction, that these discrete logarithms are distinct and denote them by $d_1$, $d_2$ respectively. The adaptive root assumption implies that with \op,\vs $$d_1 \equiv r\equiv d_2 \Mod{l}.$$ But since the $\lamb$-bit prime $l$ is randomly generated, the integer $d_1-d_2$ is randomly and uniformly distributed modulo $l$ and hence, \vs $$ \Prob\big( d_1\equiv d_2\Mod{l}\; \Big|\; d_1\neq d_2    \big) = \frac{1}{l} =\negl(\lamb),$$ a contradiction.\end{prf}

\vspace{0.2cm}



\noindent We can also generalize the protocol \verb|EqDLog| as follows. For a public polynomial {$f(X)\in \bz[X]$}, an honest Prover can provide a constant-sized proof that he possesses integers $d_1,d_2$ such that \vs $$a_1^{d_1} = b_1\;,\;a_2^{d_2} = b_2\;,\;f(d_1) = d_2.$$ We provide an argument of knowledge for the relation 

\[
  \mc{R}_{{\ttt{PolyDLog}}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    ((a_1, b_1), (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]);\\
    (d_1, d_2)\in\mb{Z}^2: \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_1 = a_1^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\] 

\vspace{0.2cm}


\begin{Prot} \normalfont \textit{Proof of Polynomial equation between discrete logarithms} (\verb|PoPolyDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, b_1, a_2, b_2\in \mb{G}$, a public polynomial $f(X)\in\bz[X]$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$ such that:

\noindent -$a_1^{d_1} = b_1,\;  a_2^{d_2} = b_2$\\
-$f(d_1) = d_2$

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $\wti{g}_1, \wti{g}_2$ and sends them to the Verifier $\mc{V}$.

\noindent 2. The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$.

\noindent 3. $\mc{P}$ computes elements $q_1, q_2, r_1, r_2$ such that \vs $$d_1 = q_1l+r_1,\; d_2 = q_1l+r_1,\;\; r_1,r_2\in [l].$$

\noindent 4. $\mc{P}$ computes the elements $Q_1:= a_1^{q_1},\;Q_2:= a_2^{q_2},\; g_1:= g^{q_1},\; g_2:= g^{q_2}\;\in\mb{G}$ and sends them to $\mc{V}$ along with the integer $r_1$.

\noindent 5. The Verifer verifies that $r_1\in [l]$. He independently computes $r_2:= f(r_1)\Mod{l}$.

\noindent 6. $\mc{V}$ verifies the equations \vs $$Q_1^{l}a_1^{r_1}\stackrel{?}{=} b_1\;\;\bigwedge\;\; Q_2^{l}a_2^{r_2}\stackrel{?}{=} b_2 \;\;\bigwedge\;\; (g_1)^lg^{r_1} \stackrel{?}{=} \wti{g}_1\;\;\bigwedge\;\; (g_2)^lg^{r_2} \stackrel{?}{=} \wti{g}_2 $$ and accepts the validity of the claim if and only if all equations hold.\qed \end{enumerate}

\noindent Thus, the proof consists of six elements of $\mb{G}$ and one $\lam$-bit integer.

\begin{Prop} The protocol \verb|PoPolyDLog| is an argument of knowledge in the generic group
model.\end{Prop}

\begin{prf} (Sketch) The Verifier independently computes $r_2:= f(r_1)\Mod{l}$ in Step 6. Hence, the equations $$Q_1^{l}a_1^{r_1}\stackrel{?}{=} b_1\;\;\bigwedge\;\; Q_2^{l}a_2^{r_2} = b_2$$ imply that with \op, the Prover possesses rationals $d_1,d_2$ such that $$a^{d_1} = b_1\;,\;a_2^{d_2} = b_2,\;,\;d_2\equiv f(d_1)\Mod{l}.$$ Furthermore, the equations \vs $$(g_1)^lg^{r_1} \stackrel{?}{=} g^{d_1}\;\;\bigwedge\;\; (g_2)^lg^{r_2} \stackrel{?}{=} g^{d_2} $$ imply that with \op, \vs $$\wti{g}_1 = g^{d_1}\;\bigwedge\;\wti{g}_2 = g^{d_2}. $$ The fractional root assumption now implies that with \op, $d_1,d_2\in \bz$.\end{prf}

\noin In the next section, we will generalize this protocol to multivariate polynomial relations for multiple discrete logarithms. We briefly discuss an application of the last protocol.\\

\noin \textbf{Underlying sets of committed multisets:} Let $a_1,a_2$ be elements of $\mb{G}$. Let \vs $$\mc{M} = \{\mf{m}_1\times d_1,\cdots, \mf{m}_m\times d_m \}\;,\;\mc{N} = \{\mf{n}_1\times e_1,\cdots, \mf{n}_n\times e_n \}$$ be multisets, where $\mf{m}_i,\;\mf{n}_j$ are the multiplicities of the elements. As before, we write \vs $$\Pi(\mc{M}):= \pl_{i=1}^m d_i^{\mfm_i}\;,\; \Pi(\mc{M}):= \pl_{j=1}^n e_j^{\mfn_j}.$$ Let \vs $$A_1:= \ttt{Com}(g, \mc{M}) =  g^{\Pi(\mc{M})}\;,\; A_2:= \ttt{Com}(g, \mc{N}) = g^{\Pi(\mc{N})}$$ be the commitments to $\mc{M}$, $\mc{N}$.

Clearly, the relation $\mc{N}\sub \mc{M}$ can be demonstrated by the protocol \verb|PoKE|$[A_2, A_1]$. We now show that the protocol \verb|PolyDLog| allows a Prover to succinctly demonstrate the following relations between the underlying sets of $\mc{M}$, $\mc{N}$, the proofs for which can be publicly verified against the commitments to $\mc{M}$ and $\mc{N}$.\vspace{0.1cm}

\noin 1. $\sett(\mc{M})\sub \sett(\mc{N})$.

\noin 2. $\sett(\mc{M})\nsub \sett(\mc{N})$.

\noin 3. $\sett(\mc{M}) = \sett(\mc{N})$ \vspace{0.1cm}

\noin Before we describe the protocols, we note a few basic facts. Clearly, we have \vs $$\sett(\mc{M}) = \sett(\mc{N})\LRA \sett(\mc{M}) \sub \sett(\mc{N})\;\bigwedge\; \sett(\mc{N}) \sub \sett(\mc{M}).$$ Furthermore, with notations as before, we have \vs $$\sett(\mc{M})\sub \sett(\mc{N})\LRA \exists\; N:\;\Pi(\mc{M})^N\equiv 0\Mod{\Pi(\mc{N})}.$$ Likewise, to show that $\sett(\mc{M})\nsub \sett(\mc{N})$, it suffices to show that there exists an integer $p$ such that \vs $$p\notin \{-1,1\}   \;\bigwedge\;\Pi(\mc{M})\equiv 0\Mod{p} \;\bigwedge\; \GCD(\Pi(\mc{N}),{p})=1.$$ 


\begin{Prot} Protocol for the containment of underlying sets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noin \textbf{Input:} Elements $a_1,a_2\in\mb{G}$; commitments $A_1 = a_1^{\Pi(\mc{M})}\;,\;A_2 = a_2^{\Pi(\mc{N})}$ to multisets $\mc{M}$, $\mc{N}$.

\noin \textbf{Claim:} $\sett(\mc{N})\sub \sett(\mc{M})$. \vs

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \item The Prover $\mP$ computes $N:= \max\{\mf{n}_j:1\leq j\leq n \}$ and \vs $$A_3:= a_1^{\Pi(\mc{M})^N}.$$ He sends $A_3$ and $N$ to the Verifier $\V$.

\noin 2. $\mP$ computes a non-interactive proof for \verb|PoPolyDLog|$[(a_1, A_1),\;(a_2, A_3),\;X^N]$ and sends it to $\V$.

\noin 3. $\mP$ computes a non-interactive proof for \verb|PoKE|$[A_2,A_3]$ and sends it to $\V$.

\noin 4. $\V$ verifies the two proofs and accepts if and only if both are valid.\qed \end{enumerate}

\vspace{0.15cm}

\begin{Prot} Protocol for the non-containment of underlying sets.\end{Prot}\vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$. 

\noin \textbf{Input:} Elements $a_1,a_2\in\mb{G}$; commitments $A_1 := \ttt{Com}(a_1, \mc{M}) = a_1^{\Pi(\mc{M})}\;,\;A_2 := \ttt{Com}(a_2, \mc{N})= a_2^{\Pi(\mc{N})}$ to multisets $\mc{M}$, $\mc{N}$.

\noin \textbf{Claim:} $\sett(\mc{M})\nsub \sett(\mc{N})$. \vs

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \item The Prover chooses an integer $p$ such that $p\in \sett(\mc{M})\setminus \sett(\mc{N}).$ and computes $b_1: = a_1^p$. He sends $b_1$ to the Verifier $\V$ long with a non-interactive proof for \verb|PoKE|$[b_1, A_1]$.

\noin 2. $\mP$ computes a non-interactive proof for \verb|RelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$ and sends it to $\V$.

\noin 3. $\V$ verifies that $b_1\notin \{ a_1, a_1^{-1}\}$ and the proofs for \verb|PoKE|$[b_1, A_1]$, \verb|RelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$. He accepts if and only if both proofs are valid.\qed \end{enumerate}






\subsection{\fontsize{11}{11}\selectfont Aggregating the knowledge of multiple exponents}

In this section, we discuss protocols for aggregating the proofs of knowledge of multiple exponents and proofs of certain relations between these exponents. This amounts to demonstrating relations between multiple sets/multisets through non-interactive proofs that can be publicly verified against the commitments to these sets/multisets. The proofs consist of elements of the hidden order $\mb{G}$ and $\lam$-bit integers arising from the remainders of the exponents modulo the prime challenges. Using Lemma 1.3 and a few more techniques, we have designed the protocols so that the number of $\mb{G}$-elements is constant and hence, independent of the number of exponents involved. The proof sizes are $\bO(n)$ since they consist of $\bO(n)$ $\lam$-bit integers. However, in practice, this is a lot more efficient in terms of the communication complexity than proofs with $\bO(n)$ group elements.

The first protocol in this section allows us demonstrate the knowledge of multiple integer exponents when they share a common base. We call this protocol the \textit{Proof of Aggregated Knowledge of the Exponents 1} or \verb|AggKE-1| for short. We provide an argument of knowledge for the relation:

\[
  \mc{R}_{{\ttt{AggKE-1}}}[a,\; \mc{A}] = \left\{\begin{array}{l}
    (a\in\mb{G}\;,\; \mc{A} = (a_1,\cdots, a_n)\in\mb{G}^n);\\ 
    (d_1,\cdots,d_n)\in\bz^n):  \\
    a_i = a^{d_i}\;\forall\; i
  \end{array}\right\}
\]
\vspace{0.05cm}


\begin{Prot} \normalfont \textit{Proof of aggregated knowledge of exponents} 1 (\verb|PoAggKE-1|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a\in\mb{G} $, $(b_1,\cdots,b_n)\in \mb{G}^n$ for some integer $n\geq 1$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that $a^{d_i} = b_i$ for $i = 1,\cdots, n$

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item \normalfont 1. The Fiat-Shamir heuristic generates $\lamb$-bit challenge $\gamma$.

\noin 2. The Prover $\mc{P}$ computes \vs $$\wti{g}:= g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sends it to the Verifier $\mc{V}$.

%\noindent 3. $\mc{P}$ computes \vs $$b:= \prod\limits_{i=1}^n b_i^{\gamma^i} \in \mb{G}.$$

\noin 3. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$. 

\noin 4. $\mc{P}$ computes the integers $r_i:= d_i\Mod{l}$ and the integers $q, r,\wti{q},\wti{r}$ such that \vs $$\slim_{i=1}^n d_i\gamma^i = ql+r\;\;,\;\; \slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r},\;\;\;r,\wti{r}\in[l]$$ and \vs $$Q:= a^q\;,\; \weck{g}:= g^{\wti{q}}.$$ He sends $Q, \weck{g}, (r_1,\cdots,r_n)$ to the Verifier.

\noin 5. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 6. $\mP$ computes integers $q_0, r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0\;,\;r_0\in[l] .$$ He computes $Q_0:= a^{q_0}$ and sends it to $\V.$

\noindent 7. $\mc{V}$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$b := \prod\limits_{i=1}^n b_i^{\gamma^i}\;,\;b_0 := \prod\limits_{i=1}^n b_i^{\gamma_0^i}\;,$$ \vspace{-0.2cm} $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i\Mod{l}\;,\;r_0:=\slim_{i=1}^n r_i\gamma_0^i\Mod{l}.$$ 

\noin 8. $\V$ verifies the equations \vs $$Q^la^r\sta b\;\bigwedge\;(Q_0)^la^{r_0}\sta b_0\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta\wti{g}.$$ He accepts if and only if all equations hold.\qed  \end{enumerate}

Thus, the proof consists of three $\mb{G}$-elements and $n$ $\lam$-bit integers. In particular, the number of $\mb{G}$-elements is constant-sized and independent of the number of exponents. For the security of the protocol, it is necessary that the challenge $\gamma_0$ is generated \textit{after} the remainders $r_1,\cdots,r_n$ have been committed. In a non-interactive setting, this means the hashing algorithm that generates $\gamma_0$ takes the vector $(r_1,\cdots,r_n)\in [2^{\lam+1}]^n$ of remainders modulo $l$ as one of its inputs. Hence, the remainders $r_i:= d_i\Mod{l}$ must be honestly computed by the Prover in order to succeed at the additional task of computing the element $Q_0\in\mb{G}$ such that $(Q_0)^la^{r_0} = b_0$.



\vspace{0.2cm}

\begin{Prop} The protocol \verb|PoAggKE-1| is an argument of knowledge for the relation\\ $\mc{R}_{{\ttt{AggKE-1}}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The equation $Q_0^la^{r_0} = b_0$ implies that $\mP$ possesses rationals $d_1,\cdots,d_n$ such that $r_i\equiv d_i\Mod{l}$ and 
$a_i^{d_i} = b_i$. Furthermore, we have $\wti{g} = (\weck{g})^lg^{\wti{r}}$ and hence, the adaptive root assumption implies that with \op, \vs $$\wti{g} = g^{(\slim_{i=1}^n d_i^{n\lam}\gamma^i)+lk} $$ for some integer $k$. Since the $\lam$-bit prime $l$ is randomly generated, the discrete logarithm between $g,\wti{g}$ is randomly and uniformly distributed modulo $l$. Hence, the Schwartz-Zippel lemma implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}.$$ Now, the fractional root assumption implies that with \op, $\slim_{i=1}^n d_i^{n\lam}\gamma^i\in\bz$. From Lemma 1.3, it follows that with \op, $(d_1,\cdots,d_n)\in\bz^n$.\end{prf}

\bigskip

In the next protocol, we generalize the protocol \verb|PolyDLog| to multiple discrete logarithms. We provide an argument of knowledge for the relation: 
\[
  \mc{R}_{\ttt{MultPolyDLog}}[a,\; (b_1,\cdots, b_n),\; (f_1,\cdots,f_k)] = \left\{\begin{array}{l}
    (a\in\mb{G},\; (b_1,\cdots, b_n)\in\mb{G}^n);\\
    (f_1,\cdots,f_k)\in\bz[X_1,\cdots,X_n]^k;\\ 
    (d_1,\cdots,d_n)\in\bz^n)\;: \\
    b_i = a^{d_i}\;\forall\; i\;\bigwedge \;\\   f_j(d_1,\cdots,d_n) = 0\;\forall\; j 
  \end{array}\right\}
\] 

\noin The soundness of the protocol hinges on the Schartz-Zippel lemma for multivariate polynomials, which we state here.

\begin{Lem} $\mr{(Schwartz\text{-}Zippel)}:$ Let $F$ be a field and let $f\in F[X_1,\cdots,X_n]$ be a polynomial. Let $r_1,\cdots,r_n$ be selected randomly and uniformly from a subset $S\sub F$. Then \vspace{-0.1cm}$$\mbf{Prob}[f(r_1,\cdots, r_n) = 0] \leq \frac{\deg(f)}{|S|}.$$\end{Lem}


\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of multivariate polynomial relation between discrete logarithms}\\ (\verb|PoMultPolyDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a\in\mb{G} $, $(b_1,\cdots,b_n)\in \mb{G}^n$ for some integer $n\geq 1$; public $n$-variate polynomials $f_j(X_1,\cdots,X_n)\in \bz[X_1,\cdots,X_n]$ ($j=1,\cdots,n$).

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that:

\noindent- $a^{d_i} = b_i$ for $i = 1,\cdots, n$.\\
- $f_j(d_1,\cdots,d_n) = 0$ for $j = 1,\cdots, k$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noindent 2. $\mc{P}$ computes \vs $$\wti{g}:=g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sends it to the Verifier $\mc{V}$.

\noindent 3. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.
 
\noindent 4. $\mc{P}$ computes the integers $r_i:=d_i\Mod{l}\;\; (i=1,\cdots, n)$ and the integers $\wti{q}, q, \wti{r}, r$ such that \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\slim_{i=1}^n d_i\gamma^i = ql+r\;,\;\;\;\wti{r}, r\in [l] .$$

\noin 5. $\mP$ computes $Q:= a^q\;,\;\weck{g}:= g^{\wti{q}}$ and sends $Q$, $\weck{g}$, $(r_1,\cdots,r_n)$ to  $\V$. 

\noin 6. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 7. $\mP$ computes the integers $q_0, r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0\;,\;r_0\in[l] .$$ He computes $Q_0:= a^{q_{0}}$ and sends $Q_0$ to $\V$.

\noindent 8. $\mc{V}$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i\Mod{l}\;,\;r_0:= \slim_{i=1}^n r_i\gamma_0^i\Mod{l}.$$

\noin 9. $\V$ computes \vs $$b:= \pl_{i=1}^n b_i^{\gamma^i}\;,\;b_0:= \pl_{i=1}^n b_i^{\gamma_0^i}.$$

\noindent 10. $\mc{V}$ verifies the equations \vs $$ Q^{l} a^{r} \sta b \;\;\bigwedge\;\;(Q_0)^{l} a^{r_{0}} \sta b_0 \;\;\bigwedge\;\; (\weck{g})^lg^{\wti{r}} \stackrel{?}{=}\wti{g} \;\;\bigwedge\;\;\Big( \bigwedge\limits_{j=1}^k  f_j(r_1,\cdots,r_n) \stackrel{?}{\equiv} 0\Mod{l} \Big).$$ He accepts the validity of the claim if and only if all equations hold.\qed \end{enumerate}


\vspace{0.1cm}

Thus, the proof consists of five $\mb{G}$-elements and $n$ $\lam$-bit integers. We note that the additional challenge $\gamma_0$ is necessary for the security of the protocol. A malicious Prover $\mP_{\mr{mal}}$ could forge a fake proof as follows.

\noin 1. $\mP_{\mr{mal}}$ computes integers $r_1,\cdots,r_n\in[l]$ such that \vs $$ \slim_{i=1}^n d_i^{n\lam}\gamma^i\equiv\slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l} \;,\;\Big( \bigwedge\limits_{j=1}^k f_j(r_1,\cdots,r_n) \equiv 0\Mod{l}$$ but $d_i\not\equiv r_i\Mod{l}\Big)$ for some or all indices $i$. The malicious Prover can succeed in this task with non-negligible probability.

\noin 2. $\mP_{\mr{mal}}$ then sends $r_1,\cdots,r_n$ to the Verifier.

\noin 3. The Verifier is thus tricked into believing that $f(d_1,\cdots,d_n) = 0$, which might not necessarily be the case.

Now, in our protocol, $\gamma_0$ is randomly generated by the Fiat-Shamir heuristic \textit{after} the Prover sends $(r_1,\cdots,r_n)$. In a non-inertactive setting, this means the hashing algorithm that generates the challenge $\gamma_0$ takes the $\lam$-bit integers $(r_1,\cdots,r_n)$ as one of its inputs. Hence, we have \vs $$\Prob\Big(\slim_{i=1}^n d_i\gamma_0^i \equiv \slim_{i=1}^n r_i\gamma_0^i \Mod{l}\;\Big|\; d_i\not\equiv r_i\Mod{l}\;\text{for some } i\Big) = \negl(\lam). $$ Hence, the elements $(r_1,\cdots,r_n)$ must be honestly computed in order to succeed at the additional task of computing the element $\what{Q}_0$ such that \vs $$(\what{Q}_0)^la^{\what{r}_0} = \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ with a non-negligible probability.

\begin{comment} Although the proof is linear in size because of the $\lam$-bit integers $r_1,\cdots,r_n$, the number of $\mb{G}$-elements in this proof is constant. Since the group elements are much larger than $\lam$-bits, the communication complexity is substantially smaller that sending over $n$ separate arguments of knowledge. For instance, when $\lam = 128$, the group elements are of bit-size $3072$ with a RSA group, $6656$-bits with an imaginary quadratic class group and $3300$-bits with a Jacobian of a genus three hyperelliptic curve.\end{comment}

An important special case is where $f$ is the $(n+1)$-variate polynomial \vs $$f(X_1,\cdots,X_n, X_{n+1}) := \big(\pl_{i=1}^n X_i \big)- X_{n+1}.$$ We will need this case for some of the subsequent protocols. \vspace{0.2cm}


\begin{Prop} The protocol \verb|PoMultPolyDLog| is an argument of knowledge for the relation $\mc{R}_{{\tt{MultPolyDLog}}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) Since the equation $Q_0^l a^{r_0} = \pl_{i=1}^n b_i^{\gamma_0^i}$ holds, the adaptive root assumption implies that with \op, the Prover possesses rationals $d_1,\cdots,d_n$ such that: 

\noin - $a^{d_i} = b_i$ for $i=1,\cdots,n$ and 

\noin - $\sum\limits_{i=1}^n d_i\gamma_0^i\equiv \sum\limits_{i=1}^n r_i\gamma_0^i\Mod{l}.$ 

Since $\gamma_0$ is randomly generated after the Prover has committed $(r_1,\cdots,r_n)$, $\gamma_0$ is randomly and uniformly distributed modulo $l$. Hence, it follows that with \op,\\ $d_i\equiv r_i\Mod{l}$ for every index $i$. Now, \vs $$\Prob\left(f(d_1,\cdots,d_n)\equiv 0\Mod{l} \;\Big|\; f(d_1,\cdots,d_n)\neq 0 \right) = \negl(\lam) .$$ Since $l$ was a randomly generated $\lam$-bit prime, it follows that with \op, $f(d_1,\cdots,d_n) = 0$. Furthermore, the equation \vs $$\wti{g} = (\weck{g})^lg^{\wti{r}} $$ implies that $\wti{g} = g^{lk+\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$ for some integer $k$. Since $l$ is randomly generated \textit{after} the Prover sends $\wti{g}$, the adaptive root assumption implies that with \op, $\wti{g} = g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$. The fractional root assumption implies that with \op, $\slim_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$ and hence, with \op, $d_1,\cdots,d_n\in\bz$.\end{prf} 


\noindent We now discuss a relation that is a dual to the relation \verb|AggKE-1|. We provide an argument of knowledge for the following relation: 

\[
  \mc{R}_{{\ttt{AggKE-2}}}[\mc{A},\;A] = \left\{\begin{array}{l}
    (\mc{A} = (a_1,\cdots, a_n)\in \mb{G}^n,\; A\in\mb{G})\;\\ 
    (d_1,\cdots,d_n)\in\bz^n) :  \\
     A = a_i^{d_i}\;\forall\; i
  \end{array}\right\}
\]
\vspace{0.1cm}

\noin Given elements $a_1,\cdots,a_n$ such that \vs $$A = a_1^{d_1} =\cdots = a_n^{d_n} $$ where the integers $d_i$ are known to him, the Prover can efficiently compute $d:= \LCM(d_1,\cdots,d_n)$ and  using Shamir's trick, an element $a\in\mb{G}$ such that $a^d = A$ in runtime $\mbf{O}(n\log(n))$. Now, the protocol \verb|PoAggKE-1|$[a,\;(a_1,\cdots,a_n)]$ and \verb|PoKE|$[a,\;A]$ would demonstrate that the Prover possesses the discrete logarithms between $a_i$ and $A$ for every $i$. However, these protocols do not prove that these discrete logarithms are, in fact, integers. To that end, a Prover needs to demonstrate that the rationals $d/d_i$ ($i=1,\cdots, n$) are integers. This can be achieved by the Prover producing the element \vs $$\wti{g}:= g^{\slim_{i=1}^{n}d_i^{n\lam}\gamma^i} $$ for some randomly generated $\lam$-bit integer $\gamma$. Lemma 1.3 and the fractional root assumption then imply that with overwhelming probability, the $d/d_i$ are integers.

\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated knowledge of exponents} 2 (\verb|PoAggKE-2|): \end{Prot}\vspace{-0.25cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$ 

\noindent \textbf{Inputs:} $(a_1,\cdots,a_n) \in \mb{G}^n$, $A\in\mb{G}$.

\noindent \textbf{Claim:} The Prover posseses integers $d_1,\cdots,d_n$ such that $a_i^{d_i} = A$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes the integers \vs $$D:= \LCM(d_1,\cdots,d_n)\;,\;\what{d}_i:= D/d_i\;(i=1,\cdots,n).$$ Using Shamir's trick, he computes an element $a\in\mb{G}$ such that $a^D = A$. He sends $a$ to the Verifier $\mc{V}$ along with a non-interactive \verb|PoKE|$[a,\;A]$.

\noin 2. The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noin 3. $\mc{P}$ computes $$\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sends it to the Verifier $\mc{V}$. 

\noin 4. $\mc{P}$ computes a non-interactive proof for \verb|AggKE-1|$[a,\;\{a_1,\cdots,a_n\}]$ and sends it to $\mc{V}$.

\noin 5. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 6. $\mc{P}$ computes $R:= D\Mod{l}$ and $\weck{a}:= a^{(D-R)/l}$. He sends $\weck{a}, R$ to $\mc{V}$.

\noin 7. $\mc{P}$ computes the integers $\what{r}_i:= \what{d}_i\Mod{l}$ ($i=1,\cdots,n$) and the integers $\what{q},\what{r}$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q} l + \what{r}\;,\;\what{r}\in [l].$$ He computes $\what{Q}:= a^{\what{q}}$ and sends $\what{Q},\; (\what{r}_1,\cdots,\what{r}_n)$ to $\mc{V}$.

\noin 8. $\mc{P}$ computes the integers ${r}_i:= {d}_i\Mod{l}$ ($i=1,\cdots,n$) and the integers $q,r,\wti{q},\wti{r}$ such that \vs $$\slim_{i=1}^n d_i\gamma^i = ql+r\;,\;\slim_{i=1}^n {d}_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\;\;r,\wti{r}\in[l] $$ He computes ${Q}:= a^q$, $\weck{g}:= g^{\wti{q}}$ and sends ${Q}, \weck{g}$ to $\mc{V}$.

\noin 9. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 10. $\mc{P}$ computes the integers $\what{q}_0,\what{r}_0$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q}_0l+\what{r}_0\;,\;\what{r}_0\in[l].$$ He computes $\what{Q}_0:= a^{q_0}$ and sends ${Q}_0$ to $\mc{V}$.

\noin 11. $\mc{V}$ verifies that $(\what{r}_1,\cdots,\what{r}_n, R)\in [l]^{n+1}$ and independently computes $r_i\equiv \what{r}_i^{-1}R\Mod{l}$ ($i=1,\cdots,n$) and \vs $$\what{r}:= \slim_{i=1}^n \what{r}_i\gamma^i\Mod{l}\;,\;\wti{r}:= {\slim_{i=1}^n r_i^{n\lam}\gamma^i}\Mod{l}\;,\; \what{r}_0:= \slim_{i=1}^n \what{r}_i\gamma_0^i\Mod{l}$$

\noin 12. $\mc{V}$ verifies the equations \vs $$(\weck{a})^la^R\sta A  \;\bigwedge\; (\what{Q})^l a^{\what{r}}\sta \pl_{i=1}^{n} a_i^{\gamma^i}\;\bigwedge\;(\what{Q}_0)^la^{\what{r}_0}\sta \pl_{i=1}^{n} a_i^{\gamma_0^i} \;\bigwedge\; (\weck{g})^lg^{\wti{r}} \sta \wti{g}.$$ He accepts the validity of the claim if and only if all equations hold and the proofs for \verb|PoKE|$[a,\;A]$, \verb|AggKE-1|$[a,\;(a_1,\cdots,a_n)]$ are valid.\qed \end{enumerate}

\vspace{0.2cm}

We note that the additional challenge $\gamma_0$ is necessary for the security of this protocol. The Prover commits the integer $\slim_{i=1}^n d_i^{n\lam}\gamma^i$ by computing \vs $$\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sending it to the Verifier \textit{before} the challenge $l$ is generated by the Fiat-Shamir heuristic. However, a malicious Prover $\mP_{\mr{mal}}$ could forge a fake proof as follows:

\noin 1. $\mP_{\mr{mal}}$ chooses integers $e_1,\cdots,e_n$ and sends $g^{\slim_{i=1}^n e_i\gamma^i}$ to the Verifier instead of $g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$

\noin 2. $\mP_{\mr{mal}}$ chooses integers $r_1,\cdots,r_n\in [l]$ such that \vs $$\slim_{i=1}^n (Dd_i^{-1})\gamma^i \equiv \slim_{i=1}^n (Dr_i^{-1})\gamma^i \Mod{l}\;,\; \slim_{i=1}^n e_i\gamma^i\equiv \slim_{i=1}^n r_i\gamma^i \Mod{l},$$ but $d_i\not\equiv r_i\Mod{l}$ for some or all indices $i$. The Prover $\mP_{\mr{mal}}$ can do so  with non-negligible probability.

\noin 3. Thus, the Verifier is tricked into believing that $\slim_{i=1}^n d_i^{n\lam}\gamma^i$ is an integer, which  might not necessarily be the case. In fact, even if the Fiat-Shamir heuristic outputs the additional challenge $\gamma_0$ before the remainders $(r_1,\cdots,r_n, R)$ are committed, $\mP_{\mr{mal}}$ can forge a fake proof with non-negligible probability. 

Now, in our protocol, $\gamma_0$ is randomly generated by the Fiat-Shamir heuristic \textit{after} the Prover sends $(\what{r}_1,\cdots,\what{r}_n, R)$. Hence, we have \vs $$\Prob\Big(\slim_{i=1}^n d_i\gamma_0^i \equiv \slim_{i=1}^n r_i\gamma_0^i \Mod{l}\;\Big|\; d_i\not\equiv r_i\Mod{l}\;\text{for some } i\Big) = \negl(\lam). $$ Hence, the elements $(r_1,\cdots,r_n)$ must be honestly computed in order to succeed at the additional challenge of computing the element $\what{Q}_0$ such that \vs $$\what{Q}_0^la^{\what{r}_0}= \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ with non-negligible probability.

\noin 


\vspace{0.2cm}

\begin{Prop} The protocol $\tt{PoAggKE}$-$2$ is an argument of knowledge for the relation $\mc{R}_{{\tt{AggKE-2}}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The subprotocol \verb|PoAggKE-1|$[a,\;\{a_1,\cdots,a_n\}]$ demonstrates that with \op, the Prover possesses integers $\what{d}_1,\cdots,\what{d}_n$ such that \vs $$a_i = a^{\what{d}_i}\; (i=1.\cdots,n)$$ Furthermore, since $\gamma_0$ is randomly generated and the equation \vs $$\what{Q}_0^la^{\what{r}_0} = \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ holds, the adaptive root assumption implies that with \op, \vs $$\slim_{i=1}^n\what{r}_i\gamma_0^i\equiv \slim_{i=1}^n \what{d}_i\gamma_0^i\Mod{l}.$$ Hence, with \op, $\what{r}_i\equiv \what{d}_i\Mod{l}$ (Schwartz-Zippel).

The equation $(\weck{a})^la^R= A $ implies that with \op, the Prover possesses a rational $D\equiv R\Mod{l}$ such that $a^D = A$. Thus, with \op, the rationals $D\what{d_1}^{-1},\cdots,D\what{d_n}^{-1}$ satisfy \vs $$a_i^{D\what{d_i}^{-1}} = A \text{ for every }i.$$ Now, the Verifier independently computes \vs $$r_i:= R\what{r}_{i}^{-1}\equiv D\what{d}_i^{-1}\Mod{l}\;(i=1,\cdots,n),\;\;r:= \slim_{i=1}^n r_i\gamma^i\equiv \slim_{i=1}^n D\what{d}_i^{-1}\Mod{l},$$\vspace{-0.3cm} $$\wti{r}:= {\slim_{i=1}^n r_i^{n\lam}\gamma^i}\equiv {\slim_{i=1}^n (D\what{d}_i^{-1})^{n\lam}\gamma^i}\Mod{l}.$$ Hence, the equation $(\weck{g})^lg^{\wti{r}} = \wti{g}$ implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i}g^{kl} $$ for some integer $k$. Since the prime $l$ is randomly generated, the Schwartz-Zippel lemma implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i}. $$ The fractional root assumption implies that \vs $$\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i\;\in\;\bq$$ is a an integer and by lemma 1.3, it follows that with \op, the rationals $D\what{d_i}^{-1}$ are integers.\end{prf}




\section{\fontsize{12}{12}\selectfont Protocols for arguments of disjointness}

The goal of this section is to provide protocols for demonstrating disjointness of multiple data multisets. The proofs can be publicly verified against the succinct commitments to these multisets. To that end, we first describe a protocol whereby an honest Prover can show that the GCD of two discrete logarithms equals a third discrete logarithm while keeping the communication complexity constant. One obvious application is proving disjointness of sets in accumulators instantiated with hidden order groups. We formulate an argument of knowledge for the relation \vs  $$\mc{R}_{{\ttt{GCD}}}[(a_1,b_1),\;(a_2,b_2),\;(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} .$$ We construct a protocol that has communication complexity independent of the elements $a_i, b_i$. The protocol rests on the observation that \vs $$d_3 = \GCD(d_1, d_2)\;\; \LRA \;\;(d_1\equiv d_2\equiv 0 \Mod{d_3})\;\bigwedge \; \left(\exists \; (x_1,x_2)\in \bz^2:\; d_3 = x_1d_1+x_2d_2  \right).$$
 

\begin{Prot} \normalfont \textit{Proof of the greatest common divisor} (\verb|PoGCD|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2, a_3, b_1, b_2, b_3 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$, $d_3$ such that:

\noindent - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$, $a_3^{d_3} = b_3$\\
\noindent - $\GCD(d_1, d_2) = d_2$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}$, $b_{1,3}:= a_1^{d_3}$ and sends them to the Verifier $\V$.

\noindent 2. He generates non-interactive proofs for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|EqDLog|$[(a_3, b_3),\; (a_1, b_{1,3})]$ and sends them to $\mc{V}$.

\noindent 3. $\mc{P}$ generates non-interactive proofs for \verb|PoKE|$[b_{1,3},\;b_1 ]$ and \verb|PoKE|$[b_{1,3},\;b_{1,2} ]$ and sends them to $\V$.

\noindent 4. $\mc{P}$ uses Bezout's algorithm to compute integers $e_1, e_2$ such that \vs $$e_1d_1 + e_2d_2 = d_3\;\;,\;\; |e_1| < d_2,\; |e_2| < d_1 .$$

\noindent 5. $\mc{P}$ computes \vs $$\wti{b}_1:= b_1^{e_1},\;\; \wti{b}_{1,2}:= b_{1,2}^{e_2} $$ and sends them to $\V$. He generates non-interactive proofs for \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$. He sends these proofs to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies all of the proofs he receives in addition to the equation $\wti{b}_1\wti{b}_{1,2}\stackrel{?}{=} b_{1,3}$. He accepts the validity of the claim if and only if all of these proofs are valid.\qed \end{enumerate}

\noindent An important special case is where $\GCD(d_1, d_2) = 1$. In this case, Step 3 is redundant and hence, the proof size is smaller. We call this special case the Protocol for \textit{Relatively Prime Discrete Logarithms} or \verb|RelPrimeDLog| for short: $$\mc{R}_{{\ttt{RelPrimeDLog}}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} .$$ 

\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Relatively Prime Discrete Logarithms} (\verb|PoRelPrimeDLog|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2, b_1, b_2 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$ such that:

\noindent - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$\\
\noindent - $\GCD(d_1, d_2) = 1$
 

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}$ and sends it to the Verifier $\V$. 

\noindent 2. $\mP$ computes a non-interactive proof for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$ and sends it to $\mc{V}$.

\noindent 3. $\mc{P}$ uses the algorithm \verb|Bezout|  to compute integers $e_1, e_2$ such that $e_1d_1 + e_2d_2 = 1$.

\noin 4. $\mc{P}$ computes \vs $$\wti{b}_1:= b_1^{e_1}\;\;,\;\; \wti{b}_{1,2}:= b_{1,2}^{e_2} $$ and sends them to $\V$. 

\noin 5. $\mP$ generates non-interactive proofs for \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$ and sends them to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies the equation $\wti{b}_1\wti{b}_{1,2}\stackrel{?}{=} a_1$ and the proofs for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$. He accepts the validity of the claim if and only if all of these proofs are valid.\qed \end{enumerate}

\vspace{0.2cm}

\begin{Prop} The Protocols \verb|PoGCD|, \verb|PoRelPrimeDLog| are arguments of knowledge for the relations $\mc{R}_{{\tt{GCD}}}$, $\mc{R}_{{\tt{RelPrimeDLog}}}$ respectively in the generic group model.\end{Prop}

\begin{prf} Since the relation \verb|RelPrimeDLog| is a special case of the relation \verb|GCD|, it suffices to show that the protocol \verb|PoGCD| is correct and sound. Furthermore, since we showed that \verb|PoEqDLog| is correct and sound, we may assume without loss of generality that - with notations as in the protocol \verb|PoGCD| - \vs $$a_1 = a_2 = a_3\;,\; {b}_{1,2} = b_2\;,\;{b}_{1,3} = b_3 .$$ Now, the protocols \verb|PoKE|$[b_3, b_1]$, \verb|PoKE|$[b_3, b_2]$, \verb|PoKE|$[a_1, b_3]$ imply that with \op, the Prover $\mP$ possesses integers $d_1,d_2,d_3$ such that \vs $$a_1^{d_1} = b_1\;,\;a_1^{d_2} = b_2\;,\;a_1^{d_3} = b_3\;,\;\GCD(d_1,d_2)\equiv 0\Mod{d_3}.$$ 

Furthermore, the Prover $\mP$ sends elements $\wti{b}_1, \wti{b}_2\in \mb{G}$ such that $\wti{b}_1\wti{b}_2 = b_3$ along with the non-interactive proofs for \verb|PoKE|$[b_1,\wti{b}_1]$, \verb|PoKE|$[b_2,\wti{b}_2]$. Hence, with \op, the Prover possesses integers $e_1,e_2$ such that $e_1d_1+e_2d_2 = d_3$. Hence, it follows that with \op, $d_3 = \GCD(d_1,d_2).$ 
\end{prf}


It is easy to see that the \verb|PoGCD| may be combined with the protcol \verb|PoMultPolyDLog| to provide an argument of knowledge for the relation \vs $$\mc{R}_{{\ttt{LCM}}}[(a_1,b_1),(a_2,b_2), \; (a_3, b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\LCM(d_1,d_2)=d_3 \} .$$ This argument of knowledge can demonstrate that for data multisets $\mc{D}_1,\mc{D}_2, \mc{D}_3$, we have \vs $$\mc{D}_3 = \mc{D}_1\cup \mc{D}_2 $$ by setting \vs $$ d_i = \prod\limits_{d\in\mc{D}_i} x\;\;(i=1,2,3).$$\vspace{0.2cm}


\begin{comment}

\noin \textbf{Multiplicities in multiset commitments:} As before, let $g$ be a randomly generated element in a hidden order group $\mb{G}$. Let $\mc{M}, \mc{N}$ be multiset and let \vs $$\protect{\verb|Com|}(M):= g^{\pl_{x\in \mc{M}} x^{\mr{mult(x,M)}}}\;,\;\protect{\verb|Com|}(N):= g^{\pl_{x\in \mc{N}} x^{\mr{mult(x,N)}}}$$ be the commitments to $\mc{M}$, $\mc{N}$ respectively.




For a set $\mc{D}$, a Prover can use the protocol \verb|PoGCD| to demonstrate that every element of $\mc{D}$ occurs with a higher multiplicity in $\mc{M}$ than in $\mc{N}$. This proof is public verifiable against the commitments to $\mc{M}$, $\mc{N}$ and $\mc{D}$. \vspace{0.15cm}

\noin 1. The Prover $\mP$ computes \vs $$\protect{\verb|Com|}(\mc{D}):= g^{\pl_{x\in \mc{D}} x}$$ and sends it to the Verifier $\V$ along with a \verb|PoE| for this exponentiation.

\noin 2. $\mP$ computes the multiplicities $m_x$, $n_x$ of every element $x\in\mc{D}$ in $\mc{M}$ and $\mc{N}$ respectively.

\noin 3. $\mP$ computes \vs $$a_1:= g^{{\pl_{x\in \mc{D}} x^{n_x}}}\;,\; a_2 := g^{{\pl_{x\in \mc{D}} x^{n_x+1}}} $$ and sends them to $\V$ along with a non-interactive proof for \verb|EqDLog|$[(g, \protect{\verb|Com|}(\mc{D})),\;(a_1,a_2)]$.

\noin 4. $\mP$ computes a non-interactive proof for \verb|PoGCD|$[(g, a_2),\;(g, \protect{\verb|Com|}(\mc{N})),\;(g,a_1)]$ and sends it to $\V$. 

\noin 5. $\mP$ computes a non-interactive proof for \verb|PoKE|$[a_2, \protect{\verb|Com|}(\mc{M})]$ and sends it to $\V$.

\noin 6. $\V$ verifies the three proofs and accepts if and only if they are all valid.
 

\end{comment}



\subsection{\fontsize{11}{11}\selectfont Protocols for aggregated arguments of disjointness}

We now use the protocols \verb|AggKE-1| and \verb|AggKE-2| and a few more techniques to generalize the protocol \verb|RelPrimeDLog| to multiple discrete logarithms. Consider a setting where we have $n$ accumulators $\Acc_1,\cdots,\Acc_n$ instantiated in the same group $\mb{G}$ and with the common genesis state $g\in\mb{G}$. Let $\mc{D}_i$ denote the data inserted into $\Acc_i$ and let $A_i$ denote the accumulated digest of $\Acc_i$. Thus, \vs $$A_i = g^{\Pi(\mc{D}_i)} .$$ 

Suppose a Prover needs to demonstrate to a Verifier (with access to the accumulated digests) that the data sets/multisets $\mc{D}_i$ are pairwise disjoint, while keeping the communication complexity to a bare minimum. In particular, the Verifier should not need to access the data sets/multisets $\mc{D}_i$ which might be too large for the storage capacity of the verifying node. A straightforward way would be to provide the $n\choose 2$ proofs of pairwise disjointness using the protocol $\tt{RelPoRelPrimeDLog}$. But this would entail $\mbf{O}(n^2)$ group elements and $\mbf{O}(n^2)$ $\lam$-bit integers, which we would like to avoid. Instead, we provide a protocol whereby the Prover can demonstrate the pairwise disjointness with a constant number of $\mb{G}$-elements and $2n$ $\lam$-bit integers.

We call the next protocol the \textit{Aggregated Knowledge of Relatively Prime Exponents-1} or\\ \verb|AggRelPrimeDLog-1| for short. We provide an argument of knowledge for the following relation:

\[
  \mc{R}_{\ttt{AggRelPrimeDLog-1}}[a,\; \mc{A}] = \left\{\begin{array}{l}
    (a\in\mb{G},\;  \mc{A}:=(a_1,\cdots, a_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\bz^n): \\
    a_i = a^{d_i}\;\forall\;i\;\;,\;\; \GCD(d_i, d_j) = 1)\;\forall \;i\neq j   	
  \end{array}\right\}
\] 

\noin The protocol rests on the following elementary lemma.

\begin{Lem}\label{lcm} Let $d_1,\cdots,d_n$ be non-zero integers. Set \vs $$D:= \pl_{i=1}^n d_i\;,\; \what{d}_i:= \frac{D}{d_i}\;(i=1,\cdots,n) \;,\;\what{D}:= \slim_{i=1}^n \what{d}_i.$$ Then \vs $$\GCD(d_i,d_j)=1\;\forall\;i\neq j\;\; \LRA \;\; \GCD(D, \what{D}) = 1 .$$\end{Lem}

\begin{prf} First, suppose there exists a pair $i,j$ such that $\GCD(d_i,d_j)> 1$. Then $\GCD(d_i,d_j)$ divides $\what{d}_k$ for every index $k$ and in particular, $\GCD(d_i,d_j)$ divides $\what{D}$. Hence, $\GCD(D,\what{D})$ is divisible by $\GCD(d_i,d_j)$.

Conversely, suppose $\GCD(d_i,d_j)=1\;\forall\;i\neq j$. Then for every index $i$, $\what{D}\equiv \what{d}_i\Mod{d_i} $ and hence, $\GCD(\what{D}, d_i) = \GCD(\what{d}_i, d_i) = 1$. Thus, $\GCD(D,\what{D})$ = 1.\end{prf}

\noin Recall that given integers $d_1,\cdots,d_n$ and elements $a,A\in\mb{G}$ such that \vs $$a^D = a^{\pl_{i=1}^n d_i} = A ,$$ the \textbf{RootFactor} algorithm allows us to compute elements $a_i$ such that $a_i^{d_i} = A$ in runtime $\mbf{O}(n\log(n))$. Thus, a Prover can compute the element \vs $$\what{A}:= \pl_{i=1}^n a_i$$ in runtime $\mbf{O}(\log(D)\log(\log(D)))$ with the \textbf{RootFactor} algorithm followed by $n$ group multiplications.

\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 1 \\(\verb|PoAggRelPrimeDLog-1|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Element $a\in\mb{G}$, $(a_1,\cdots,a_n)\in \mb{G}^n$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that:

\noindent - $a^{d_i} = a_i$ for $i = 1,\cdots, n$.

\noindent - $\GCD(d_i, d_j) = 1$ for every pair $i\neq j$.


\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integers \vs $$D:=\pl_{i=1}^n d_i\;\;,\;\; \what{D}:= \slim_{i=1}^n \pl_{\substack{1\leq j\leq n \\ j\neq i}} d_j.$$

\noin 2. $\mP$ computes $A:= a^D,\;\what{A}:= a^{\what{D}} $ (the latter using the \textbf{RootFactor} algorithm) and sends $A,\what{A}$ to the Verifier $\V$.

\begin{comment}
\noin 3. $\mP$ computes a non-interactive proof for \verb|AggKE-1|$[a,\;(a_1,\cdots,a_n)]$ and sends it to $\V$.

\noin 4. \end{comment}


\noin 3. $\mP$ computes a non-interactive proof for \verb|MultPolyDLog|$[a,\;(a_1,\cdots,a_n,A, \what{A}),\; (f,\what{f})]$ where \vs $$f(X_1,\cdots,X_{n+2}):= \big(\pl_{i=1}^n X_i\big) -X_{n+1}\;\;,\;\;\what{f}(X_1,\cdots, X_{n+2}):= \big(\slim_{i=1}^n \pl_{\substack{1\leq j\leq n \\ j\neq i}} X_j\big) - X_{n+2}$$ and sends the proof to $\V$.

\noin 4. $\mP$ generates a non-interactive proof for \verb|RelPrimeDLog|$[(a,A),\;(a,\what{A})]$ and sends it to $\V$.

\noin 5. $\V$ verifies the three proofs and accepts the validity of the claim if and only if all proofs are valid.\qed \end{enumerate}

Recall that the protocol \verb|PoMultPolyDLog|$[a,\;(a_1,\cdots,a_n,A, \what{A}),\; (f,\what{f})]$  contains\\ \verb|PoAggKE-1|$[a,\;(a_1,\cdots,a_n)]$ as a subprotocol. So this last protocol demonstrates that there exist $n$ integers $d_i$ such that $a^{d_i} = a_i$ and the product $\pl_{i=1}^n d_i$ is relative prime with the integer given by the $(n-1)$-th elementary symmetric function \vs $$\slim_{i=1}^n \pl_{\substack{1\leq j\leq n \\ j\neq i}} d_j. $$ By the preceding lemma, this is equivalent to the integers $d_i$ being pairwise co-prime. Thus, the proof consists of a constant number of $\mb{G}$-elements and $n+\bO(1)$ $\lam$-bit integers. 



\begin{Prop} The protocol \verb|PoAggRelPrimeDLog-1| is an argument of knowledge for the relation $\mc{R}_{\tt{AggRelPrimeDLog-1}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The two \verb|MultPolyDLog| proofs imply that with \op, $\mP$ possesses integers $D$, $\what{D}$, $d_1,\cdots,d_n$ such that \vs $$D = \pl_{i=1}^n d_i\;,\;\what{D} = \slim_{i=1}^n \frac{D}{d_i}   \;,\;a^{d_i} = a_i\;\forall\;i \;,\;a^{D} = A\;,\; a^{\what{D}} = \what{A} .$$ Furthermore, the proof for \verb|RelPrimeDLog|$[(a,A),\;(a,\what{A})]$ implies that $\GCD(D,\what{D}) = 1$. Hence, by the preceding lemma, the integers $d_i$ are pairwise co-prime.\end{prf}



\bigskip

\noin Given elements $a_1, a_2\in \mb{G}$ and equations \vspace{-0.15cm}$$a_1^{d_1} = b_1,\cdots, a_1^{d_m}= b_m,\;\; a_2^{e_1} = c_1,\cdots, a_2^{e_n} = c_n,$$ a Prover may provide a proof that he possesses the integers \vs $$d_1,\cdots, d_m,\;e_1,\cdots, e_n$$ and that every pair $d_i, e_j$ is relatively prime. Clearly, the latter part is equivalent to showing that the integers \vs $$d:=\LCM(d_1,\cdots, d_m)\;,\;e:=\LCM(e_1,\cdots, e_n)$$ are relatively prime. Our approach is to compute elements $B = a_1^d,\;C:= a_2^{e}$. We then use the protocols \verb|AggKE-1| and \verb|AggKE-2| to provide arguments of knowledge that $d, e$ are divisible by $\{d_1,\cdots, d_n \}$, $\{e_,\cdots,e_n \}$ repectively. We then  use the protocol \verb|RelPrimeDLog| to show that $\GCD(d, e) = 1$.


We call the next protocol the \textit{Aggregated Knowledge of Relatively Prime Exponents} 2 or\\ \verb|AggRelPrimeDLog-2| for short. We provide an argument of knowledge for the following relation:\vspace{-0.3cm}

\[
  \mc{R}_{\ttt{AggRelPrimeDLog-2}}[a_1, a_2,\; \mc{B}, \mc{C}] = \left\{\begin{array}{l}
    ((a_1,a_2)\in\mb{G}^2,\;\\
     \mc{B}:=(b_1,\cdots, b_m)\in\mb{G}^m,\;\mc{C}:= (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n)\;: \\
    (b_i = a_1^{d_i}\;\;\bigwedge\;\; c_j = a_2^{e_j}\;\bigwedge\; \GCD(d_i, e_j) = 1)\;\forall \;i,j   	
  \end{array}\right\}
\] 

\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms 2}\\ (\verb|PoAggRelPrimeDLog-2|) :\end{Prot}\vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2\in \mb{G}$, Elements $\mc{B} = (b_1,\cdots, b_m)$, $\mc{C} = (c_1,\cdots, c_n)$ of $\mb{G}^n$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_m$,\; $e_1,\cdots,e_n$ such that:

\noindent - $a_1^{d_i} = b_i$ for $i = 1,\cdots, m$.

\noindent - $a_2^{e_j} = c_j$ for $j = 1,\cdots, n$.

\noindent - $\GCD(d_i, e_j) = 1$ for every pair $i, j$.


\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes \vs $${d}:= \pl_{i=1}^m d_m\;\;,\;\; {e}:= \pl_{j=1}^n e_n.$$

\noindent 2. $\mc{P}$ computes $B:= a_1^{d},\;\;C:= a_2^{e}\;\in\mb{G}$ and sends $B, C$ to the Verifier $\mc{V}$.

\noindent 3. $\mc{P}$ generates a non-interactive proof for \vs $$\ttt{MultPolyDLog}[a_1,\;(b_1,\cdots,b_m, B),\; (\pl_{i=1}^m X_i) -X_{m+1}]$$ and sends it to $\mc{V}$.

\noin 4. $\mc{P}$ generate a non-interactive proof for \vs $$ \ttt{MultPolyDLog}[a_2,\;(c_1,\cdots,c_n, C),\; (\pl_{j=1}^n X_j) -X_{n+1}]$$ and sends it to $\mc{V}$.

%\noindent 5. $\mc{P}$ generates non-interactive proofs for \verb|AggKE-1|$[a_1,\mc{B}]$ and \verb|AggKE-1|$[a_2,\mc{C}]$ and sends them to the Verifer.

\noindent 5. $\mc{P}$ generates a non-interactive proof for \verb|RelPrimeDLog|$[(a_1, B),\;(a_2, C)]$ and sends it to $\mc{V}$. 

\noindent 6. $\mc{V}$ accepts the validity of the claim if and only if all of these proofs are valid.\qed \end{enumerate}

Note that the protocol $\ttt{PoMultPolyDLog}[a_1,\;(b_1,\cdots,b_m, B),\; (\pl_{i=1}^m X_i) -X_{m+1}]$ contains\\ \verb|AggKE-1|$[a_1,\;\mc{B}]$ as a subprotocol. Similarly, $\ttt{PoMultPolyDLog}[a_2,\;(c_1,\cdots,c_n, C),\; (\pl_{j=1}^n X_i) -X_{n+1}]$ contains \verb|AggKE-1|$[a_2,\;\mc{C}]$ as a subprotocol. Thus, the proof consists of a constant number of $\mb{G}$-elements and $2(m+n)+\bO(1)$ $\lam$-bit integers.\vspace{0.2cm}


\begin{Prop} The Protocol \verb|AggRelPrimeDLog-2| is an argument of knowledge for the relation $\mc{R}_{\tt{AggRelPrimeDLog-2}}$ in the generic group
model.\end{Prop}

\begin{prf} (Sketch) Since each of the subprotocols was shown to be correct and sound in the preceding seciton, this follows immediately.\end{prf}

\noindent \textbf{An example:} We discuss an example of an application of this last protocol. Consider two families \vspace{-0.1cm}$$\mc{A}_1 = (A_{1,1},\cdots,A_{1, m})\;\; , \;\; \mc{A}_2 = (A_{2,1},\cdots,A_{2, n}) $$ of accumulators instantiated using the same group $\mb{G}$ of hidden order. As usual, each data element is represented by a $\lam$-bit prime. Let $g_1$, $g_2$ be the genesis states for all accumulators in $\mc{A}_1$ and $\mc{A}_2$, respectively. 

As usual, each data element is represented by a distinct $\lamb$-bit prime. Let $\mc{D}_{1, i}$ ($\mc{D}_{2, j}$) denote the data set/multiset inserted into the accumulator $A_{1, i}$ (respectively, $A_{2, j}$) and write $$\mc{D}_1 := \bigcup\limits_{i=1}^m  \mc{D}_{1,i}\;\; ,\;\;\mc{D}_2 = \bigcup\limits_{j=1}^n  \mc{D}_{2,j}.$$ Suppose a Verifier (with access to the accumulated digests) wants to verify that the unions are disjoint, i.e. $\mc{D}_1 \cap \mc{D}_2 = \emptyset.$ An honest Prover could simply provide a non-interactive proof for the protocol \verb|AggRelPrimeDLog-2|$[(g_1, \mc{A}_1) ,\;(g_2, \mc{A}_2)]$. In particular, the proof can be verified without access to the data sets $\mc{D}_{1}, \mc{D}_{2}$. \\


Consider a setting where we have data multisets $\mc{D}_1,\cdots, \mc{D}_n$ in an accumulator. Let $A$ denote the accumulated digest, $w_i$ the witness for $\mc{D}_i$ and $d_i$ the product of all elements of $\mc{D}_i$. 

Suppose a Prover needs to demonstrate that the multisets $\mc{D}_i$ are pairwise disjoint to a Verifier who has access to the witnesses $w_1,\cdots,w_n$ but not the data multisets. A straightforward approach would be to provide a proof for \verb|RelPrimeDLog|$[(w_i, A),\;(w_j, A)]$. But such a proof would contain $\mbf{O}(n^2)$ $\mb{G}$-elements and $\mbf{O}(n^2)$ $\lam$-bit integers, which is impractical for larger values of $n$.

Instead, we provide a protocol whereby the proof consists of a constant number of $\mb{G}$-elements and $n$ $\lam$-bit integers. The protocol rests on two simple observations. First, note that for integers $d_1,\cdots,d_n$, \vs $$\GCD(d_i,d_j)=1\;\forall\;i\neq j\;\; \LRA\;\; \pl_{i=1}^n d_i= \LCM(d_1,\cdots,d_n),$$ as can be easily proved by induction. Secondly, if an element $w\in \mb{G}$ can be expressed in the form \vspace{-0.15cm}$$w = \prod\limits_{i=1}^n w_i^{x_i},\;\;(x_1,\cdots,x_n)\in\bz^n,$$ then \vs $$w^{\LCM(d_1,\cdots,d_n)} = A^{k} $$ for some integer $k$ where \vs $$k = \slim_{i=1}^n x_i\frac{\LCM(d_1,\cdots,d_n)}{d_i}.$$ Furthermore, the Prover can efficiently compute the integers \vs $$d:= \pl_{i=1}^n d_i = \LCM(d_1,\cdots,d_n)\;,\;\what{d}_i:= \pl_{\substack{1\leq j\leq n\\ j\neq i}} d_j\;\; (i=1,\cdots,n)\;\;,\;\; \what{d} := \slim_{i=1}^n \what{d}_i.$$ Now, $d$ is relatively prime to $\what{d}$. Hence, the Prover can efficiently compute integers $e,\what{e}$ such that $$de+\what{d}\what{e} = 1\;,\; A^e(\pl_{i=1}^n w_i)^{\what{e}} = w.  $$ In particular, since $\pl_{i=1}^n w_i$ is publicly computable, the Prover can demonstrate, with constant communication complexity, that $w$ is expressible as a product $\pl_{i=1}^n w_i^{x_i}$ where the $x_i$ are integers known to him. If the Prover can also demonstrate that $$w^{\prod\limits_{i=1}^n d_i} = A,$$ (with a subprotocol virtually identical to \verb|MultPolyDLog|), then this implies that \vspace{-0.15cm}$$\LCM(d_1,\cdots,d_n)\equiv 0\Mod{ \prod\limits_{i=1}^n d_i},$$ which forces equality. In what follows, we provide an argument of knowledge for the relation 

\[
  \mc{R}_{\ttt{AggRelPrimeDLog-3}}[(w_1,\cdots, w_n),\; A] = \left\{\begin{array}{l}
    (A\in\mb{G},\; (w_1,\cdots, w_n)\;\in\mb{G}^n);\\
    ((d_1,\cdots,d_n)\in\bz^n)\;: \\
    w_i^{d_i} = A\;\forall\;i\\
   	\GCD(d_i, d_j) = 1\;\forall \;i,j: i\neq j
  \end{array}\right\}
\] 

\vspace{0.2cm}



\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 3\\ (\verb|PoAggRelPrimeDLog-3|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $(w_1,\cdots, w_n)\in \mb{G}^n$, $A\in\mb{G}$

\noindent \textbf{Claim:} The Prover possesses integers $ d_1,\cdots, d_n$ such that:

\noindent - $w_i^{d_i} = A$ for $i = 1,\cdots,n$.

\noindent - $\GCD(d_i, d_j) = 1$ for every pair $i\neq j$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes the integers \vs $$D := \prod\limits_{i=1}^n d_i\;\;,\;\;\what{d}_i = \pl_{\substack{1\leq j\leq n\\ j\neq i}} d_j\;(i=1,\cdots,n)\;\;,\;\; \what{D}:=\slim_{i=1}^n\what{d}_i.$$ \vs

\noin 2. Using Shamir's trick, $\mc{P}$ computes an element $w\in\mb{G}$ such that $w^D = A$ and sends $w$ to the Verifier $\mc{V}$.

\noin 3. $\mP$ uses the Euclidean algorithm to compute integers $e,\what{e}$ such that $eD+\what{e}\what{D} = \GCD(D,\what{D}) = 1.$

\noin 4. $\mP$ computes $$A_0:= A^{e}\;,\;W := \big(\pl_{i=1}^n w_i\big)^{\what{e}}.$$ He sends $A_0,W$ to $\V$ along with non-interactive proofs for \verb|PoKE|$[A,\; A_0]$ and \verb|PoKE|$[(\pl_{i=1}^n w_i),\; W]$.

\noin 5. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma$.

\noin 6. $\mc{P}$ computes \vs $$\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sends $\wti{g}$ to $\mc{V}$.

\noin 7. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 8. $\mc{P}$ computes \vs $$R:= D\Mod{l}\;,\; \weck{w}:= w^{(D-R)/l}$$ and sends $\what{w}$ to $\mc{V}$.

\noin 9. $\mc{P}$ computes the integers \vs $$\what{r}_i:= \what{d}_i\Mod{l}\;,\;{r}_i:= {d}_i\Mod{l}$$ and sends $(r_1,\cdots,r_n)$ to $\mc{V}$.

\noin 10. $\mP$ computes the integers $\wti{q},\what{q}, \wti{r}, \what{r}$ such that \vs $$\slim_{i=1}^n {d}_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;\;,\;\; \slim_{i=1}^n \what{d}_i\gamma^i = \what{q}l+\what{r}\;\;,\;\;\;r,\what{r}\in [l].$$

\noin 11. $\mP$ computes \vs $$ \what{Q}:= w^{\what{q}}\;,\;\weck{g}:= g^{\wti{q}}$$ and sends $Q, \what{Q}, \weck{g}$ to $\V$.

\noin 12. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 13. $\mP$ computes the integers $\what{q}_0, \what{r}_0$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q}_0 l+\what{r}_0\;\;,\;\;\what{r}_0\in [l]$$ He computes $\what{Q}_0:= w^{\what{q}_0} $ and sends it to $\V$.

\noin 14. $\V$ verifies that $(r_1,\cdots,r_n)\in [l]^{n}$. He independently computes \vs $$R:= \pl_{i=1}^n r_i\Mod{l} \;,\;\what{r}_i = Rr_i^{-1}\Mod{l}\;\;(i=1,\cdots,n),$$\vspace{-0.3cm} $$\wti{r}:= \slim_{i=1}^n {r}_i^{n\lam}\gamma^i\Mod{l} \;,\; \what{r}:= \slim_{i=1}^n \what{r}_i\gamma^i\Mod{l}\;,\;\what{r}_0:= \slim_{i=1}^n \what{r}_i\gamma_0^i\Mod{l}.$$

\noin 15. $\V$ verifies the equations \vs $$(\what{Q})^lw^{\what{r}}\sta \pl_{i=1}^n w_i^{\gamma^i} \;\bigwedge\; (\what{Q}_0)^lw^{\what{r}_0}\sta \pl_{i=1}^n w_i^{\gamma_0^i}\;\bigwedge\; A_0\cdot W\sta w\;\bigwedge\; (\weck{w})^lw^R\sta A\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta\wti{g}$$ and the two \verb|PoKE|s from Step 4. He accepts if and only if all equations hold and all proofs are valid. 
\qed \end{enumerate}

\noin The proof consists of a constant number of $\mb{G}$-elements and $n+\bO(1)$ $\lam$-bit integers.

\vspace{0.1cm}


\begin{Prop} The protocol \verb|PoAggRelPrimeDLog-3| is an argument of knowledge for the relation $\mc{R}_{\tt{AggRelPrimeDLog-3}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The equations verified in step 15 imply that with \op, there exist integers $d_1,\cdots,d_n, D$ such that \vs $$D = \pl_{i=1}^n d_i\;,\;A = w^D\;,\; A= w_i^{d_i}\;\forall \;i .$$ Furthermore, since we have $A_0W = w$ and the proofs for \verb|PoKE|$[A,\;A_0]$ and \verb|PoKE|$[(\pl_{i=1}^n w_i),\; W]$, it follows that, in particular, $w$ is expressible as a product \vs $$w =\pl_{i=1}^n w_i^{x_i}\;,\;(x_1,\cdots,x_n)\in\bz^n.$$ Hence, \vs $$w^{\LCM(d_1,\cdots,d_n)} = A^k$$ for some integer $k$. Thus, $\LCM(d_1,\cdots,d_n)$ is divisible by the product $\pl_{i=1}^n d_i$ . Hence, the integers $d_i$ are pairwise co-prime.\end{prf}



\bigskip

Next, we discuss a dual to the Protocol \verb|AggRelPrimeDLog-2|. Given elements $B, C\in \mb{G}$ and subsets \vspace{-0.15cm}$$\mc{B} = \{b_1,\cdots, b_m\}\in \mb{G}^m \;\;,\;\; \mc{C} = \{c_1,\cdots, c_n\}\in \mb{G}^n,$$ an honest Prover may provide a proof that he possesses integers \vs $$\{d_1,\cdots, d_m\}\;,\; \{e_1,\cdots, e_n\}$$ such that $b_i^{d_i} = B,\; c_j^{e_j} = C$ and every pair $d_i, e_j$ is relatively prime. We call this relation the \textit{Aggregated Relatively Prime Discrete Logarithms} 4 or \verb|AggRelPrimeDLog-4| for short. We provide an argument of knowledge for the following relation:
\[
  \mc{R}_{\ttt{AggRelPrimeDLog-4}}[\mc{B}, \mc{C}, B, C] = \left\{\begin{array}{l}
    ((B,C)\in\mb{G}^2,\;\\
     \mc{B} = (b_1,\cdots,b_m)\in\mb{G}^m\;,\;\mc{C} = (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n)\;: \\
    (B = b_i^{d_i},\; C = c_j^{e_j}\;\bigwedge \; \GCD(d_i, e_j) = 1)\;\forall \;i,j
  \end{array}\right\}
\] 

\noindent \textbf{An example:} Consider the case where $B$, $C$ are accumulated digests for accumulators $\Acc_1$ and $\Acc_2$ respectively. Let $\mc{D}_1,\cdots,\mc{D}_m$ and $\mc{E}_1,\cdots,\mc{E}_m$ be data sets inserted into the two accumulators. Let $w_i$, $u_j$ denote the membership witnesses for $\mc{D}_i$, $\mc{E}_j$ and let $d_i$, $e_j$ denote the products of elements of $\mc{D}_i$, $\mc{E}_j$ respectively($1\leq i\leq m$, $1\leq j\leq n$). Then $$w_i^{d_i} = B,\; u_j^{e_j} = C.$$ Suppose a Prover needs to prove the disjointness of the unions $$\mc{D} := \bigcup\limits_{i=1}^m \mc{D}_i\;\;,\;\;\mc{E} := \bigcup\limits_{j=1}^n \mc{E}_j$$ to a Verifier with access to the witnesses \vspace{-0.15cm}$$\mc{W}:= \{w_1,\cdots,w_m \}\;\;,\;\;\mc{U}:= \{u_1,\cdots,u_n \}.$$

A straightforward approach would be to provide $mn$ distinct proofs that $\GCD(d_i, e_j) = 1$ for every pair $d_i,e_j$. But such a proof would entail $\mbf{O}(mn)$ elements of $\mb{G}$ in addition to $\mbf{O}(mn)$ $\lamb$-bit integers. Instead, the Prover could simply send a non-interactive proof for the relation \verb|AggRelPrimeDLog-4|$[(\mc{W}, B),\;(\mc{U}, C)]$. The proof consists of a constant number of $\mb{G}$-elements and $2(m+n)+\bO(1)$ $\lamb$-bit integers.\vspace{0.1cm} 


\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 4\\ (\verb|PoAggRelPrimeDLog-4|) :\end{Prot}\vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $B, C\in \mb{G}$,\;  $\mc{B} = (b_1,\cdots, b_m)\;\in\;\mb{G}^m$,\;\; $\mc{C} = (c_1,\cdots, c_n)\;\in\;\mb{G}^n$

\noindent \textbf{Claim:} The Prover possesses integers $ d_1,\cdots, d_m$,\; $e_1,\cdots,e_n$ such that:

\noindent - $b_i^{d_i} = B$ for $i = 1,\cdots, m$.

\noindent - $c_j^{e_j} = C$ for $j = 1,\cdots, n$.

\noindent - $\GCD(d_i, e_j) = 1$ for every pair $i, j$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mc{P}$ computes \vs $${d}:= \LCM(d_1,\cdots,d_m)\;\;,\;\; {e}:= \LCM(e_1,\cdots,e_n).$$

\noindent 2. Using Shamir's trick, $\mP$ computes elements $b, c \in \mb{G}$ such that \vspace{-0.15cm}$$b^{d} = B,\;\; c^{e} = C$$ and sends $b,c$ to the Verifier $\mc{V}$.

\noindent 3. $\mc{P}$ generates non-interactive proofs for \verb|AggKE-2|$[\mc{B},\; B]$ and \verb|AggKE-2|$[\mc{C},\; C]$ and sends the proofs to $\mc{V}$.

\noindent 4. $\mc{P}$ generates non-interactive proofs for \verb|AggKE-1|$[b,\;\mc{B}]$ and \verb|AggKE-1|$[c,\; \mc{C}]$ and sends them to $\mc{V}$.

\noindent 5. $\mc{P}$ generates a non-interactive proof for \verb|RelPrime|$[(b,B),\;(c,C)]$ and sends the proof to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies all of these proofs and accepts the validity of the claim if and only if all proofs are valid.\qed \end{enumerate}

\noindent Thus, the proof for \verb|AggRelPrimeDLog-4| consists of a constant number of $\mb{G}$-elements and \\$2(m+n)+\bO(1)$ $\lam$-bit integers arising from the proofs for \verb|AggKE-2|$[\mc{B},\; B]$ and \verb|AggKE-2|$[\mc{C},\; C]$.


\begin{Prop} The protocol \verb|AggRelPrimeDLog-4| is an argument of knowledge for the relation $\mc{R}_{\tt{AggRelPrimeDLog-4}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The proofs for \verb|AggKE-2|$[\mc{B}, B]$ and \verb|AggKE-1|$[b,\mc{B}]$ imply that, with overwhelming probability, there exist integers $d,d_1,\cdots,d_m,\what{d}_1,\cdots,\what{d}_m$ such that \vs $$b^d = B\;,\; b^{\what{d}_i}= b_i\;,\; b_i^{d_i}= B\;\forall\; i.$$ Similarly, the proofs for \verb|AggKE-2|$[\mc{C},\; C]$ and \verb|AggKE-1|$[c,\;\mc{C}]$ imply that with overwhelming probability, there exist integers $e,e_1,\cdots,e_n$, $\what{e}_1,\cdots,\what{e}_n$ such that \vs $$c^e = C\;,\; c^{\what{e}_j}= c_j\;,\;c_j^{e_j}= C\;\forall\; j.$$ 

Finally, the proof for \verb|RelPrimeDLog|$[(b,B),\;(c,C)]$ implies with \op, that $\GCD(d,e) = 1$. Hence, $\GCD(d_i,e_j) = 1\;\forall\;i,j$.\end{prf}

\bigskip

\section{\fontsize{12}{12} Applications}

\subsection{\fontsize{11}{11} Verifiably outsourcing storage}

The protocols we have developed so far allow us to build a mechanism whereby a client can verifiably outsource data multisets to a server node. The client stores constant-sized commitments to these multisets and can query the server for information regarding these data sets. The server node, in turn, submits this information with proofs that can  be publicly verified against the constant-sized commitments stored by the client.

As before, $\mb{G}$ is a group of hidden order in which we assume the adaptive root and strong-RSA assumptions to hold. The (fixed) element $g\in\mb{G}$ is a randomly generated element of $\mb{G}$. For a multiset $\mc{M}$, the commitment to $\mc{M}$ is given by the element \vs $$\protect{\verb|Com|}(g, \mc{M}):= g^{\Pi(\mc{M})}\in\mb{G}$$ where $\Pi(\mc{M})$ is the product of all elements of $\mc{M}$, with the appropriate multiplicities. \vspace{0.15cm}

\noin \textbf{Proof of storage:} To ask the server $\mP$ to prove that he is storing the data multiset $\mc{M}$, the client $\V$ can generate a random element $g_1\in\mb{G}$ and ask the server to provide the element \vs $$\protect{\verb|Com|}(g_1, \mc{M}):= g_1^{\Pi(\mc{M})}\in\mb{G}$$ along with a non-interactive proof for \verb|EqDLog|$[(g, \protect{\verb|Com|}(g, \mc{M})),\;(g_1, \protect{\verb|Com|}(g_1, \mc{M}))]$. The communication complexity is constant and in particular, is independent of the size of $\mc{M}$.\vspace{0.15cm}

\noin \textbf{Updates:} When the data multiset is to be updated, the client sends the changes to the server. The server stores these changes and sends back the updated commitment to the multiset, along with a non-interactive proof of exponentiation (\verb|PoE|) so that the client can verify that the new commitment is the correct one. \vspace{0.15cm}

\noin \textbf{Multiset sums:} For multisets $\mc{M}_1,\cdots,\mc{M}_n$, the server node can verifiably send the client the commitment $A_{\Pi}$ for the sum \vs $$\sum\limits_{i=1}^n \mc{M}_i = \Big\{\big(\sum\limits_{i=1}^n \mul(\mc{M}_i, x)\big)\times x:\; x\in\bigcup\limits_{i=1}^n \sett(\mc{M}_i)\Big\} $$ using the Protocol \vs $$\ttt{PoMultPolyDLog}[g,\; (A_1,\cdots,A_n,A_{\Pi}),\;(\pl_{i=1}^{n}X_i)-X_{n+1})].$$ The proof consists of a constant number of $\mb{G}$-elements and $2n$ $\lam$-bit integers.

\bigskip

\noin \textbf{Multiset differences:} For multisets $\mc{M}$, $\mc{N}$, the difference $\mc{M}\sm \mc{N} $ has commitment \vs $$\protect{\verb|Com|}(g, \mc{M}\sm \mc{N}) = g^{\frac{\Pi(\mcM)}{\Pi(\mcM\cap \mc{N})}} .$$ So the Prover can combine the Protocols \verb|PoGCD| and \verb|PoMultPolyDLog| to verifiably send the commitment to $\mc{M}\sm \mc{N} $. 

\bigskip

\noin \textbf{Multiset intersections:} Consider a setting where a client $\mc{V}$ who stores commitments $A_i:= \protect{\ttt{Com}}(g, \mc{M}_i)$ for data multisets $\mc{M}_1, \cdots, \mc{M}_n$ needs a commitment $\protect{\verb|Com|}(g, \mc{M}_{\tt{\cap}})$ to the intersection \vs $$\mc{M}_{\tt{\cap}}:=\bigcap\limits_{i=1}^n \mc{M}_i .$$ In keeping with the rest of this paper, we would like to design a protocol that allows the Prover to do so while keeping the communication complexity to a minimum. Note that \vs $$d = \GCD(d_1,\cdots,d_n)\; \LRA\; (d|d_i\;\forall\;i)\;\bigwedge\; \exists\;(e_1,\cdots,e_n)\in\bz^n:\;\slim_{i=1}^n e_id_i = d .$$\vs Furthermore, \vs $$d = \GCD(d_1,\cdots,d_n)\; \LRA \left(\frac{d_1}{d},\cdots, \frac{d_n}{d}\right)\in \bz^n\;\bigwedge\; \GCD\left(\frac{d_n}{d},\cdots, \frac{d_n}{d}\right)=1.$$ Hence, by changing the base from $g$ to $a:= g^d$, we can reduce this to the case where the GCD of the $n$ integers is $1$. So, the Prover can verifiably send the commitment for $\mc{M}_{\tt{\cap}}$ as follows:


\begin{Prot} Protocol for the intersection of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mcM_i) := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$ whose elements are $\lam$-bit primes; an element $A_{\tt{\cap}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integers \vs $$d_i:= \frac{\Pi(\mc{M}_i)}{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}\;\; (i=1,\cdots,n).$$

\noin 2. The Prover $\mP$ generates a non-interactive proof for $\ttt{AggKE-1}[A_{\tt{\cap}},\;(A_1,\cdots,A_n)]$ and sends it to the Verifier $\V$.

\noin 3. $\mP$ uses Bezout's algorithm to compute integers $e_1,\cdots,e_n$ such that $\;\slim_{i=1}^n e_id_i = 1$.

\noin 4. $\mP$ computes the elements $\weck{A}_i := a^{e_i}\; (i=1,\cdots,n)$ and sends them to the $\V$.

\noin 5. $\mP$ generates a non-interactive proof for $\ttt{MultPolyDLog}[A_{\tt{\cap}},\; (A_1,\cdots,A_n, \weck{A}_1,\cdots,\weck{A}_n),\;f]$ where \vs $$f(X_1,\cdots,X_{2n}):= \slim_{i=1}^n X_iX_{n+i} - 1. $$

\noin 6. $\V$ verifies the proofs and accepts if and only if they are all valid.\qed \end{enumerate}

This proof entails $n+\bO(1)$ group elements and $\bO(n)$ $\lam$-bit integers. As before, we would like to keep the number of group elements constant. To this end, the Prover can sample $\lam$-bit integers $\gamma$ until he finds one such that \vs $$\GCD(\slim_{i=1}^n d_i\gamma^i, d_1) = 1 .$$ He can then send a non-interactive proof for \vs $$\ttt{RelPrimeDLog}[(A_{\tt{\cap}},\pl_{i=1}^n A_i^{\gamma^i}),\;(A_{\tt{\cap}}, A_1)].$$ When the elements of the multisets $\mc{M}_i$ are all $\lam$-bit primes, the integers $\Pi(\mcM_i)$ are $\lam$-rough and hence, finding an appropriate $\gamma$ takes runtime $\bO(1)$. This is because for an arbitrary $\gamma$ and any $\lam$-bit prime $p$, the Schwartz-Zippel lemma implies that \vs $$\mbf{Prob}\big(\slim_{i=1}^n d_i\gamma^i \equiv 0\Mod{p} \big) = \negl(\lam). $$ 

\begin{comment}
However, this is no longer true when the integers $\Pi(\mcM_i)$ have prime divisors of bit-size $< \lam$. While such a protocol would be \textit{sound} in the sense that a Prover could not forge a fake proof, it would not be \textit{correct}, meaning an honest Prover might not be able to efficiently generate a proof. To get around this problem, we use lemma 1.3. 

For an arbitrary $\lam$-bit integer $\gamma$, consider the integer $\slim_{i=1}^n d_i^{n\lam}\gamma^i.$ If the Prover can demonstrate that $\GCD(\slim_{i=1}^n d_i^{n\lam}\gamma^i, d_i)= 1$, then it follows that $\GCD(d_1,\cdots,d_n) = 1$. So it boils down to the expected runtime for finding such an integer $\gamma$. 

For a randomly chosen $\gamma$, suppose we have \vs $$ e:= \GCD(\slim_{i=1}^n d_i\gamma^i, d_1) > 1 .$$ Let $p$ be any prime divisor of $e$. Since $p$ does not divide all of the coefficients of the polynomial $\slim_{i=1}^n d_i^{n\lam}X_i\in\bz[X]$, it follows that \vspace{-0.25cm} $$\mbf{Prob}\big(\slim_{i=1}^n d_i\gamma^i \equiv 0\Mod{p^{n\lam}} \big) = \negl(\lam).$$ The Prover can efficiently compute \vs $$e:= \GCD(\slim_{i=1}^n d_i\gamma^i, d_1)\;,\;\wti{e}:= \GCD(\slim_{i=1}^n d_i\gamma^i, e^{n\lam}).$$ He sends the commitments to these integers and demonstrates the relations between the discrete logarithms using the protocols $\ttt{PoGCD}$ and $\ttt{MultPolyDlog}$. Now, $$e^{n\lam-1}\equiv 0\Mod{\wti{e}} \imp \GCD(d_1,\cdots,d_n) = 1.$$ To see this, let $p$ be a prime dividing $\GCD(d_1,\cdots,d_n)$ and let $k$ be the largest integer such that $p^k$ divides $e$. Then $p^{kn\lam}$ divides every $d_i^{n\lam}$ and hence, $p^{kn\lam}$ divides $\wti{e}$. On the other hand, $p^{kn\lam}$ does not divide $e^{n\lam-1}$, a contradiction.  \end{comment} 


As before, we say a multiset $\mcM$ is $\lam$-\textbf{rough} if the integer $\Pi(\mcM)$ is $\lam$-rough or equivalently, if all elements of $\mcM$ are primes $> 2^{\lam-1}$.

\begin{Prot} Protocol for the intersection of $\lam$-rough multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mcM_i) := g^{\Pi(\mc{M}_i)}$ for $\lam$-rough multisets $\mc{M}_i$ whose elements are $\lam$-bit primes; an element $A_{\tt{\cap}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integers \vs $$d_i:= \frac{\Pi(\mc{M}_i)}{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}\;\; (i=1,\cdots,n).$$

\noin 2. $\mP$ generates non-interactive proofs for $\pr{\ttt{AggKE-1}}[A_{\tt{\cap}},\;(A_1,\cdots,A_n)]$, $\ttt{PoKE}[g,\;A_{\tt{\cap}}]$ and sends them to the Verifier $\V$.

\noin 3. $\mP$ samples $\lam$-bit primes $\gamma$ until he finds one such that \vs $$ \GCD(\pl_{i=1}^n d_i, \slim_{i=1}^n d_i\gamma^i) = 1.$$ He sends $\gamma$ to $\V$.

\noin 4. $\mP$ computes $\wti{A}:= g^{\pl_{i=1}^n d_i}$ and sends $\wti{A}$ to $\V$ along with a non-interactive proof for\\ $\ttt{MultPolyDLog}[A_{\tt{\cap}},\; (A_1,\cdots,A_n, \wti{A}),\;(\pl_{i=1}^n X_i)-X_{n+1}]$.

\noin 5. $\mP$ generates a non-interactive proof for the relation $\ttt{RelPrimeDLog}[(A_{\tt{\cap}}, \wti{A}),\;(A_{\tt{\cap}}, \pl_{i=1}^n A_i^{\gamma^i})]$ and sends it to $\V$.

\noin 6. $\V$ verifies all the proofs he receives and accepts if and only if they are all valid.\qed \end{enumerate}


\noin Thus, the proof consists of a constant number of $\bG$-elements and $2n+\bO(1)$ $\lam$-bit integers. 
 






\bigskip


\noin \textbf{Multiset unions:} The techniques in the last protocol also allow a server node to verifiably send over a commitment for the union of multisets $\mcM_1,\cdots,\mcM_n$. The proof that this commitment is valid can be publicly verified against the commitments $\ttt{Com}(g,\mc{M}_i)\;(i=1,\cdots,n)$ which the client stores. The basic idea here is as follows.

\begin{Lem} For integers $d_1,\cdots,d_n$, set $\what{d}_j:= \pl_{\substack{1\leq i\leq n \\ i\neq j}} d_i \;\;(j=1,\cdots,n)$. Then we have \vspace{-0.2cm} $$ \LCM(d_1,\cdots,d_n)\cdot \GCD(\what{d}_1,\cdots,\what{d}_n) = \pl_{i=1}^n d_i.$$ \end{Lem}

We omit the proof since it is straightforward. Thus, the following are equivalent:\vspace{0.1cm}

\noin - $\LCM(d_1,\cdots,d_n) = d$

\noin - $d_i\big| d\;\forall\; i$ and there exist integers $\what{e}_1,\cdots,\what{e}_n$ such that \vs $$\pl_{i=1}^n d_i  =  d\cdot\slim_{i=1}^n \what{e}_i\what{d}_i.$$

\noin - The rationals $\frac{d}{d_i}$ are integers and \vs $$\GCD(\frac{d}{d_1},\cdots,\frac{d}{d_n}) = 1 .$$

\vspace{0.1cm}

\begin{comment}
Let $p$ be a prime and let $\mr{val}_p(N)$ denote the largest integer $x$ such that $p^x$ divides $N$. Write $k_i:= \mr{val}_p(d_i)$ for brevity. Then $\mr{val}_p(\pl_{i=1}^n d_i) = \slim_{i=1}^n k_i$ and $\mr{val}_p(\what{d}_j) = (\slim_{i=1}^n k_i)-k_i$. Hence, \vs $$\mr{val}_p(\GCD(\what{d}_1,\cdots,\what{d}_n)) = \min\big((\slim_{i=1}^n k_i)-k_i\big)_i = \slim_{i=1}^n k_i - \max(k_1,\cdots,k_n).$$ On the other hand, \vs $$\mr{val}_p(\LCM(d_1,\cdots,d_n)) = \max(k_1,\cdots,k_n).$$ Thus, \vs $$\mr{val}_p(\LCM(d_1,\cdots,d_n))+ \mr{val}_p(\GCD(\what{d}_1,\cdots,\what{d}_n)) = \mr{val}_p(\pl_{i=1}^n d_i),$$ which completes the proof. \end{comment}





\begin{Prot} Protocol for the union of $\lam$-rough multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mc{M}_i) := g^{\Pi(\mc{M}_i)}$ for lam$-rough $ multisets $\mc{M}_i$; an element $A_{\tt{\cup}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cup}} = \protect{\verb|Com|}(g, {\bigcup\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcup\limits_{i=1}^n} \mc{M}_i)}$. \vs

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integers \vspace{-0.25cm} $$d:= \Pi(\bigcup\limits_{i=1}^n \mc{M}_i)\;,\;\weck{d}_i:= \frac{\Pi(\bigcup\limits_{i=1}^n \mc{M}_i)}{\Pi(\mcM_i)}\;\;(i=1,\cdots,n).$$

\noin 2. $\mP$ generates a non-interactive proof for the relation $\ttt{AggKE-2}[(A_1,\cdots,A_n),\;A_{\tt{\cup}}]$ and sends it to the Verifier $\V$. 

\noin 3. $\mP$ uses Bezout's algorithm to compute integers $\weck{e}_1,\cdots, \weck{e}_n$ such that \vs $$\slim_{i=1}^n \weck{e}_i\weck{d}_i = 1.$$

\noin 4. $\mP$ computes the elements $\weck{A}_i:= g^{\weck{e}_i}$ and sends them to $\V$.

\noin 5. $\mP$ generates a non-interactive proof for $\ttt{MultPolyDLog}[g,\;(A_1,\cdots,A_n,\weck{A}_1,\cdots,\weck{A}_n,A_{\tt{\cup}}),\; \weck{f}]$ where \vs $$\weck{f}(X_1,\cdots,X_{2n+1}):= X_{2n+1}\Big(\slim_{i=1}^n X_{n+i}\big(\pl_{\substack{1\leq j\leq n\\ j\neq i}} X_{j}\big)\Big) - \pl_{i=1}^n X_i$$ and sends the proof to $\V$.

\noin 6. $\V$ verifies all of the proofs he receives and accepts if and only if they are valid.\qed \end{enumerate}


\noin The proof entails $n+\bO(1)$ group elements and $\bO(n)$ $\lam$-bit integers. As was the case with multiset intersections, when the multisets are $\lam$-rough, the protocol can be modified so that the number of group elements is constant.

\vspace{0.1cm}

\begin{Prot} Protocol for the union of $\lam$-rough multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mc{M}_i) := g^{\Pi(\mc{M}_i)}$ for $lam$-rough multisets $\mc{M}_i$; an element $A_{\tt{\cup}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cup}} = \protect{\verb|Com|}(g, {\bigcup\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcup\limits_{i=1}^n} \mc{M}_i)}$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Prover $\mP$ computes the integers \vspace{-0.25cm} $$d:= \Pi(\bigcup\limits_{i=1}^n \mc{M}_i)\;,\;\weck{d}_i:= \frac{\Pi(\bigcup\limits_{i=1}^n \mc{M}_i)}{\Pi(\mcM_i)}\;\;(i=1,\cdots,n).$$

\noin 2. $\mP$ generates a non-interactive proof for the relation $\ttt{AggKE-2}[(A_1,\cdots,A_n),\;A_{\tt{\cup}}]$ and sends it to the Verifier $\V$.


\noin 3. $\mP$ samples $\lam$-bit integers $\gamma$ until he finds one such that \vs $$ \GCD(d, \slim_{i=1}^n \weck{d}_i\gamma^i) =1.$$ He sends $\gamma$ to $\V$.

\noin 4. $\mP$ computes \vs $$\weck{A}:= g^{\slim_{i=1}^n \weck{d}_i\gamma^i}$$ and sends $\weck{A}$ to $\V$ along with a non-interactive proof for $\ttt{MultPolyDLog}[g,\;(A_1,\cdots, A_n, A_{\tt{\cup}}, \weck{A}), \weck{f}]$ where \vs $$\weck{f}(X_1,\cdots X_{n+2}):= X_{n+1}\Big(\slim_{i=1}^n \gamma^i\big(\pl_{\substack{1\leq j\leq n\\ j\neq i}} X_j\big)\Big) - X_{n+2}\pl_{i=1}^n X_i.$$


\noin 5. $\mP$ generates a non-interactive proof for $\ttt{RelPrimeDLog}[(g, A_{\tt{\cup}}),\;(g, \pl_{i=1}^n A_i^{\gamma^i})]$ and sends it to $\V$.

\noin 6. $\V$ verifies all the proofs he receives and accepts if and only if they are all valid. \qed \end{enumerate}

\noin The proof consists of a constant number of $\bG$-elements and $2n+\bO(1)$ $\lam$-bit integers. A server node storing the data multisets $\mcM_i$ can use this protocol to verifiably send the succinct commitment for the union $\bigcup\limits_{i=1}^n \mcM_i$. The validity of this commitment can be verified against the commitments to the $\mcM_i$ held by the client.


\bigskip


\noin \textbf{Disjointness:} The server node can verifiably demonstrate that the multisets $\mcM_1,\cdots,\mcM_n$ are pairwise disjoint using the protocol $\ttt{AggRelPrimeDLog-1}[g,\;(A_1,\cdots,A_n)]$. Similarly, for any subset $I\sub\{1,\cdots,n \}$ of indices, the server node can use the protocol $\ttt{AggRelPrimeDLog-2}$ to verifiably show that the multisets \vs $$\wti{\mcM}_1 = \bigcup\limits_{i\in I}\mcM_i\;\;,\;\;\wti{\mcM}_2 = \bigcup\limits_{j\in \{1,\cdots,n\}\sm I}\mcM_j $$ are disjoint. The proofs in both cases consist of $\bO(1)$ group elements and $2n+\bO(1)$ $\lam$-bit integers.

\bigskip

Thus, to summarize, the protocols in this paper allow the server node to verifiably send the client succinct commitments to unions, intersections, sums (and combinations thereof) of multisets for which the client holds succinct commitments.  The communication complexity is linear in the number of the committed multisets but independent of the sizes of these multisets.

\subsubsection{\fontsize{11}{11} Frequencies of elements}

Consider a setting where a client node needs to keep track of the occurrences of a certain keyword or certain blocks of keywords in the files that he possesses. If the client node suffers from a low storage capacity or weak computational power, he would prefer to outsource the files to an untrusted server node. As before, he stores succinct commitments to the data sets/multisets derived from hashing the files. This allows the server node storing his data sets/multisets to send publicly verifiable proofs about the occurrences of batches of elements in the data sets/multisets.

Let $\mc{M}_1,\cdots, \mc{M}_n$ be data multisets and let \vs $$A_i:= \ttt{Com}(g,\mc{M}_i) = g^{\Pi(\mc{M}_i)}\;\;(i=1,\cdots,n) $$ be the commitments. Suppose the server node storing the data for the client needs to identify the data multiset with the highest frequency of a data set $\mc{D}$. The protocols we have developed so far allows him to do so with a proof that the client can verify against the commitments $A_1,\cdots,A_n$.\vspace{0.1cm}

\begin{Prot} Protocol for frequency of elements in multisets $1$.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a higher frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \vs

\item The Prover $\mP$ computes \vs $$\what{A}_1:= g^{\Pi\left(\bigcup\limits_{i=2}^n \mc{M}_i\right)} $$ and sends it to the verifier $\V$ along with a non-interactive proof for \verb|AggKE-2|$[(A_2,\cdots,A_n), \what{A}_1]$. \vs

\item The Prover computes the group elements \vs $$B_1:= g^{\pl_{x\in \mc{D}} x^{\mr{mult\left(\bigcup\limits_{i=2}^n \mc{M}_i, x\right)}}}\;,\;B_2:= B_1^{\Pi(\mc{D})} \;\in\; \bG.$$ \vspace{-0.8cm}

\item $\mP$ sends $B_1, B_2$ to $\V$ along with a non-interactive \verb|PoE| for the equation $B_2= B_1^{\Pi(\mc{D})}$. \vs

\item $\mP$ compute non-interactive proofs for \verb|PoKE|$[B_2,\;A_1]$, \verb|PoGCD|$[(g, \what{A}_1),\;(g, B_2),\;(g, B_1)]$ and sends them to $\V$.\vs

\item $\V$ verifies the three proofs and accepts if and only if all of them are valid.\qed\end{enumerate}

Similarly, the following protocol allows the server to prove that every element of a certain data set $\mc{D}$ occurs with a lower frequency in $\mc{M}_1$ than in any of the multisets $\mc{M}_2,\cdots,\mc{M}_n$.

\begin{Prot} Protocol for frequency of elements in multisets $2$.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a lower frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \vs

\item The Prover $\mP$ computes \vs $$B_1:= g^{\pl_{x\in\mc{D}} x^{\mr{mult(\mc{M}_1, x)}}}\;,\; B_2 = B_1^{\Pi(\mc{D})}.$$ \vspace{-0.8cm}

\item $\mP$ sends $B_1, B_2$ to $\V$ along with a non-interactive \verb|PoE| for the equation $B_2= B_1^{\Pi(\mc{D})}$. \vs

\item $\mP$ generates non-interactive proofs for \verb|AggKE-1|$[B_2,\;(A_2,\cdots,A_n)]$ and\\ \verb|PoGCD|$[(g, A_1),\;(g, B_2),\;(g,B_1)]$ and sends them to $\V$. \vs

\item $\V$ verifies the three proofs and accepts if and only if they are all valid.\qed\end{enumerate}

\noin The next two protocols are duals to the last two. They allow the server node to verifiably identify the multiset with the highest/lowest occurrence of a data set in a setting where the client stores the membership witnesses for the multisets with respect to a single accumulated digest.

\begin{Prot} Protocol for frequency of elements in multisets $3$.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Membership witnesses $w_i$ for multisets $\mc{M}_i$ with respect to an accumulated digest $A$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a higher frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \vs

\item The Prover $\mP$ uses Shamir's trick to compute an element $\weck{w}_1\in \mb{G}$ such that \vs $$\weck{w}_1 ^{\Pi(\bigcup\limits_{i=2}^n \mc{M}_i)} = A $$ and sends it to the Verifier $\V$. \vs

\item $\mP$ computes the elements \vs $$\wti{w}_1:= w_1^{\pl_{x\in\mc{D}} x^{\mr{mult}(\bigcup\limits_{i=2}^n \mc{M}_i, x)}}\;,\; \wti{w}_1^{\Pi(\mc{D})}\;\in\;\mb{G}$$ and sends them to $\V$ along with a non-interactive \verb|PoE|. \vs

\item $\mP$ generates a non-interactive proof for \verb|AggKE-1|$[\weck{w}_1,\;\{w_2,\cdots,w_n\}]$ and sends it to $\V$. \vs

\item $\mP$ generates non-interactive proofs for \verb|PoGCD|$[(\weck{w}_1, A),\;(w_1,\wti{w}_1^{\Pi(\mc{D})}),\;(w_1,\wti{w}_1)]$ and\\ \verb|PoKE|$[\wti{w}_1^{\Pi(\mc{D})}\;,A]$ and sends them to $\V$. \vs

\item $\V$ verifies the three proofs and accepts if and only if they are all valid.\qed\end{enumerate}



\begin{Prot} Protocol for frequency of elements in multisets $4$.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Membership witnesses $w_i$ for multisets $\mc{M}_i$ with respect to an accumulated digest $A$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a lower frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt] \vs

\item The Prover $\mP$ computes an element $\what{w}_1\in\mb{G}$ such that \vs $$\what{w}_1^{\Pi(\bigcap\limits_{i=2}^n \mc{M}_i)}:= A$$ and sends $\what{w}_1$ to the Verifier $\V$ along with a non-interactive proof for \verb|AggKE-2|$[\{w_2,\cdots,w_n\},\;\what{w}_1]$. \vspace{-0.5cm}

\item $\mP$ computes \vs $$\what{A}:= \what{w}_1^{\pl_{x\in\mc{D}}x^{\mr{mult}(\mc{M}_1,x)}}\;,\;\what{A}^{\Pi(\mc{D})}\;\in\mb{G}$$ and sends them to $\V$ along with a non-interactive \verb|PoE| for the exponentiation $\what{A}^{\Pi(\mc{D})}$. \vs

\item $\mP$ generates \nons\; for \verb|PoKE|$[\what{w}_1^{\Pi(\mc{D})},\;A]$ and \verb|PoGCD|$[(w_1,A),\;(w_1, \what{A}^{\Pi(\mc{D})}),\;(w_1, \what{A})]$ and sends them to $\V$. \vs

\item $\V$ verifies the three proofs and accepts if and only if they are all valid.\qed\end{enumerate}


\subsubsection{\fontsize{11}{11} Updates}

As before, let $\mc{M}_1,\cdots, \mc{M}_n$ be multisets a client $\V$ outsources to a server node $\mP$. The client stores succinct commitments \vs $$\pr{\ttt{Com}}(g, \mc{M}_i) = g^{\Pi(\mc{M}_i)},$$ where $g$ is a randomly generated element of $\bG$. The multisets are dynamic and hence, the commitments need to be updated in response to changes. \vspace{0.15cm}

\noin \textbf{Inserts:} When the multiset $\mc{M}_1$ changes to $\mc{M}_1+\mc{M}'_1$, the server changes the commitment from $[g,\; g^{\Pi(\mc{M}_1)}]$ to $[g,\;g^{\Pi(\mc{M}_1+\mc{M}_1')}]$. He sends $g^{\Pi(\mc{M}_1+\mc{M}_1')}$ to the client along with a non-interactive $\tt{PoE}$ for the equation \vs $$(g^{\Pi(\mc{M}_1)})^{\Pi(\mc{M}_1')} =   g^{\Pi(\mc{M}_1+\mc{M}_1')}.$$  

\noin \textbf{Deletes:} Let $\mc{M}_1'$ be a multiset contained in $\mc{M}_1$ and suppose $\mc{M}_1'$ is to be deleted from $\mc{M}_1$. Broadly there are three ways of handling deletes, each with some tradeoffs. We discuss them here. \vspace{0.1cm}

\noin 1. The server node changes the commitment from $[g,\; g^{\Pi(\mc{M}_1)}]$ to $[g,\;g^{\Pi(\mc{M}_1\sm\mc{M}_1')}]$. He sends $g^{\Pi(\mc{M}_1\sm\mc{M}_1')}$ to the client along with a non-interactive $\tt{PoE}$ for the equation \vs $$(g^{\Pi(\mc{M}_1\sm\mc{M}_1')})^{\Pi(\mc{M}_1')} =   g^{\Pi(\mc{M}_1)}.$$

While this is probably the simplest way of handling deletions, the computational burden is linear in the size of $\mc{M}_1\sm\mc{M}_1'$.
\vspace{0.1cm}

\noin 2. The server node changes the commitment from $[g,\; g^{\Pi(\mc{M}_1)}]$ to $[g^{\Pi(\mc{M}'_1)},\; g^{\Pi(\mc{M}_1)}]$. He sends $g_{\mr{new}}:= g^{\Pi(\mc{M}_1')}$ to the client along with a non-interactive $\tt{PoE}$ for the equation \vs $$g^{\Pi(\mc{M}_1')} =   g_{\mr{new}}.$$

The advantage is that the runtime complexity is $\mbf{O}(\#\mc{M}_1')$. The downside is that the client needs to keep track of the different bases for the commitments as opposed to a single base $g$. This increases the communication complexity and the Prover's work when the client asks for an argument of knowledge for any relation between the multisets $\mc{M}_1,\cdots,\mc{M}_n$. 

\vspace{0.1cm}

\noin 3. The server node changes the commitment for $\mc{M}_1$ from $[g,\; g^{\Pi(\mc{M}_1)}]$ to\\ $[g^{\Pi(\mc{M}'_1)},\; g^{\Pi(\mc{M}_1)}]$. Furthermore, he updates the commitments for $\mc{M}_i$ ($i=2,\cdots,n$) from $[g,\; g^{\Pi(\mc{M}_i)}]$ to $[g^{\Pi(\mc{M}'_1)},\; g^{\Pi(\mc{M}_i+\mc{M}'_1)}]$. He sends \vs $$g_{\mr{new}}:= g^{\Pi(\mc{M}_1')}\;,\;g^{\Pi(\mc{M}_i+\mc{M}'_1)}\;(i=2,\cdots,n)$$ to the client along with the relevant non-interactive $\tt{PoE}$s.

This preserves a common base for the $n$ commitments. The runtime complexity is $\mbf{O}(n\cdot \#\mc{M}_1')$, but the $n$ exponentiations are completely parallelizable.




\bigskip

\subsection{\fontsize{11}{11} Sharded stateless blockchains}


We briefly discuss the concept of a stateless blockchain and the need for it. Currently, in every existing blockchain, every full node in the system needs to store the entire state of the blockchain in order to validate incoming transactions. This has already become cumbersome as the size of the state grows. To this end, [Tod13] suggested the concept of a \textit{stateless} blockchain. In this proposed model, every node stores the data relevant to itself and the accumulated digest. 

While this would drastically alleviate the problem of state bloat, the big tradeoff would be that in such a model, a node sending over transactions must also send over proofs attesting to the validity of these transactions. At the moment, the authentication data structure used by blockchains is that of a Merkle tree and the membership proofs are what we call Merkle branches/paths. Despite the several advantages that Merkle trees provide, a drawback is that the membership proofs cannot be batched or aggregated. Thus, a stateless model that continues to use Merkle trees as the accumulator would suffer from a bandwidth bottleneck. To address this problem, [BBF19] etc. have proposed using a cryptographic accumulator with batchable/aggregable membership and non-membership proofs. In this regard, accumulators hinging on groups of unknown order have an important advantage over bilinear accumulators in that they can be transparent, have constant-sized public parameters and are dynamic. 

Consider the setting of a stateless sharded blockchain that, instead of a Merkle tree, hinges on a cryptographic accumulator instantiated with a hidden order group $\mb{G}$ ([BBF19]). Let $g$ be a randomly selected element of $\mb{G}$ and $S_1,\cdots, S_n$ the distinct shards. Let $\mc{D}_i$ denote the data in shard $S_i$ and $\mc{D}:= \bigcup\limits_{i=1}^n \mc{D}_i$. Then the accumulated digest (the analog of the Merkle root hash) of $S_i$ is given by \vs $$A_i:= g^{\Pi(\mc{D}_i)}.$$  The accumulated digest of the blockchain is given by \vs $$A:= g^{\Pi(\mc{D})}.$$

In order to demonstrate that the data sets in distinct shards are pairwise disjoint, a Prover (such as a miner or an untrusted server node) can provide a proof for the relation\\ $\mc{R}_{\ttt{AggRelPrimeDLog-1}}[a,\;(A_1,\cdots,A_n) ].$


\bigskip

Now consider the setting of a single shard. Let $\V_1,\cdots,\V_n$ be verifiers (such as light nodes) on the network. Let $\mc{E}_i$ denote the data set corresponding to $\V_i$. Suppose the verifiers need to verify that the data sets $\mc{E}_i$ are pairwise disjoint, but do not have access to the data sets outside their shards. A Prover $\mP$ (such as a miner or an untrusted server) can prove this pairwise disjointness as follows.\vspace{0.1cm}

\noin 1. $\V_i$ ($i=1,\cdots,n$) broadcasts the membership witness $w_i$ for $\mc{D}_i$ to the other $n-1$ nodes $\V_j$ ($j\neq i$). 

\noin 2. $\mP$ computes \vs $$d_i:= \pl_{d\in\mc{D}_i} d\;\;(i=1,\cdots,n)$$ and generates a non-interactive proof for the protocol \verb|PoAggRelPrimeDLog-3|$[(w_1,\cdots,w_n),\; A]$, which he then broadcasts to the Verifiers.



% \noin 2. Now suppose the Prover needs to convince a Verifier that 

\bigskip


\bigskip

\noin \textbf{Conclusion:} We hope that the techniques will find more applications than what we have discussed in this paper. To this end, we have tried to keep the setting general, in the hope of finding a wider variety of applications.  Several open questions remain, the foremost of which is whether the computational burden of the Prover can be alleviated. A closely related line of research is to further explore class groups and Jacobians as candidates for hidden order groups.

`



\bigskip

\noin \textbf{Acknowledgements:} The author thanks Benedikt B\"{u}nz and Dimitris Kolonelos for helpful feedback.

\bigskip



\begin{center}\textbf{References} \end{center}
\footnotesize

\noindent [BBF19] D. Boneh, B. B\"{u}nz, B. Fisch, \textit{Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains.} In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology  CRYPTO 2019, pages 561586, Cham, 2019. Springer International Publishing. \vspace{0.1cm}

\noin [BBBF18] D. Boneh, J. Bonneau, B. B\"{u}nz and B. Fisch, \textit{Verifiable delay functions}. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS \vspace{0.1cm}

\noin [BBF18] D. Boneh, B. B\"{u}nz, and B. Fisch, \textit{A survey of two verifiable delay functions}. Cryptology ePrint Archive, Report 2018/712, 2018. https://eprint.iacr.org/2018/712 \vspace{0.1cm}

\noindent [BFS19] B. B\"{u}nz, B. Fisch, A. Szepieniec, \textit{Transparent SNARKs from DARK Compilers}, Cryptology ePrint Archive, Report 2019/1229, 2019. https://eprint.iacr.org/2019/1229 \vspace{0.1cm}

\noin [BCM05] E. Bangerter, J. Camenisch, and U. Maurer. \textit{Efficient proofs of knowledge of discrete logarithms and representations in groups with hidden order}. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, Springer, Heidelberg, January 2005.\vspace{0.1cm}

\noin [BH01] J. Buchmann and S. Hamdy. \textit{A survey on IQ cryptography}, In Public-Key Cryptography and Computational Number Theory. \vspace{0.1cm}

\noin [CF13] D. Catalano and D. Fiore. \textit{Vector commitments and their applications}, In Kaoru Kurosawa and Goichiro Hanaoka, editors, PKC 2013, volume 7778 of LNCS, pages 55-72. Springer, Heidelberg, February/March 2013.

\noindent [CFGKN20] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, L. Nizzardo, \textit{Vector Commitment Techniques and Applications to Verifiable Decentralized Storage} \vspace{0.1cm}

\noin [CSV20] W. Castryck, J, Sotakova, F. Vercauteren, \textit{Breaking the decisional Diffie-Hellman problem for class group actions using genus theory}\vspace{0.1cm}

\noindent [Can87] D. Cantor. \textit{Computing in the Jacobian of a hyperelliptic curve. Mathematics of computation}, 48(177):95101, 1987.\vspace{0.1cm}

\noindent [Can94] D. Cantor. \textit{On the analogue of the division polynomials for hyperelliptic curves}, Crelle's Journal, 447:91146, 1994.\vspace{0.1cm}


\noindent [DGS20] S. Dobson, S. Galbraith, B. Smith, \textit{Trustless Groups of Unknown Order with Hyperelliptic Curves}, https://eprint.iacr.org/2020/196\vspace{0.1cm}

\noin [Fis18] B. Fisch. \textit{Tight Proofs of Space and Replication}. In Y. Ishai and V. Rijmen, editors, EUROCRYPT 2019, Part II, volume 11477 of LNCS, pages 324-348. Springer, Heidelberg, May 2019.

\noindent [FS87] A. Fiat, A. Shamir, \textit{How to prove yourself: Practical solutions to identification and signature problems.} In Andrew M. Odlyzko, editor, CRYPTO86, volume 263 of LNCS, pages 186194. Springer, Heidelberg, August 1987\vspace{0.1cm}

\noin [KPZ17] N. Katz, C. Papamanthou, Y. Zhang, \textit{An Expressive (Zero-Knowledge) Set Accumulator}, 2017 IEEE European Symposium on Security and Privacy


\noin [LLX07] J. Li, N. Li, and R. Xue,  \textit{Universal accumulators with efficient nonmembership proofs} In Jonathan Katz and Moti Yung, editors, ACNS 07, volume 4521 of LNCS, pages 253-269. Springer, Heidelberg, June 2007.

\noin [LM18] R. Lai and G. Malavolta,  \textit{Optimal succinct arguments
via hidden order groups}. Cryptology ePrint Archive, Report 2018/705,
2018.

\noin [Ngu05] L. Nguyen. \textit{Accumulators from bilinear maps and applications}. CT-
RSA, 2005. \vspace{0.1cm}

\noindent [Sut07] A. Sutherland, \textit{Order Computations in Generic Groups}, MIT Thesis, 2007 \vspace{0.1cm}

\noindent [STY01] T. Sander, A. Ta-Shma, M. Yung, \textit{Blind, auditable membership proofs}, In Yair Frankel, editor, FC 2000, volume 1962 of LNCS, pages 53{71. Springer, Heidelberg, February 2001.\vspace{0.1cm}

%\noindent [Th19] S. Thakur, \textit{Batching non-membership proofs with bilinear accumulators}, https://eprint.iacr.org/2019/1147\vspace{0.1cm}

\noindent [Th20] S. Thakur, \textit{Constructing hidden order groups using genus three Jacobians}, https://eprint.iacr.org/2020/348\vspace{0.1cm} 

\noin [Tod16] Peter Todd. \textit{Making UTXO Set Growth Irrelevant With Low-Latency Delayed TXO Commitments}.\\ https://petertodd.org/
2016/delayed-txo-commitments, May 2016.\vspace{0.1cm}

\noindent [Wes19] B. Wesolowski, \textit{Efficient verifiable delay functions}. In Yuval Ishai and Vincent Rijmen, editors, Advances in Cryptology  Eurocrypt 2019, pages 379407, Cham, 2019. Springer International Publishing.\vspace{0.1cm}




\bigskip

\normalsize
\noindent Steve Thakur\\
Axoni Research Group\\
New York City, NY\\
Email: stevethakur01@gmail.com


\newpage


\begin{center}\textbf{List of symbols/abbreviations:}\end{center}

\noindent $\mb{G}$: a group of hidden order in which we assume the adaptive root and strong-RSA assumptions to hold. \vspace{0.1cm}

\noindent $\lam$: The security parameter \vspace{0.1cm}

\noindent $\negl(\lam)$: The set of functions negligible in $\lam$. \vspace{0.1cm}

\noindent $[n]$: The set of integers $\{0,1,\cdots,n-1 \}$ \vspace{0.1cm}

\noin PPT: Probabilistic Polynomial Time \vspace{0.1cm}

\noindent $a\eqlam b$: The equivalence of $a,b\in\mb{G}$ with respect to the relation $\eqlam$ \vspace{0.1cm}

\noin $\mc{P}$: The Prover \vspace{0.1cm}

\noin $\mc{P}_{\mr{mal}}$: A malicious Prover \vspace{0.1cm}

\noin $\mc{V}$: The Verifier \vspace{0.1cm}

\noin $\impop$: Implies with overwhelming probability \vspace{0.1cm}

\noin $\sett(\mc{M})$: The underlying set of a multiset $\mc{M}$ \vspace{0.1cm}

\noin $\Pi(\mc{M})$: The product of all elements of a multiset $\mc{M}$ \vspace{0.1cm}

\noin $\mr{mult}(\mc{M},x)$: The multiplicity of an element $x$ in a multiset $\mc{M}$ \vspace{0.1cm}

\noin \verb|PoE|: Proof of Exponentiation ([Wes18], [BBF19])

\noin \verb|PoKE|: Proof of Knowledge of the Exponent ([BBF19])

\bigskip \begin{center} \textbf{List of Protocols:}




\end{center}

The following is a list of the protocols in this paper and the relations that the protocols are arguments of knowledge for, in the generic group model.\\

\noin 1. $\ttt{PoEqDLog}$ (Proof of equality of discrete logarithms) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{EqDLog}}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}): \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\]

\noin 2. $\ttt{PoAggEqDLog}$ (Proof of aggregated equality of discrete logarithms) \vspace{-0.3cm}

\[
  \mc{R}_{\ttt{AggEqDLog}}[(a, b),\;(\mc{A},\;\mc{B})] = \left\{\begin{array}{l}
  	((a, b)\in\mb{G}^2\\
    \mc{A} = (a_1, \cdots, a_n),\;\mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\
    d\in\mb{Z}): \\
    b_i = a_1^{d} \;\forall\;i
  \end{array}\right\}
\]
 

\noin 3. $\ttt{PoPolyDLog}$ (Proof of polynomial relation between discrete logarithms)\vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{PolyDLog}}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]);\\
    (d_1, d_2)\in\mb{Z}^2: \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_1 = a_1^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\]

\noin 4. $\ttt{PoAggKE-1}$ (Proof of aggregated knowledge of exponents-1) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{AggKE-1}}}[a,\; \mc{A}] = \left\{\begin{array}{l}
    (a\in\mb{G},\; \mc{B} = (a_1,\cdots, a_n)\in\mb{G}^n);\\ 
    (d_1,\cdots,d_n)\in\bz^n):  \\
    a_i = a^{d_i}\;\forall\; i
  \end{array}\right\}
\]

\noin 5. $\ttt{PoAggKE-2}$ (Proof of aggregated knowledge of exponents-2) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{AggKE-2}}}[\mc{A},\;A] = \left\{\begin{array}{l}
    (\mc{A} = (a_1,\cdots, a_n)\in \mb{G}^n,\; A\in\mb{G})\;\\ 
    (d_1,\cdots,d_n)\in\bz^n) :  \\
     A = a_i^{d_i}\;\forall\;  i
  \end{array}\right\}
\]

\noin 6. $\ttt{PoMultPolyDLog}$ (Proof of multivariate polynomial relations between discrete logs)\vspace{-0.3cm}

\[
  \mc{R}_{\ttt{MultPolyDLog}}[a,\; (b_1,\cdots, b_n),\; (f_1,\cdots,f_k)] = \left\{\begin{array}{l}
    (a\in\mb{G},\; (b_1,\cdots, b_n)\in\mb{G}^n);\\
    (f_1,\cdots,f_k)\in\bz[X_1,\cdots,X_n]^k;\\ 
    (d_1,\cdots,d_n)\in\bz^n)\;: \\
    b_i = a^{d_i}\;\forall\; i\;\bigwedge \;\\   f_j(d_1,\cdots,d_n) = 0\;\forall\; j 
  \end{array}\right\}
\]

\noin 7. $\ttt{PoEqDLogPairs}$ (Proof of equality of discrete log pairs) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{EqDLogPairs}}}[(a_1, \mc{B}),\; (a_2, \mc{C})] = \left\{\begin{array}{l}
  	(a_1,a_2\in\mb{G};\\
    (b_1,\cdots, b_n),\;(c_1,\cdots, c_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in \bz^n)\;: \\
    b_i = a_1^{d_i}\;,\;c_i= a_2^{d_i} \;\forall\; i
  \end{array}\right\}
\]

\noin 8. $\ttt{PoGCD}$ (Proof of GCD) \vspace{-0.5cm} 

\[\mc{R}_{{\ttt{GCD}}}[(a_1,b_1),\; (a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} .\]


\noin 9. $\ttt{PoRelPrimeDLog}$ (Proof of relatively prime discrete logs; special case of \verb|PoGCD|) \vspace{-0.7cm}

\[
\mc{R}_{\ttt{RelPrimeDLog}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} .
\]

\noin 10. $\ttt{PoAggRelPrimeDLog-1}$ (Aggregated proof of relatively prime discrete logarithms-1) \vspace{-0.2cm}

\[
  \mc{R}_{\ttt{AggRelPrimeDLog-1}}[a, \mc{A}] = \left\{\begin{array}{l}
    \big(a\in\mb{G},\;  \mc{A}:=(a_1,\cdots, a_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\bz^n\big): \\
    a_i = a^{d_i}\;\forall\;i\;\;,\;\; \GCD(d_i, d_j) = 1)\;\forall \;i\neq j   	
  \end{array}\right\}
\] 

\noin 11. $\ttt{PoAggRelPrimeDLog-2}$ (Aggregated proof of relatively prime discrete logarithms-2) \vspace{-0.6cm}

\[
  \mc{R}_{{\ttt{AggRelPrimeDLog-2}}}[a_1, a_2, \mc{B}, \mc{C}] = \left\{\begin{array}{l}
    \big((a_1,a_2)\in\mb{G}^2,\;\\
     \mc{B}:=(b_1,\cdots, b_m)\in\mb{G}^m,\;\mc{C}:= (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n\big)\;: \\
    (b_i = a_1^{d_i}\;\;\bigwedge\;\; c_j = a_2^{e_j}\;\bigwedge\; \GCD(d_i, e_j) = 1)\;\forall \;i,j   	
  \end{array}\right\}
\] 

\noin 12.${\ttt{PoAggRelPrimeDLog-3}}$ (Aggregated proof of relatively prime discrete logarithms-3) \vspace{-0.3cm}

\[
  \mc{R}_{{\ttt{AggRelPrimeDLog-3}}}[(w_1,\cdots, w_n), A] = \left\{\begin{array}{l}
    \big(A\in\mb{G},\; (w_1,\cdots, w_n)\;\in\mb{G}^n);\\
    ((d_1,\cdots,d_n)\in\bz^n\big)\;: \\
    w_i^{d_i} = A\;\forall\;i\;\bigwedge  \\
   	\GCD(d_i, d_j) = 1\;\forall \;i,j: i\neq j
  \end{array}\right\}
\] 

\noin 13. ${\ttt{PoAggRelPrimeDLog-4}}$ (Aggregated proof of relatively prime discrete logarithms-4) \vspace{-0.5cm}

\[
  \mc{R}_{{\ttt{AggRelPrimeDLog-4}}}[\mc{B}, \mc{C}, B, C] = \left\{\begin{array}{l}
    \big((B,C)\in\mb{G}^2,\;\\
     \mc{B} = (b_1,\cdots,b_m)\in\mb{G}^m,\;\mc{C} = (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n\big)\;: \\
    (B = b_i^{d_i},\; C = c_j^{e_j}\;\bigwedge \; \GCD(d_i, e_j) = 1)\;\forall \;i,j
  \end{array}\right\}
\]   

\noin 14. Protocol for the intersection of multisets \vspace{-0.3cm}

\[
  \mc{R}_{\tt{\cap}}[a,\; (A_1,\cdots,A_n),\; A_{\tt{\cap}}] = \left\{\begin{array}{l}
    (a\in\mb{G};\;\\
     (A_1,\cdots,A_n)\in\mb{G}^{n}\;,\; A_{\tt{\cap}}\in\bG;\\
    ((d_1,\cdots,d_n, d_{\tt{\cap}})\in\bz^{n+1}): \\
    A_i = g^{d_i}\;\forall\;i\;,\; A_{\tt{\cap}} = g^{d_{\tt{\cap}}}   \\
    
  \GCD(d_1, \cdots, d_n) = d_{\tt{\cap}}
  \end{array}\right\}
\] 

\noin 15. Protocol for the union of multisets \vspace{-0.3 cm}

\[
  \mc{R}_{\tt{\cup}}[a,\; (A_1,\cdots,A_n),\; A_{\tt{\cup}}] = \left\{\begin{array}{l}
    (a\in\mb{G};\;\\
     (A_1,\cdots,A_n)\in \mb{G}^{n})\;,\;,A_{\tt{\cup}})\in\mb{G};\\
    ((d_1,\cdots,d_n, d_{\tt{\cup}})\in\bz^{n+1}): \\
    A_i = g^{d_i}\;\forall\;i\;,\; A_{\tt{\cup}} = g^{d_{\tt{\cup}}}   \\
    
  \LCM(d_1, \cdots, d_n) = d_{\tt{\cup}}
  \end{array}\right\}
\] 

\noin 16. Protocol for equality/inequality of underlying sets \vspace{0.1cm}

\noin Given elements $a_1,a_2\in\bG$ and multisets $\mcM_1, \mcM_2$ with commitments $\ttt{Com}(a_i, \mcM_i) = a_i^{\Pi(\mcM_i)}$, the Prover can demonstrate the equality/inequality of the underlying sets $\sett(\mcM_1)$, $\sett(\mcM_2)$.\vspace{0.25cm}

\noin 17. Protocol for the highest/lowest frequency of elements in multisets \vspace{0.1cm}

\noin If the Verifier has access to the commitments $\ttt{Com}(g, \mcM_i)= g^{\Pi(\mcM_i)}$ to multisets $\mcM_1,\cdots,\mcM_n$ and a data set $\mc{D}$, the Prover can show that every element of $\mc{D}$ occurs with a higher/lower frequency in $\mcM_1$ than in any $\mcM_i$ for $i\geq 2$.

\noin Similarly, given a single accumulated digest $A$ and witnesses $w_i$ for multisets $\mcM_i$ such that $w_i^{\Pi(\mcM_i)} = A $, the Prover can show that every element of $\mc{D}$ occurs with a higher/lower frequency in $\mcM_1$ than in any $\mcM_i$ for $i\geq 2$.\vspace{0.25cm}

\noin 18. Protocol for the containment/non-containment of the underlying sets \vspace{0.1cm}

\noin If the Verifier has access to the commitments $\ttt{Com}(g, \mcM_i)= g^{\Pi(\mcM_i)}$ for multisets $\mcM_1, \mcM_2$, the Prover can verifiably show whether $\sett(\mcM_1)\sub \sett(\mcM_2)$ or $\sett(\mcM_1)\not\sub \sett(\mcM_2)$.






\vspace{0.2cm}






\bigskip

\newpage




\begin{comment}


\vspace{0.1cm}

\begin{Prot} Protocol for intersection of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cap}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1} \normalfont \noin 1. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gammma$.

\noin 2. The Prover computes \vs $$g_1:= g^{\slim{i=1}^n} d_i\gamma^i\;,\;g_2:= g^{\slim{i=1}^n} e_i\gamma^i$$ and sends them to the Verifier $\V$.

\noin 3. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 4. $\mP$ computes the integers \vs $$r_i:= d_i\Mod{l}\;,\; s_i:= e_i\Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i\Mod{l}\;,\;s:= \slim_{i=1}^n s_i\gamma^i\Mod{l}.$$

\noin 5. $\mP$ computes elements $Q_1, Q_2\;\in\;\bG$ such that \vs $$Q_1^{l}g^{r} = g_1\;,\; Q_2^{l}g^{s} = g_2.$$ He sends \vs $$Q_1, Q_2,\; (r_1,\cdots,r_n),\;(s_1,\cdots,s_n)$$ to $\V$.

\noin 6. $\mP$ computes \vs $$t:= \slim_{i=1}^n d_ie_i\Mod{l}$$ and an element $Q_3\in \bG$ such that $Q_3^lg^{t} = A_{\tt{\cap}}.$

\noin 7. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\what{\gamma}$.

\noin 8. $\mP$ computes the integers \vs $$\what{r}:= \slim_{i=1}^n r_i\what{\gamma}^i\Mod{l}\;,\;\what{s}:= \slim_{i=1}^n s_i\what{\gamma}^i\Mod{l}$$ and elements $\what{Q}_1,\;\what{Q}_2\;\in\;\bG$ such that \vs $$\what{Q}_1^l g^{\what{r}} = \pl_{i=1}^n A_i^{\what{\gamma}^i}\;,\; \what{Q}_2^l g^{\what{s}} = \pl_{i=1}^n A_i^{\what{\gamma}^i}$$

\noin 9. 


\end{comment}
 



\begin{comment}





\begin{Prot} Protocol for the intersection of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cap}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1} \normalfont \noin 1. The Prover $\mP$ computes the integers \vs $$d_i:= \Pi(\mc{M}_i)\; (i=1,\cdots,n)$$ and integers $e_1,\cdots,e_n$ such that \vs $$\sum\limits_{i=1}^n d_ie_i = \GCD(d_1,\cdots,d_n).$$

\noin 2. $\mP$ generates a non-interactive proof for $\pr{\ttt{AggKE-1}}[A_{\tt{\cap}},\;(A_1,\cdots,A_n)]$ and sends it to the Verifier $\V$.

\noin 3. $\mP$ computes the elements $\weck{A}_i=g^{e_i}\;(i=1,\cdots,n)$ and sends them to $\V$ along with a  non-interactive proof for $\pr{\ttt{AggKE-1}[g,\;(\weck{A}_1.\cdots,\weck{A}_n)]} .$ 

\noin 4. $\mP$ generates a non-interactive proof for $\protect{\tt{MultPolyDLog} }[g,\;(A_1,\cdots,A_n, \weck{A}_1,\cdots,\weck{A}_n, A_{\tt{\cap}}),\;f]$ where \vs $$f(X_1,\cdots,X_{2n+1}):= (\slim_{i=1}^n X_iX_{n+i})-X_{2n+1} $$ and sends it to $\V$.

\noin 5. $\V$ verifies the two proofs and accepts if and only if they are both valid.\end{prf1}

The proof consists of $n+\bO(1)$ $\mb{G}$-elements and $2n$ $\lam$-bit integers. If the client also needs the intersection $\bigcap\limits_{i=1}^n \mc{M}_i$ rather than just the commitment to this multiset, the server node can send along a non-interactive \verb|PoE| for the exponentiation \vs $$A_{\tt{\cap}} = g^{\Pi(\bigcap\limits_{i=1}^n \mc{M}_i)}.$$ Note that the proof size can be smaller in certain special cases. In particular, when the multisets $\mc{M}_i$ are pairwise disjoint, the prover can use the protocol $\pr{\ttt{PoAggRelPrimeDLog-1}}$, which entails a constant number of $\bG$-elements and $2n$ $\lam$-bit integers.

In a setting where the elements of every $\mcM_i$ are all $\lam$-bit primes, the proof can be modified so that the number of group elements is constant. The basic idea is that for a randomly generated $\lam$-bit integer $\gamma$, we have \vs $$\mbf{Prob}\big( \GCD(\slim_{i=1}^n d_i\gamma^i,\pl_{i=1}^n d_i)>1 \big)  = \negl(\lam).$$ This allows for the following protocol. \vspace{0.1cm}

\begin{Prot} Protocol for the intersection of multisets of $\lam$-bit primes.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cap}}\in\mb{G}$.

\noin \textbf{Assumption:} All elements of $\mcM_i$ are primes $> 2^{\lam}$.

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1}\normalfont \noin 1. The Prover $\mP$ computes the integers \vs $$d_i:= \Pi(\mc{M}_i)\; (i=1,\cdots,n).$$

\noin 2. $\mP$ samples $\lam$-bit integers $\gamma$ until he finds one such that \vs $$\GCD(\slim_{i=1}^n d_i\gamma^i,\pl_{i=1}^n d_i) = 1 .$$ He sends $\gamma$ to the Verifier $\V$.

\noin 3. $\mP$ generates a non-interactive proof for $\ttt{AggKE-1}[A_{\tt{\cap}},\;(A_1,\cdots,A_n)]$ and sends it to $\V$.

\noin 4. $\mP$ computes $\wti{A}:= g^{\pl_{i=1}^n d_i}$ and sends $\wti{A}$ to $\V$ along with a non-interactive proof for\\ $\ttt{MultPolyDLog}[g,\; (A_1,\cdots,A_n, \wti{A}),\; f]$ where \vs $$f(X_1,\cdots,X_{n+1}):= (\pl_{i=1}^n X_i)-X_{n+1} .$$

\noin 5. $\mP$ generates a non-interactive proof for $\ttt{PoGCD}[(g, \wti{A}),\;(g, \pl_{i=1}^n A_i^{\gamma^i}),\;(g, A_{\tt{\cap}})]$ and sends it to $\V$.

\noin 6. $\V$ verifies the three proofs and accepts if and only if they are all valid.\end{prf1}

\noin The proof consists of a constant number of $\bG$-elements and $\bO(n)$ $\lam$-bit integers.


\bigskip



\begin{Prot} Protocol for the union of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cup}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cup}} = \protect{\verb|Com|}(g, {\bigcup\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcup\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1} \normalfont \noin 1. The Prover $\mP$ computes the integers \vs $$d_j:= \Pi(\mc{M}_j)\;,\;\what{d}_j := \pl_{\substack{1\leq i\leq n \\ i\neq j}} d_i \; (i=1,\cdots,n)$$ and integers $\what{e}_1,\cdots,\what{e}_n$ such that \vs $$\sum\limits_{i=1}^n \what{d}_i\what{e}_i = \GCD(\what{d}_1,\cdots,\what{d}_n).$$

\noin 2. $\mP$ generates a non-interactive proof for $\pr{\ttt{AggKE-2}}[(A_1,\cdots,A_n),\;A_{\uni}] $ and sends it to $\V$.

\noin 3. $\mP$ computes \vs $$\wti{A}:= g^{\pl_{i=1}^n d_i} = \ttt{Com}(g, \slim_{i=1}^n \mcM_i)$$ and sends $\wti{A}$ to the Verifier $\V$ along with a non-interactive proof for the relation \\ $\ttt{MultPolyDLog}[g,\;(A_1,\cdots,A_n,\wti{A}),\;f]$ where \vs $$f(X_1,\cdots,X_{n+1}):= (\pl_{i=1}^n X_i)-X_{n+1}. $$

\noin 4. $\mP$ computes $\weck{A}_i:= g^{\what{e}_i}\;(i=1,\cdots,n) $ and sends $\weck{A}_1,\cdots,\weck{A}_n$ to $\V$ along with a non-interactive proof for $\pr{\ttt{MultPolyDLog}}[g,\;(A_1,\cdots,A_n, \weck{A}_1,\cdots,\weck{A}_n, A_{\uni}, \wti{A}),\;\weck{f}]$ where \vs $$\weck{f}(X_1,\cdots,X_{2n+1}):= \Big(X_{2n+1}\cdot\big(\slim_{j=1}^n (X_{n+j}\pl_{\substack{1\leq i\leq n \\ i\neq j}} X_i)\big)\Big) - X_{2n+2} $$ 

\noin 5. $\V$ verifies the two proofs and accepts if and only if they are both valid.\end{prf1}

\noin The proof consists of $n+\bO(1)$ $\bG$-elements and $3n$ $\lam$-bit integers.





\begin{Prot} Protocol for the intersection of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mcM_i) := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cap}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cap}} = \protect{\verb|Com|}(g, {\bigcap\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1} \normalfont \noin 1. The Prover $\mP$ computes the integers \vs $$d_i:= \frac{\Pi(\mc{M}_i)}{\Pi({\bigcap\limits_{i=1}^n} \mc{M}_i)}\; (i=1,\cdots,n).$$

\noin 2. $\mP$ generates non-interactive proofs for $\pr{\ttt{AggKE-1}}[A_{\tt{\cap}},\;(A_1,\cdots,A_n)]$, $\ttt{PoKE}[g,\;A_{\tt{\cap}}]$ and sends them to the Verifier $\V$.

\noin 3. $\mP$ samples a $\lam$-bit prime $\gamma$ and computes \vs $$ e:= \GCD(\slim_{i=1}^n d_i, \slim_{i=1}^n d_i\gamma^i).$$

\noin 4. $\mP$ computes \vs $$\wti{e}:= \GCD(e^{n\lam}, \slim_{i=1}^n d_i^{n\lam}\gamma^i) .$$ If $\wti{e}$ does not divide $e^{n\lam-1}$, $\mP$ returns to Step 3 and samples another $\gamma$. Otherwise, $\mP$ sends $\gamma$ to $\V$ and proceeds to Step 5.  

%\noin 5. $\mP$ computes $A:= A_{\tt{\cap}}^{\pl_{i=1}^n d_i}$ and sends $\wti{A}$ to $\V$ along with a non-interactive proof for\\ $\ttt{MultPolyDLog}[A_{\tt{\cap}},\;(A_1,\cdots,A_n, A), f]$ where $$f(X_1,\cdots,X_n):= (\pl_{i=1}^n X_i)-X_{n+1}.$$

\noin 5. $\mP$ computes $B_0:= A_{\tt{\cap}}^{e}$ and sends $B_0$ to $\V$ along with a non-interactive proof for \\ $\ttt{PoGCD}[(A_{\tt{\cap}}, \pl_{i=1}^n A_i^{\gamma^i}),\;(A_{\tt{\cap}},\pl_{i=1}^n A_i),\;(A_{\tt{\cap}},B_0)]$.

\noin 6. $\mP$ computes $\wti{A}:= A_{\tt{\cap}}^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends $\wti{A}$ to $\V$ along with a non-interactive proof for \\ $\ttt{MultPolyDLog}[A_{\tt{\cap}},\;(A_1,\cdots,A_n, \wti{A}),\;\wti{f}]$ where \vs $$\wti{f}:= (X_1,\cdots,X_{n+1}):= \big(\slim_{i=1}^n \gamma^i X_i^{n\lam}\big) - X_{n+1}.$$

\noin 7. $\mP$ computes $B_1:= A_{\tt{\cap}}^{e^{n\lam}},\; B_2:= A_{\tt{\cap}}^{e^{n\lam-1}}$ and sends $A_{\tt{\cap}}^{e^{n\lam}}, A_{\tt{\cap}}^{e^{n\lam-1}}$ to $\V$ along with a non-interactive proof for \vs $$\ttt{MultPolyDLog}[A_{\tt{\cap}},\;(A_0, B_1,B_2),\;(X_1^{n\lam}- X_2, X_1^{n\lam-1}- X_3)] .$$
 
\noin 8. $\mP$ computes $\wti{B}_0 := A_{\tt{\cap}}^{\wti{e}}$ and sends $\wti{B}_0$ to $\V$ along with a non-interactive proof for \\ $\ttt{PoGCD}[(A_{\tt{\cap}}, \wti{A}),\;(A_{\tt{\cap}},B_1),\;(A_{\tt{\cap}},\wti{B}_0)]$.

\noin 9. $\mP$ generates a non-interactive proof for $\ttt{PoKE}[\wti{B}_0,\; B_2] .$

\noin 10. $\V$ verifies all the proofs he receives and accepts if and only if they are all valid.\end{prf1}


\noin Thus, the proof consists of a constant number of $\bG$-elements and $\bO(n)$ $\lam$-bit integers. In certain special cases, the proof can be substantially simpler. In particular, when the elements of every $\mcM_i$ are all primes larger than $2^{\lam}$, it is easier for the Prover to find an integer $\gamma$ such that \vs $$\GCD(\slim_{i=1}^n d_i\gamma^i, \pl_{i=1}^n d_i) = \GCD(d_1,\cdots,d_n).$$


\begin{Prot} Protocol for the union of multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i = \ttt{Com}(g, \mc{M}_i) := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; an element $A_{\tt{\cup}}\in\mb{G}$

\noin \textbf{Claim:} $A_{\tt{\cup}} = \protect{\verb|Com|}(g, {\bigcup\limits_{i=1}^n} \mc{M}_i) := g^{\Pi({\bigcup\limits_{i=1}^n} \mc{M}_i)}$.

\begin{prf1} \normalfont \noin 1. $\mP$ generates a non-interactive proof for $\ttt{AggKE-2}[(A_1,\cdots,A_n),\;A_{\tt{\cup}}]$ and sends it to the Verifier $\V$.

\noin 2. The Prover $\mP$ computes the integers \vspace{-0.25cm} $$\weck{d}_i:= \frac{\Pi(\bigcup\limits_{i=1}^n \mc{M}_i)}{\Pi(\mcM_i)}\;\;(i=1,\cdots,n).$$


\noin 3. $\mP$ samples a $\lam$-bit prime $\gamma$ and computes \vs $$e:= \GCD(\weck{d}_1, \slim_{i=1}^n \weck{d}_i\gamma^i) .$$

\noin 4. $\mP$ computes $$\wti{e}:= \GCD(e^{n\lam}, \slim_{i=1}^n \weck{d}_i^{n\lam}\gamma^i) .$$ If $\wti{e}$ does not divide $e^{n\lam-1}$, $\mP$ returns to Step 3 and samples another $\gamma$. Otherwise, $\mP$ proceeds to Step 5.

\noin 5. $\mP$ computes $g_0:= g^{e}$ and sends $g_0$ to $\V$ along with a non-interactive proof for\\ $\ttt{PoGCD}[(g, \weck{A}),\;(g, A_{\tt{\cup}}),\;(g, g_0)].$

\noin 6. $\mP$ computes $\weck{A}:= g^{\slim_{i=1}^n \weck{d}_i\gamma^i}$ and sends it to $\V$ along with a non-interactive proof for\\ $\ttt{MultPolyDLog}[g, \;(A_1,\cdots,A_n, A_{\tt{\cup}}, \weck{A}),\; (\weck{f},\wti{f})]$ where \vs $$\weck{f}(X_1,\cdots,X_{n+2}):= X_{n+1}\cdot \Big( \slim_{i=1}^n \frac{\gamma^i}{X_i} \Big)- X_{n+2}\;,\;\wti{f}(X_1,\cdots,X_{n+3}):= X_{n+1}^{n\lam}\cdot\Big(  \slim_{i=1}^n \frac{\gamma^i}{X_i^{n\lam}} \Big)- X_{n+3}.$$

%\noin 7. $\mP$ computes $\wti{A}:= g^{\slim_{i=1}^n \weck{d}_i^{n\lam}\gamma^i}$ and sends $\wti{A}$ to $\V$ along with a non-interactive proof for\\ $\ttt{MultPolyDLog}[g, \;(A_1,\cdots,A_n, A_{\tt{\cup}}, \wti{A}), \wti{f}]$ where \vs $$\wti{f}(X_1,\cdots,X_{n+2}):= X_{n+1}^{n\lam}\cdot\Big(  \slim_{i=1}^n \frac{\gamma^i}{X_i^{n\lam}} \Big)- X_{n+2}. $$

\noin 7. $\mP$ computes $g_1:= g^{e^{n\lam}}, g_2:= g^{e^{n\lam-1}}$ and sends $g_1,g_2$ to $\V$ along with a non-interactive proof for \vs $$\ttt{MultPolyDLog}[g,\; (g_0, g_1,g_2),\; (X_1^{n\lam}-X_2, X_1^{n\lam-1}-X_3)] .$$

\noin 8. $\mP$ computes $\wti{g}_0 := g^{\wti{e}}$ and sends $\wti{g}_0$ to $\V$ along with a non-interactive proof for \vs $$\ttt{PoGCD}[(g, \wti{A}),\;(g,g_1),\;(g,\wti{g}_0)].$$

\noin 9. $\mP$ generates a non-interactive proof for $\ttt{PoKE}[\wti{g}_0,\; g_2] .$ and sends it to $\V$.

\noin 10. $\V$ verifies all the proofs he receives and accepts if and only if they are all valid. \end{prf1}

\noin The proof consists of a constant number of $\bG$-elements and $\bO(n)$ $\lam$-bit integers. As was the case with the protocol for multiset intersections, the proof is simpler in special cases such as when the elements of every $\mcM_i$ are all primes $> 2^{\lam-1}$.


\end{comment}

\newpage

\appendix

\section{\fontsize{12}{12}\selectfont More protocols}

In what follows, we provide an argument of knowledge for the relation \vs

\[
  \mc{R}_{{\ttt{EqDLogPairs}}}[(a_1, \mc{B}),\; (a_2, \mc{C})] = \left\{\begin{array}{l}
  	((a_1, a_2)\in\mb{G}^2\\
    \mc{B} = (b_1,\cdots, b_n)\;,\;\mc{C} = (c_1,\cdots, c_n)\;\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\mb{Z}^n): \\
    b_i = a_1^{d_i}\;,\;c_i = a_2^{d_i} \;\forall\;i
  \end{array}\right\}
\]

\vspace{0.2cm}


\begin{Prot} \normalfont \textit{Proof of equalities of pairs of discrete logarithm} (\verb|PoEqDLogPairs|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs :} $a_1,a_2\in\mb{G}$  \;,\;$(b_1,\cdots, b_n), \;\;(c_1,\cdots, c_n)\;\in\; \mb{G}^n$.

%\noindent \textbf{Inputs:} $\mc{P}$ possesses

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that $a_1^{d_i} = b_i,\; a_2^{d_i} = c_i$.

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma$.

\noin 2. The Prover $\mP$ computes $\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends it to the Verifier $\V$.
 
\noin 3. $\mc{P}$ computes the elements \vs $$B:= \prod\limits_{i=1}^n b_i^{\gamma^i},\;\;C:= \prod\limits_{i=1}^n c_i^{\gamma^i}\;\in\; \mb{G}.$$

\noin 4. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 5. $\mP$ computes $r_i:= d_i\Mod{l}$ and the integers $q,\wti{q}, r,\wti{r}$ such that \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\slim_{i=1}^n d_i\gamma^i = ql+r,\;\;\;r,\wti{r}\in[l]$$

\noin 6. $\mP$ computes $\weck{g}:= g^{\wti{q}}$, $Q:= a_1^q$ and sends $\weck{g}$, $Q$, $(r_1,\cdots,r_n)$ to $\V$.   
 
\noindent 7. $\mc{P}$ computes a non-interactive proof for \verb|EqDLog|$[(a_1, B),\; (a_2, C)]$ and sends it to $\mc{V}$.

\noin 8. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 9. $\mP$ computes integers $q_0,r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0,\;\;\;r_0\in[l] .$$ He computes $Q_0:= a_1^{q_0}$ and sends $Q_0$ to $\V$.

\noindent 10. $\V$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i \Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i \Mod{l}\;,\;r_0:= \slim_{i=1}^n r_i\gamma_0^i \Mod{l} .$$

\noin 11. $\V$ independently computes the elements \vs $$B:= \prod\limits_{i=1}^n b_i^{\gamma^i},\;\;B_0:= \prod\limits_{i=1}^n b_i^{\gamma_0^i},\;\;   C:= \prod\limits_{i=1}^n c_i^{\gamma^i}\;\in\; \mb{G}.$$

\noin 12. $\V$ verifies the equations \vs $$Q^la_1^{r}\sta B\;\bigwedge\;(Q_0)^la_1^{r_0}\sta B_0\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta \wti{g} .$$ He then accepts the validity of the claim if and only if the proof for \verb|EqDLog|$[(a_1, B),\; (a_2, C)]$ is valid and all equations hold.\qed\end{enumerate}


\noindent We now show how to generalize the last protocol for multiple discrete logarithms while keeping the communication complexity constant-sized and independent of the number of discrete logarithms. We call the following protocol the \textit{Aggregated Equality of Discrete Logarithms} or \verb|AggEqDLog| for short. We provide an argument of knowledge for  the following relation:

\[
  \mc{R}_{{\ttt{AggEqDLog}}}[(a, b),\;(\mc{A},\;\mc{B})] = \left\{\begin{array}{l}
  	%(a, b)\in\mb{G}^2\\
    (\mc{A} = (a_1, \cdots, a_n),\;\mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\
    d\in\mb{Z}): \\
    b_i = a_1^{d} \;\forall\;i
  \end{array}\right\}
\]

\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Equal Discrete Logarithms} (\verb|PoAggEqDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs :} $a,b\in\mb{G}$, $(a_1, \cdots, a_n)\in\mb{G}^n$, $(b_1, \cdots, b_n)\in\mb{G}^n$.

%\noindent \textbf{Inputs:} 

\noindent \textbf{Claim:} The Prover possesses an integer $d$ such that $a^d = b$ and $a_i^d = b_i$ for $i = 1,\cdots, n$ .

\begin{enumerate}[wide, labelwidth=!, labelindent=0pt]\vs \item The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noindent 2. The Prover $\mc{P}$ computes the elements \vspace{-0.15cm}$$\wti{a}:= \prod\limits_{i=1}^n a_i^{\gamma^i}, \;\;\wti{b}:= \prod\limits_{i=1}^n b_i^{\gamma^i}\;\; \in \mb{G}.$$

\noindent 3. $\mc{P}$ generates a non-interactive proof for \verb|EqDLog|$[(a, b),\; (\wti{a}, \wti{b})]$ and sends it to the Verifier $\mc{V}$.

\noindent 4. $\mc{V}$ independently computes the elements $\wti{a}, \wti{b}$ and accepts if and only if the proof for\\ \verb|EqDLog|$[(a, b),\; (\wti{a}, \wti{b})]$ is valid.\qed \end{enumerate}
\vspace{0.1cm}

\noin Thus, the proof consists of four $\mb{G}$-elements and one  $\lam$-bit integer. In particular, it is constant-sized and independent of the cardinalities $|\mc{A}|$, $|\mc{B}|$.


\vspace{0.1cm}

\begin{Prop} The protocol \verb|AggEqDLog| is an argument of knowledge for the relation $\mc{R}_{{\tt{AggEqDLog}}}$in the generic group
model.\end{Prop}

\begin{prf} (Sketch) With notations as in in the Protocol, $\mc{V}$ accepts if and only if $\mc{P}$ proves possession of an integer $d$ such that $$a^d = b,\;\;\wti{a}^d = \wti{b}$$ through the Protocol \verb|PoEqDLog|$[(a,b),\; (\wti{a},\wti{b})]$. Now, since the challenge $\gamma$ is randomly generated, it follows that \vspace{-0.15cm}$$ \mbf{Prob}\left( (a_1^d,\cdots, a_n^d) \neq (b_1,\cdots, b_n)\;   \Big|\; \wti{a}^d = \wti{b} \right) \in \negl(\lamb). $$ Since the Protocol \verb|EqDLog|$[(a,b),\; (\wti{a},\wti{b})]$ is secure under the strong-RSA and adaptive root\\ assumptions, it follows that the Protocol \verb|AggEqDLog|$[(a_1, b_1),\; (a_2, b_2)]$ is also secure under these assumptions.\end{prf}



\bigskip



\end{document}

















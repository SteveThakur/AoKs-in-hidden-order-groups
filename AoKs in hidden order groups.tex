\documentclass[11pt, lettersize, notitlepage, leqno, footskip=0.6cm]{article}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}	
%\usepackage{graphicx}
\usepackage{amscd}
%\usepackage{mathabx}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

%\usepackage[T1]{fontenc}% http://ctan.org/pkg/fontenc
%\usepackage[outline]{contour}% http://ctan.org/pkg/contour
%\usepackage{xcolor}% http://ctan.org/pkg/xcolor

\usepackage{authblk}

\usepackage{fancyvrb}

% This the preamble, load any packages you're going to use here
%\usepackage{physics} % provides lots of nice features and commands often used in physics, it also loads some other packages (like AMSmath)
%\usepackage{siunitx} % typesets numbers with units very nicely
\usepackage{enumerate} % allows us to customize our lists
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tikz}
%\usetikzlibrary{decorations.pathreplacing}
%\usepackage[colorinlistoftodos]{todonotes}
%\usepackage{pgfplots} 
%\pgfplotsset{width=10cm,compat=1.9} 
\usepackage{verbatim}

\usepackage{thmtools}
\usepackage[none]{hyphenat}

\usepackage{indentfirst}

\usepackage{braket}

\usepackage[shortlabels]{enumitem}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}
\DeclareMathAccent{\wideparen}{0}{mathx}{"75}

\def\cs#1{\texttt{\char`\\#1}}



\addtolength{\textwidth}{100pt}
\addtolength{\evensidemargin}{-50pt}
\addtolength{\oddsidemargin}{-50pt}
\addtolength{\topmargin}{-60pt}
\addtolength{\textheight}{1.6in}
%\setlength{\parindent}{0in}
\setlength{\parskip}{2pt}


\setlength{\abovedisplayskip}{0cm}
\setlength{\belowdisplayskip}{0cm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Begin user defined commands


\newcommand{\bc}{\mathbb C}
\newcommand{\bF}{\mathbb F}
\newcommand{\bH}{\mathbb H}
\newcommand{\bn}{\mathbb N}
\newcommand{\bz}{\mathbb Z}
\newcommand{\bp}{\mathbb{P}}
\newcommand{\bq}{\mathbb Q}
\newcommand{\br}{\mathbb R}
\newcommand{\bS}{\mathbb S}

\newcommand{\bFp}{\mathbb{F}_p}
\newcommand{\bFP}{\ov{\mathbb{F}}_p}
\newcommand{\bFl}{\mathbb{F}_l}
\newcommand{\bFq}{\mathbb{F}_q}
\newcommand{\bFQ}{\ov{\mathbb{F}}_q}
\newcommand{\bFpk}{\mathbb{F}_{p^k}}


\newcommand{\pl}{\prod\limits}
\newcommand{\slim}{\sum\limits}

\newcommand{\bT}{\mathbf T}
\newcommand{\bTl}{\mathbf T_{{\bq_l}}}
\newcommand{\bTlbar}{\mathbf T_{{\qbar_l}}}

\newcommand{\G}{\mathcal G}

\newcommand{\Gal}{\mathrm{Gal}}
\newcommand{\scl}{\mathcal L}

\newcommand{\W}{\mathcal W}
\newcommand{\WA}{\mathcal{W}_{A_v}}

\newcommand{\zbar}{\overline {\mathbb{Z}}}
\newcommand{\qbar}{\overline {\mathbb{Q}}}

\newcommand{\Fbar}{\overline {F}}
\newcommand{\Kbar}{\overline {K}}

\newcommand{\bark}{\overline {k}}

\newcommand{\bg}{\mathbb{G}}
\newcommand{\ev}{\mathbf{ev}}
\newcommand{\crys}{\mathrm{crys}}

\newcommand{\st}{\mathrm{st}}

\newcommand{\lcm}{\mathrm{lcm}}

\newcommand{\negl}{\mr{negl}}

\newcommand{\Acc}{\mbf{Acc}}

\newcommand{\sett}{\mr{Set}}


\newcommand{\absq}{\mathrm{Gal}_{\bq}}
\newcommand{\absql}{\mathrm{Gal}_{\bq_l}}
\newcommand{\absqp}{\mathrm{Gal}_{\bq_p}}
\newcommand{\absqph}{\mathrm{Gal}_{\bq_{p^h}}}

\newcommand{\absf}{\mathrm{Gal}_F}
\newcommand{\absfv}{\mathrm{Gal}_{F_v}}
\newcommand{\abse}{\mathrm{Gal}_E}
\newcommand{\absk}{\mathrm{Gal}_K}
\newcommand{\absl}{\mathrm{Gal}_L}

\newcommand{\Fr}{\mathrm{Fr}}
\newcommand{\WD}{\mathrm{WD}}

\newcommand{\Gm}{\mathbb{G}_m}

\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\rarrrow}{\rightarrow}
\newcommand{\lra}{\longrightarrow}
\newcommand{\llra}{\longleftrightarrow}
\newcommand{\xra}{\xrightarrow}
\newcommand{\hra}{\hookrightarrow}
\newcommand{\LRA}{\Longleftrightarrow}
\newcommand{\RA}{\Longrightarrow}
\newcommand{\harrow}{\hookrightarrow}
\newcommand{\lhra}{\hooklongrightarrow}

\newcommand{\imp}{\Longrightarrow}

\newcommand{\impop}{\overset{\;\;\mr{o.p.}\;\;}{\Longrightarrow}}

\newcommand{\eqlam}{\equiv_{\lam}}

\newcommand{\lameq}{\equiv_{\lam}}


\newcommand{\bs}{\backslash}
\newcommand{\ti}{\tilde}
\newcommand{\wti}{\widetilde}
\newcommand{\mf}{\mathfrak}
\newcommand{\mc}{\mathcal}
\newcommand{\mb}{\mathbb}
\newcommand{\mbf}{\mathbf} 
\newcommand{\mr}{\mathrm}
\newcommand{\mfp}{\mathfrak{p}}
\newcommand{\tmfp}{\ti{\mc{P}}}
\newcommand{\mfm}{\mathfrak{m}}
\newcommand{\mfn}{\mathfrak{n}}


\newcommand{\mfl}{\mathfrak{l}}

\newcommand{\zetamn}{\zeta_{mn}}

\newcommand{\setm}{\setminus}
\newcommand{\sm}{\setminus}

\newcommand{\Br}{\mr{Br}}

\newcommand{\Jac}{\mr{Jac}}

\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\Ga}{\Gamma}
\newcommand{\Gam}{\Gamma}
\newcommand{\lam}{\lambda}
\newcommand{\lamb}{\lambda}
\newcommand{\Lam}{\Lambda}
\newcommand{\Lamb}{\Lambda}
\newcommand{\del}{\delta}
\newcommand{\Del}{\Delta}
\newcommand{\si}{\sigma}
\newcommand{\tsi}{\tilde{\sigma}}
\newcommand{\om}{\omega}
\newcommand{\Om}{\Omega}
\newcommand{\what}{\widehat}
\newcommand{\weck}{\widecheck}


\newcommand{\ov}{\overline}


\newcommand{\bzlam}{\bz_{(\lam)}}

\newcommand{\sub}{\subseteq}

\newcommand{\nsub}{\nsubseteq}

\newcommand{\dlog}{\mbf{dlog}}

\newcommand{\Prob}{\mbf{Prob}}

\newcommand{\mP}{\mc{P}}

\newcommand{\V}{\mc{V}}


\newcommand{\pro}{\protect}
\newcommand{\Com}{\protect{\verb|Com|}}

\newcommand{\vs}{\vspace{-0.15cm}}

\newcommand{\para}{\;\;\;\;\;\;}

\newcommand{\noin}{\noindent}

\newcommand{\op}{overwhelming probability}

\newcommand{\np}{negligible probability}

\newcommand{\sta}{\stackrel{?}{=}}

\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}

\newcommand{\LCM}{\mbf{lcm}}

\newcommand{\GCD}{\mbf{gcd}}



%  End user defined commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These establish different environments for stating Theorems, Lemmas, Remarks, etc.

\newtheorem{Thm}{Theorem}[section]
\newtheorem{Prop}[Thm]{Proposition}
\newtheorem{Lem}[Thm]{Lemma}
\newtheorem{Corr}[Thm]{Corollary}
\newtheorem{Algo}[Thm]{Algorithm}
\newtheorem{Example}[Thm]{Example}

\newtheorem{Prot}[Thm]{Protocol}

\newtheorem{Def}{Definition}[section]

\newtheorem{Assumption}[Thm]{Assumption}

\newtheorem{Rem}[Thm]{Remark}

\declaretheorem{theorem} 
\declaretheoremstyle[%
  spaceabove=-2pt,%
  spacebelow=8pt,%
  headfont=\normalfont\itshape,%
  postheadspace=1em,%
  qed=\qedsymbol%
]{mystyle} 
\declaretheorem[name={Proof},style=mystyle,unnumbered,
]{prf}

\declaretheorem[name={Step},style=bold,unnumbered, %postheadspace=1em,%
qed=\qedsymbol%
]{prf1}

\numberwithin{equation}{section}


\renewcommand{\labelenumi}{(\alphaph{enumi})}

% End environments 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Now we're ready to start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\linespread{1.00}




\begin{document}
 
\title{Arguments of Knowledge\\ in hidden order groups}
\author{Steve Thakur}
\affil{}
\date{\vspace{-6ex}}
 
\maketitle

\begin{abstract} We study non-interactive arguments of knowledge (AoKs) in groups of hidden order. We provide protocols to aggregate the knowledge of the discrete logarithms between multiple elements and to prove certain relations between multiple discrete logarithms. This is equivalent to proving relationships between committed multisets that can be publicly verified against the constant-sized commitments to the multisets. In particular, we provide AoKs for disjointness of sets in cryptographic accumulators, with a view toward applications to sharded blockchains and verifiably outsourcing data storage. 

Recent work ([DGS20]) suggests that the hidden order groups need to be substantially larger in size that previously thought, in order to ensure $128$-bit security. Thus, in order to keep the communication complexity between the Prover and the the Verifier to a minimum, we have designed the protocols so that the proofs consist of a constant number of group elements, independent of the number of discrete logarithms, i.e. independent of the number of the committed multisets. We build on the techniques from [BBF19].\end{abstract}

\section{\fontsize{12}{12}\selectfont Introduction  }


Finite abelian groups of hidden order have gained prominence within cryptography in the last few years. The adaptive root assumption in such groups yields a cryptographic accumulator which is universal and dynamic with batchable membership and non-membership proofs. One of the best known verifiable delay functions is that constructed in [Wes18], which can be instantiated with any group of unknown order in which the adaptive root assumption holds. Such groups also form the basis for the transparent polynomial commitment constructed in [BFS19]. This is a polynomial commitment with logarithmic sized proofs and verification time and can be instantiated with any group of hidden order.

In this paper, we explore non-interactive arguments of knowledge in groups of hidden order. Our primary goal is to provide protocols for proofs of  disjointness of sets in accumulators. The primary use case for these AoKs is potential applications to sharded blockchains.

Recent work ([DGS20]) suggests that the hidden order groups need to be substantially larger in size that previously thought, in order to ensure $128$-bit security. Thus, with a view toward keeping the communication complexity between the Prover and the the Verifier to a minimum, we have designed the protocols so that the proofs consist of a constant number of group elements, independent of the number of exponents involved.   



\begin{comment}

\subsection{\fontsize{11}{11}\selectfont Notations and terminology}

\begin{Def} An argument system between a Prover and a Verifier is \textbf{non-interactive} if it consists of a single round of interaction. \end{Def}

\begin{Def} An argument of knowledge is said to be \textbf{public coin} if all challenges sent from the Verifier to the Prover are chosen uniformly at random and independently of the Prover's messages.\end{Def}

\noindent If the challenges are public coin, any interactive argument of knowledge can be converted into a non-interactive argument using a Fiat-Shamir heuristic ([FS86]).

\end{comment}}

\subsection{\fontsize{11}{11}\selectfont Candidates for hidden order groups }

At the moment, there are only three known families of finite abelian groups of unknown order. We briefly discuss them here.\vspace{0.1cm}

\noindent 1. \textbf{RSA groups:} For distinct $1536$-bit primes $p$, $q$, define $N:= pq$. The group $(\bz/N\bz)^*$ has order $\phi(N) = (p-1)(q-1)$ which can only be computed by factorizing $N$. The strong-RSA assumption is believed to hold in the RS group. However, the group does contain the element $-1\Mod{N}$ of a known order $2$. For the adaptive root assumption to hold, the group has to be replaced by its quotient group $(\bz/N\bz)^*/\{\pm 1\}$ of order $\frac{(p-1)(q-1)}{2}.$ 

The RSA groups suffer from the need for a trusted setup. In practice, this is usually mitigated by a secure multi-party computation. At the moment, a $3300$-bit RSA modulus yields a security level of $128$-bits.\\


\noindent 2. \textbf{Class groups:} Computing the class group of a number field is a long-standing problem in algorithmic number theory. Hence, class groups are a candidate for hidden order groups. At the moment, the only class groups that allow for efficient group operations are those of imaginary quadratic fields.

For a square-free integer $d > 0$, the field $\bq(\sqrt{-d})$ has a class group of size roughly $\sqrt{d}$. This group is believed to fulfill the strong-RSA assumption. Furthermore, if $d$ is a prime $\equiv 3 \Mod{4}$, the $2$-torsion group is trivial, which eliminates the possibility of known elements of order $2$. Such a group is believed to fulfill the adaptive root assumption.

A $6656$-bit discriminant $d$ yields a security level of $128$-bits at the moment. Unlike RSA groups, class groups allow for a transparent (trustless) setup. The downside is that for the same level of security, the group operations are roughly 10 times slower than modular multiplication.\\

\noindent 3. \textbf{Jacobians:} Recently, the group of $\bFp$-valued points of the Jacobian of a genus three hyperelliptic curve over a prime field $\bFp$ has been proposed as a candidate ([DGS20]) . While this idea needs more scrutiny, it seems promising because of the transparent setup, the smaller key sizes and the fact that the group operations are 28 times faster than those in class groups for the same level of security.

For an irreducible polynomial $f(X)\in \bz[X]$ of degree $7$ with Galois group $S_7$ and a prime $p$ such that $f(X)\Mod{p}$ is separable, the hyperelliptic curve $C:Y^2 = f(X)$ over $\bFp$ yields a Jacobian that is resistant to the known attacks. At the moment, such a genus three hyperelliptic Jacobian over a prime field $\bFp$ of bit-size $1100$ allows for a security level of $128$-bits. This group $\Jac(C)(\bFp)$ is roughly of size $p^3$. 


\subsection{\fontsize{11}{11} Cryptographic assumptions}

\begin{Def} We say that the \textbf{adaptive root assumption} holds for a group $\mb{G}$ if there is no efficient probabilistic polynomial time $($PPT$)$ adversary $(\mc{A}_0, \mc{A}_1)$ that succeeds in the following task. $\mc{A}_0$ outputs an element $w\in \mb{G}$ and some state. Then a random prime $l$ is chosen and $\mc{A}_1(l, \mr{state})$ outputs $w^{1/l}\in \mb{G}$. \end{Def}
 

\begin{Def} We say $\mb{G}$ satisfies the \textbf{strong-RSA} assumption if no PPT algorithm $\mc{A}$ is able to compute $($except with negligible probability$)$ the $l$-th root of a chosen element $w\in \mb{G}$ for some randomly chosen prime $l$.\end{Def}

\begin{Def} We say $\mb{G}$ satisfies the \textbf{low order assumption} if no PPT algorithm can generate $($except with negligible probability$)$ an element $a\in\mb{G}\setminus\{1\}$ and an integer $n< 2^{\mr{poly}(\lam)}$ such that $a^n = 1$.\end{Def}

\begin{Def} We say $\mb{G}$ satisfies the \textbf{fractional root assumption} if for a randomly generated element $g\in \mb{G}$, a PPT algorithm cannot output $h\in\mb{G}$ and $d_1,d_2\in\bz$ such that \vs $$g^{d_1} = h^{d_2}\;\wedge\; d_2 \nmid d_1$$ except with negligible probability.\end{Def}

\noin The assumptions bear the following relations: \vs $$\text{\{Adaptive root assumption\} }\imp \text{ \{Low order assumption\} } \imp \text{ \{Fractional root assumption\} },$$ \vspace{-0.6cm} $$\text{\{Strong-RSA assumption\} }\imp \text{ \{Fractional root assumption\}}. $$ We refer the reader to the appendix of [BBF19] for further details.

\subsection{\fontsize{11}{11}\selectfont Argument Systems }


\begin{Def} \normalfont We say an argument system $\protect{(\verb|Pgen,;P,V|)}$ is \textit{sound} if for all PPT adversaries $\mc{A} = (\mc{A}_0, \mc{A}_1)$, the probability of $\mc{A}$ forging a fake proof is negligible.\end{Def}

\begin{Def} \normalfont An argument system is \textit{non-interactive} if it consists of a single round of interaction between the Prover and the Verifier.\end{Def}



\subsection{\fontsize{11}{11}\selectfont Cryptographic Accumulators }

A cryptographic accumulator [Bd94] is a primitive that produces a short binding commitment to a set (or multiset) of elements together with short membership and/or non-membership proofs for any element in the set. These proofs can be publicly verified against the commitment. Broadly, there are three known types of accumulators at the moment: 

\noin - Merkle trees\\
- pairing-based (aka bilinear) accumulators \\  
- accumulators based on groups of unknown order, which we study in this paper. 

Let $\mb{G}$ be a group of hidden order and fix an element $g \in\mb{G}$. Let $\mc{M}= \{\mfm_1\cdot d_1,\cdots, \mfm_m\cdot d_m\}$ be a multiset, where $\mfm_i$ is the multiplicity of $d_i$. Using an appropriate hashing algorithm, we may assume the elements $d_i$ are distinct $\lam$-bit primes. For brevity, we write \vs $$\Pi(\mc{M}) := \pl_{i=1}^m d_i^{\mfm_i} .$$ The \textbf{accumulated digest} of $\mc{M}$ is given by \vs $$\Acc(\mc{M}):= g^{\Pi(\mc{M})} .$$ Let $\mc{M}_0 = \{\mfm_{0,1}\cdot d_1,\cdots, \mfm_{0,m}\cdot d_m\}$ be a multiset contained in $\mc{M}$, so that  $\mfm_{0,i}\leq \mfm_i\;\forall\;i$. The element \vs $$w(\mc{M}_0):= g^{\pl_{i=1}^m d_i^{\mfm_i - \mfm_{0,i}}}\;\in\;\mb{G} $$ is called \textit{the membership witness} of $\mc{M}_0$. Given this element, a Verifier can verify membership of $\mc{M}_0$ in $\mc{M}$ by verifying the equation \vs $$w(\mc{M}_0)^{\Pi(\mc{M}_0)} \sta \Acc(\mc{D}).$$ When the multiset $\mc{M}_0$ is large, this verification can be sped up using Wesolowki's \textit{Proof of Exponentiation} (\verb|PoE|) protocol ([Wes18]).

Shamir's trick allows for aggregation of membership witnesses in accumulators based on hidden order groups. This is not possible with Merkle trees, which is the primary reason other accumulators have been explored as authentication data structures for stateless blockchains. With bilinear accumulators, aggregation of membership witnesses has a linear runtime complexity, which is impractical for most use cases. Thus, accumulators based on hidden order groups have a major advantage in this regard.

These accumulators also allow for non-membership proofs [LLX07]. In [BBF19], the authors used a non-interactive argument of knowledge to compress batched non-membership proofs into constant-sized proofs, i.e. independent of the number of elements involved. This yields the first known Vector Commitment with constant-sized openings as well as  constant-sized public parameters.


\subsection{\fontsize{11}{11} Aggregating and disaggregating membership witnesses}

\noindent \textbf{Shamir's trick:} Given elements $a_1, a_2, A\in \mb{G}$ and integers $d_1, d_2\geq 1$ such that $a^{d_1} = a_2^{d_2} = A$, Shamir's trick allows us to compute the $\LCM(d_1, d_2)$-th root of $A$ as follows.

\noindent 1. Compute integers $e_1, e_2$ such that \vs $$e_1d_1+e_2d_2 = \GCD(d_1, d_2).$$

\noindent 2. Set $a_{1,2}:= a_1^{e_2}a_2^{e_1} $. 

\noindent Then \vspace{-0.15cm}$$a_{1,2}^{d_1d_2} = A^{d_2e_2 + d_1e_1} = A^{\GCD(d_1,d_2)}$$ and hence, \vspace{-0.15cm}$$a_{1,2}^{\LCM(d_1,d_2)} = A.$$ More generally, given elements $a_1,\cdots,a_n$ such that \vs $$a_1^{d_1} = \cdots = a_n^{d_n} = A, $$ we can use Shamir's trick repeatedly to compute an element $a\in\mb{G}$ such that \vs $$a^{\LCM(d_1,\cdots,d_n)} = A.$$ The runtime for this algorithm is $\mbf{O}(n\log(n))$. 

\begin{comment} Conversely, for any element $b = \pl_{i=1}^n a_i^{x_i}$ $(x_i\in\bz)$, we have \vs $$ b^{\LCM(d_1,\cdots,d_n)} = A^{\slim_{i=1}^n  \frac{\LCM(d_1,\cdots,d_n)x_i}{d_i}} $$ and the low order assumption implies that with \op, \vs $$b =  a^{\slim_{i=1}^n  \frac{\LCM(d_1,\cdots,d_n)x_i}{d_i}}.$$ Thus, $b$ is expressible as a power of $a$. 

\end{comment}

\vspace{0.2cm}


\noindent \textbf{The RootFactor Algorithm:} Given elements $a, A\in\mb{G}$ and integers $d_1,\cdots, d_n$, $D$ such that \vs $$D= \pl_{i=1}^n d_i\; ,\; a^{D} = A,$$ the RootFactor algorithm ([BBF19], [STY01]) allows us to compute elements $a_1,\cdots, a_n$ such that \vs $$a_1^{d_1}=\cdots = a_n^{d_n} = A$$ in runtime $\mbf{O}(\log(D)\log(\log(D)))$. Naively, this would take runtime $\mbf{O}(\log^2(D))$.


\subsection{\fontsize{11}{11}\selectfont $\bz_{(\lamb)}$-integers and the equivalence relation $\mathbf{(\equiv_{\lam})}$}

% \textbf{This subsection can be skipped for the time being. The protocols have been modified so that they do not involve this equivalence relation.}

\begin{Def} For elements $a, b\in\mb{G}$ and a rational $\al\in\bq$, we say $a^{\al} = \be$ with respect to a Prover $\mP$ if $\mP$ verifiably possesses integers $d_1,d_2\in\bz$ such that $\al = \frac{d_1}{d_2}$ and  $a^{d_1} = b^{d_2}$.\end{Def}

\noin Note that if there exists an element $a\in\mb{G}$ and distinct rationals $\frac{d_1}{d_2}, \frac{d_3}{d_4}\;(d_i\in\bz)$ such that \vs $$a^{\frac{d_1}{d_2}} = a^{\frac{d_3}{d_4}},$$ then $a^{d_1d_4-d_2d_3} = 1$ and $d_1d_4-d_2d_3\neq 0$. So the adaptive root assumption implies that a PPT algorithm cannot generate such a tuple $(a,d_1,d_2,d_3,d_4)$ except with negligible probability. Furthermore, by Shamir's trick, the condition is equivalent to the Prover $\mP$ being able to compute an element $a_0\in\mb{G}$ and co-prime integers $d_1,d_2$ such that \vs $$\al = \frac{d_1}{d_2}\;\;,\;\;a_0^{d_2} =a\;,\; a_0^{d_1} =b\;,\; $$


\begin{Def} An integer is said to be \textbf{$\lamb$-smooth} is all of its prime divisors are $\leq 2^{\lamb}$. An integer is said to be \textbf{$\lamb$-rough} is all of its prime divisors are $> 2^{\lamb}$.\end{Def}

\noindent The properties of $\lamb$-smoothness and $\lamb$-roughness are clearly preserved under products, greatest common divisors and least common multiples. Furthermore, any positive integer $n$ is uniquely expressible as a product $n_{{\lam,s}}n_{{\lam,r}}$ of a $\lam$-smooth integer $n_{{\lam,s}}\geq 0$ and a $\lam$-rough integer $n_{{\lam,r}}\geq 0$.

\begin{Def} For a security parameter $\lamb$, we denote by $\bz_{(\lamb)}$ the integral domain obtained by localizing $\bz$ away from all primes $\geq 2^{\lamb}$. \end{Def}

\noindent Thus, \vs $$\bz_{(\lamb)} = \left\{\frac{\al}{\be}:\; \al,\be\in\bz,\;\GCD(\al,\be) = 1,\; \be \text{ is } \lamb\text{-smooth}\right\}.$$ Note that $\bz_{(\lamb)}$ inherits the structure of a principal ideal domain. The group of units of $\bzlam$ is given by $$\bzlam^{\times} := \left\{\frac{\al}{\be}:\; \al,\be\in\bz,\;\GCD(\al,\be) = 1,\; \al, \be \text{ are } \lamb\text{-smooth}\right\}. $$ The prime ideals of $\bz_{(\lamb)}$ are the principal ideals generated by rational primes larger than $2^{\lamb}$.

\begin{Def} For $\bzlam$-integers $d_1,d_2$ we say $d_1\eqlam d_2$ if $\frac{d_1}{d_2}$ is a unit in $\bzlam$.\end{Def}

\noin This is clearly a homomorphic equivalence relation.

\begin{Def} For $\bzlam$-integers $d_1,d_2$, we denote by $\GCD_{\lam}(d_1,d_2)$ the largest $\lam$-rough integer that divides both $d_1$ and $d_2$ in the principal ideal domain $\bzlam$. Similarly, we denote by $\LCM_{\lam}(d_1,d_2)$ the smallest $\lam$-rough integer divisible by $d_1$ and $d_2$ in $\bzlam$.\end{Def}

\noin Let $d_1,\cdots,d_n$ be $\bzlam$-integers and write $d_i = \wti{d}_i\frac{\al_i}{\be_i}$ with $\wti{d}_i$ a $\lam$-rough integer and $\al_i$, $\be_i$ co-prime $\lam$-smooth integers. Clearly, for each pair $i,j$, we have the equivalence \vs $$\gcd(\wti{d}_i,\wti{d_j}) = 1\LRA d_i,d_j\text{ co-prime in }\bzlam. $$

\begin{Def} For elements $a, b$ in a hidden order group $\mb{G}$, we say \vs $$ a \equiv_{\lam} b$$ with respect to a Prover $\mc{P}$ if $\mc{P}$ verifiably possesses  relatively prime $\lamb$-smooth integers $d_1, d_2$ such that $a^{d_1} = b^{d_2}.$\end{Def}

\noindent Because of Shamir's trick, this is equivalent to $\mc{P}$ being able to generate an element $a_0\in \mb{G}$ and relatively prime $\lamb$-smooth integers $d_1, d_2$ such that \vs $$a_0^{d_2} = a, \; a_0^{d_1} = b.$$ It is easy to see that this an equivalence relation.

\begin{Prop} The relation $(\equiv_{\lam})$ is an equivalence relation.\end{Prop}

\begin{prf} Since the reflexivity and the symmetry are obvious, it suffices to show that the relation is transitive.

\noindent (Transitivity): Suppose $a \equiv_{\lam} b$ and $b \equiv_{\lam} c$ for elements $a, b, c\in\mb{G}$. Then $\mc{P}$ possesses $\lam$-smooth integers $d_1,d_2, d_3, d_4$ such that \vs $$a^{d_1} = b^{d_2}\;,\; b^{d_3} = c^{d_4}\;,\;\GCD(d_1,d_2) = \GCD(d_3,d_4) = 1.$$ Now, \vs $$a^{d_1d_3} = b^{d_2d_3} = c^{d_2 d_4}$$ and clearly, the integers $d_1d_3, d_2 d_4$ are $\lam$-smooth. Set $d:= \GCD(d_1d_3, d_2 d_4)$ and $e_1:= d_1d_3/d, d_2 d_4/d$. Then $e_1,e_2$ are co-prime and $\lam$-smooth and \vs $$ a^{e_1} = c^{e_2} .$$ Thus, $a \equiv_{\lam} c$.\end{prf}

For elements $a,b\in\mb{G}$ the following are equivalent:

\noin 1. $a^d\eqlam b$ for some integer $d$.\\
2. $a^d\eqlam b$ for some $\lam$-rough integer $d$.\\
3. $b = a^{d_1}$ for some $\bzlam$-integer $d_1$.

Furthermore, if a PPT algorithm is able to output an element $a\in\mb{G}$ and integers $d_1,d_2$ such that $a^{d_1}\eqlam a^{d_2}$, then with \op, $\frac{d_1}{d_2}\in\bzlam^{\times}$. In particular, no PPT algorithm can output an element $a\in \mb{G}$ and distinct $\lam$-rough integers $d_1,d_2$ such that $a^{d_1}\eqlam a^{d_2}$.

We note, however, that the relation $(\equiv_{\lam})$ is not homomorphic, meaning that $a_1 \equiv_{\lam} a_2$, $b_1 \equiv_{\lam} b_2$ does not imply $a_1a_2 \eqlam b_1b_2$. But the relation is \textit{partly} homomorphic in the sense that for any integer $d$, \vs $$ a \equiv_{\lam} b \LRA a^d \equiv_{\lam} b^d .$$ \vspace{0.1cm}


\noin \textbf{Non-membership proofs in accumulators:} The  best-known application of the knowledge of exponent protocol is constant-sized batched non-membership proofs in accumulators ([BBF19]). We discuss the implications of replacing equality of $\mb{G}$-elements with the equivalence relation $\eqlam$ in this regard. 

Let $g \in \mb{G}$ denote the genesis state of the accumulator, $\mc{D}$ the inserted data set and $A = g^{\pl_{d\in \mc{D}}}$ the accumulated digest. For brevity, we write $D:= \pl_{d\in \mc{D}} d$. Given a data set $\mc{D}_0$ disjoint with $\mc{D}$ and the product $D_0:= \pl_{d\in \mc{D}_0} d,$ the Prover demonstrates non-membership for all elements of $\mc{D}_0$ by sending the following to the Verifier:

\noin - Elements $w, A_1\in\mb{G}$ such that $w^{D_0}A_1 = g$.\\
- A non-interactive proof for \verb|PoKE|$[A,\; A_1]$.

Suppose, instead of \verb|PoKE|$[A,\; A_1]$, the Prover proves the weaker statement that he possesses an integer $k$ such that $A^k \eqlam A_1$. By definition, there exist an integer $k$ and a $\lam$-smooth integer $e$ such that $\GCD(k,e) = 1$ and $A^{k} = A_1^e$.

Write $w = g^x$. Then \vs $$ x D_0 +  
\frac{kD}{e} = 1 $$ and hence, \vs $$ex D_0 +  kD = e .$$ Thus, $\GCD(D_0, D)$ divides $e$ which is a $\lam$-smooth integer. Since each element of $\mc{D}$ is a $\lam$-bit prime, it follows that $\mc{D}\cap \mc{D}_0 = \emptyset$, despite $\frac{k}{e}$ possibly not being an integer.

\subsection{\fontsize{11}{11}\selectfont Some preliminary lemmas }

\noin We will need the next two lemmas repeatedly in the subsequent protocols.

\begin{Lem} Let $p$ be a prime and let $f(X)$ be a univariate degree $n$ polynomial in $\bz[X]$ such that not all coefficients are divisible by $p$. For a randomly generated integer $\gamma$, the probability that $f(\gamma)\equiv 0\Mod{p^{n\lam}}$ is $\negl(\lam)$.
\end{Lem}

\begin{prf} Let $F$ be a splitting field of $f(X)$ and let \vs $${f}(X) = \pl_{i=1}^n (X-\al_i)$$ be the factorization of ${f}(X)$ over $F$. Let $\mfp_{1},\cdots,\mfp_g$ be the distinct primes of $F$ lying over $p$. Since the extension $F/\bq$ is Galois, we have \vs $$p\mc{O}_F = \pl_{i=1}^{g} \mfp_i^e = \bigcap\limits_{i=1}^{g} \mfp_i^e$$ where $e\geq 1$ is the ramification degree and the Galois group $\Gal(F/\bq)$ acts transitively on the set $\{ \mfp_1,\cdots,\mfp_g\}$.

We note that for any integer $k\geq 1$, $\mfp_1^{ek}\cap \bz = p^{k}\bz$. The inclusion $p^{k}\bz\sub \mfp_1^{ek}\cap \bz$ is obvious. For the reverse inclusion, let $x\in \mfp_1^{ek}\cap \bz$. For any index $i$, there exists an automorphism $\sigma_i\in \Gal(F/\bq)$ such that $\sigma_i(\mfp_1) = \mfp_i$. So $x = \sigma(x) \in \mfp_i^e$. Hence, $x\in \bigcap\limits_{i=1}^g \mfp_i^{ek} = p^{k}\bz$.

For any two integers $x_1,x_2\in \bz$, we have \vs $$x_1-x_2\in \mfp_1^{e\lam}\LRA x_1-x_2\in \mfp_1^{e\lam}\cap \bz = p^{\lam}\bz.$$ Hence, the set \vs $$ S_{\lam}:= \{x + {\mfp_1^{e\lam}}:\;x\in\bz \}\sub \mc{O}_F/\mfp^{e\lam} $$ has cardinality $p^{\lam}$. Now, for any integer $\gamma$, \vs $$f(\gamma)\equiv 0 \Mod{p^{n\lam}} \LRA f(\gamma)\equiv 0 \Mod{\mfp_1^{en\lam}}  \Longrightarrow \gamma\equiv \al_i \Mod{\mfp_1^{e\lam}}\text{ for at least one index } i. $$  Since $\gamma$ is randomly generated, $\gamma\Mod{\mfp_1^{e\lam}}$ is randomly and uniformly distributed over the set $S_{\lam}$. Hence, \vs $$ \mbf{Prob}\big( f(\gamma)\equiv 0 \Mod{p^{n\lam}} \big)\leq \frac{n}{p^{\lam}} = \negl(\lam),$$ which completes the proof.\end{prf}

\begin{Lem}$\mbf{1}$. For rationals $d_1,\cdots, d_n\in \bq$ and a randomly generated $\lam$-bit integer $\gamma$, if \vs$$\sum\limits_{i=1}^n d_i\gamma^i\; \in \;\bzlam,$$ with \op, $d_1,\cdots, d_n\in \bzlam$.\vspace{0.1cm}

\noin $\mbf{2}$. For rationals $d_1,\cdots, d_n\in \bq$ and a randomly generated $\lam$-bit integer $\gamma$, if \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i\; \in \;\bz,$$ with \op, $d_1,\cdots, d_n\in \bz$.\end{Lem}

\begin{prf} $\mbf{1}$. Let $D$ be the least common denominator for $d_1,\cdots, d_n$ and write $d_i = \frac{c_i}{D}$ for $i=1,\cdots, n.$ Suppose, by way of contradiction that $(d_1,\cdots, d_n )\notin \bzlam^n$. Then $D$ is divisible by some prime $p>2^{\lam}$ and \vs $$\sum\limits_{i=1}^n  {c_i\gamma^i} \equiv 0\Mod{p}.$$ Now, the polynomial $\sum\limits_{i=1}^n c_iX^i \in \bFp[X]$ has at most $n$ distinct zeros in $\bFp$ and since $\gamma$ is uniformly distributed modulo $p$, the probability of this occurring is $\negl(\lamb)$, a contradiction.\vspace{0.15cm} 

\noin $\mbf{2}$. Let $D$ be the least common denominator for $d_1,\cdots, d_n$ and write $d_i = \frac{c_i}{D}$ for $i=1,\cdots, n.$ Suppose, by way of contradiction that $(d_1^{n\lam},\cdots, d_n^{n\lam} )\notin \bz^n$ and let $p$ be a prime dividing $D$. Then $$\slim_{i=1}^n c_i^{n\lam}\gamma^i \equiv 0\Mod{p^{n\lam}}.$$ Now, the polynomial $f(X):= \slim_{i=1}^n c_i^{n\lam} X^i$ has degree $n$ and by the preceding lemma, \vs $$\mbf{Prob}\big(h(\gamma)\equiv 0\Mod{p^{n\lam}} \big) = \negl(\lam).$$ Thus, with \op, the rationals $d_i^{n\lam}$ are integers, which in turn implies that the $d_i$ are integers.\end{prf}


\begin{comment}
For the second part, note that \vs $$\Prob\big(\sum\limits_{i=1}^n d_i\gamma_j^i\in \bz\;\forall j\big|\; (d_1,\cdots,d_n)\notin \bz\big ) = \Prob\big(\sum\limits_{i=1}^n d_i\gamma^i\in \bz\big|\; (d_1,\cdots,d_n)\notin \bz\big )^{\lam} = \negl(\lam).$$\end{comment}

\noindent In particular, \vs $$\mbf{Prob}\big((d_1,\cdots, d_n)\notin \bzlam^n \;\Big|\;\sum\limits_{i=1}^n d_i\gamma^i\; \in \;\bz \big) = \negl(\lamb).$$ Similarly, \vs $$ \mbf{Prob}\big((d_1,\cdots, d_n)\notin \bz^n \;\Big|\;\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\; \in \;\bz \big) = \negl(\lamb). $$


In a setting where the Verifier is not satisfied with the elements $d_1,\cdots, d_n$ being $\bzlam$-integers and needs a probabilistic proof that they are, in fact, rational integers, the Prover could demonstrate that $\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$. The resulting trade-off is a higher computational burden for the Prover. Computing \vs $$g^{\slim_{i=1}^n d_i^{n\lam} \gamma^i}$$ entails \vs $$\mbf{O}\big(\log(\slim_{i=1}^n d_i^{n\lam} \gamma^i)\big) = \mbf{O}\big(n\log(n)\lam\max\{\log(d_i)\}\big) $$ exponentiations in $\mb{G}$. On the other hand, computing $g^{\slim_{i=1}^n d_i\gamma^i}$ entails \vs $$\mbf{O}\big(\log(\slim_{i=1}^n d_i\gamma^i)\big) = \mbf{O}\big(\log(n)\max\{\log(d_i)\}) \big)$$ group exponentiations.



Given a randomly generated element $g\in \mb{G}$, if the Prover outputs an element $\wti{g} = g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$, then the fractional root assumption implies that $\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$ except with negligible probability. The lemma 1.4 then implies that with \op, $(d_1,\cdots,d_n)\in \bz^n$.
\bigskip



\section{\fontsize{12}{12}\selectfont Arguments of Knowledge  }

\noindent We briefly review the protocol \verb|PoKE| from [BBF19]. 

\begin{Prot} \normalfont \textit{Proof of Knowledge of the Exponent} (\verb|PoKE|) \end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$

\noindent \textbf{Inputs:} $u, w \in \mb{G}$.

\noindent \textbf{Claim:} The Prover posseses an integer $x$ such that $u^x = w$

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes $z:= g^x$ and sends it to the Verifier $\mc{V}$.

\noindent 2. The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$.

\noindent 3. $\mc{P}$ computes the integers $q, r$ such that  \vspace{-0.15cm}$$x = ql+r,\;\; r\in [l].$$

\noindent 4. $\mc{P}$ computes $Q:= u^q,\; Q' = g^q$ and sends $(Q, Q', g^x, r)$ to $\mc{V}$.

\noindent 5. $\mc{V}$ accepts if and only if \vspace{-0.15cm}$$r\in [l],\;\; Q^lu^r w,\;\; Q'^lg^r = z.$$\end{prf1}

The part where $\mc{P}$ computes $g^x$ and sends it to $\mc{V}$ \textit{before} receiving the challenge $l$ is necessary for the security of the protocol. Without this step, a malicious Prover could convince the Verifier that $x$ is an integer, which might not necessarily be the case.

Clearly, the relation \textit{Knowledge of the Exponent} is transitive in the sense that for elements $a_1,a_2,a_3\in\mb{G}$, if a prover $\mP$ possesses integers $d_1,d_2$ such that $a_1^{d_1} = a_2\;,\;a_2^{d_2} = a_3$, then he possesses the integer $d_1d_2$ which fulfills the equation $a_1^{d_1d_2} = a_3$. Henceforth, we denote the proof of knowledge of the discrete logarithm between $a,b\in\mb{G}$ by $\verb|PoKE|[a,b]$. 

In the following protocol, we show how a Prover could probabilistically demonstrate that two discrete logarithms are equal without revealing anything about the common discrete logarithm other than residues modulo a prime challenge. We provide an argument of knowledge for  the following relation:

\[
  \mc{R}_{{\protect\verb|EqDLog|}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1),\; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}: \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\]
\vspace{0.15cm}


\begin{Prot}\label{EqDLog} \normalfont \textit{Proof of equality of discrete logarithms} (\verb|PoEqDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} $a_1, a_2, b_1, b_2 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses an integer $d$ such that $a_1^d = b_1$ and $a_2^d = b_2$.

\begin{prf1}\normalfont \noin 1. The Prover $\mc{P}$ sends $\wti{g}:= g^d$ to the Verifier $\mc{V}$.

\noindent 2. The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$. 

\noindent 3. $\mc{P}$ computes the integers $q, r$ such that $d = ql+r$, $r\in [l]$ and the group elements \vs $$Q_1:= a_1^q,\;\; Q_2:= a_2^q,\;\; \weck{g}:= g^q.$$ He sends $(Q_1, Q_2, \weck{g}, r)$ to $\mc{V}$.

\noindent 3. $\mc{V}$ verifies the equations \vs $$r\in [l],\;\;Q_1^la_1^r \sta  b_1, \;\; Q_2^la_2^r \sta  b_2, \;\; (\weck{g})^lg^r \sta \wti{g}.$$ He accepts if and only if all equations hold.\end{prf1}

\noin Thus, the proof consists of four $\mb{G}$-elements and one $\lam$-bit integer. 

\begin{Prop} The protocol \verb|EqDLog|$[(a_1, b_1),\; (a_2, b_2)]$ is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|EqDLog|}}$ in the generic group model.\end{Prop}

\begin{prf} Since the protocol \verb|PoKE| is secure ([BBF19]), the validity of the equations \vs $$Q_1^la_1^r \stackrel{?}{=}  b_1, \;\; Q_2^la_2^r \stackrel{?}{=} b_2, \;\; (\weck{g})^l g^r \stackrel{?}{=} \wti{g}$$ proves that $\mc{P}$ possesses the discrete logarithms between $a_1, b_1$ and $a_2, b_2$. Suppose, by way of contradiction, that these discrete logarithms are distinct and denote them by $d_1$, $d_2$ respectively. The adaptive root assumption implies that with \op,\vs $$d_1 \equiv r\equiv d_2 \Mod{l}.$$ But since the $\lamb$-bit prime $l$ is randomly generated, the integer $d_1-d_2$ is randomly and uniformly distributed modulo $l$ and hence, \vs $$ \Prob\big( d_1\equiv d_2\Mod{l}\; \Big|\; d_1\neq d_2    \big) = \frac{1}{l} =\negl(\lamb),$$ a contradiction.\end{prf}

\vspace{0.2cm}

\noindent We now show how to generalize the last protocol for multiple discrete logarithms while keeping the communication complexity constant-sized and independent of the number of discrete logarithms. We call the following protocol the \textit{Aggregated Equality of Discrete Logarithms} or \verb|AggEqDLog| for short. We provide an argument of knowledge for  the following relation:

\[
  \mc{R}_{{\protect\verb|AggEqDLog|}}[(a, b),\;(\mc{A},\;\mc{B})] = \left\{\begin{array}{l}
  	%(a, b)\in\mb{G}^2\\
    (\mc{A} = (a_1, \cdots, a_n),\;\mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\
    d\in\mb{Z}): \\
    b_i = a_1^{d} \;\forall\;i
  \end{array}\right\}
\]

\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Equal Discrete Logarithms} (\verb|PoAggEqDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs :} $a,b\in\mb{G}$, $(a_1, \cdots, a_n)\in\mb{G}^n$, $(b_1, \cdots, b_n)\in\mb{G}^n$.

%\noindent \textbf{Inputs:} 

\noindent \textbf{Claim:} The Prover possesses an integer $d$ such that $a^d = b$ and $a_i^d = b_i$ for $i = 1,\cdots, n$ .

\begin{prf1} \normalfont 1. The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noindent 2. The Prover $\mc{P}$ computes the elements \vspace{-0.15cm}$$\wti{a}:= \prod\limits_{i=1}^n a_i^{\gamma^i}, \;\;\wti{b}:= \prod\limits_{i=1}^n b_i^{\gamma^i}\;\; \in \mb{G}.$$

\noindent 3. $\mc{P}$ generates a non-interactive proof for \verb|EqDLog|$[(a, b),\; (\wti{a}, \wti{b})]$ and sends it to the Verifier $\mc{V}$.

\noindent 4. $\mc{V}$ independently computes the elements $\wti{a}, \wti{b}$ and accepts if and only if the proof for\\ \verb|EqDLog|$[(a, b),\; (\wti{a}, \wti{b})]$ is valid.\end{prf1}
\vspace{0.1cm}

\noin Thus, the proof consists of four $\mb{G}$-elements and one  $\lam$-bit integer. In particular, it is constant-sized and independent of the cardinalities $|\mc{A}|$, $|\mc{B}|$.


\vspace{0.1cm}

\begin{Prop} The protocol \verb|AggEqDLog| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggEqDLog|}}$in the generic group
model.\end{Prop}

\begin{prf} (Sketch) With notations as in in the Protocol, $\mc{V}$ accepts if and only if $\mc{P}$ proves possession of an integer $d$ such that $$a^d = b,\;\;\wti{a}^d = \wti{b}$$ through the Protocol \verb|PoEqDLog|$[(a,b),\; (\wti{a},\wti{b})]$. Now, since the challenge $\gamma$ is randomly generated, it follows that \vspace{-0.15cm}$$ \mbf{Prob}\left( (a_1^d,\cdots, a_n^d) \neq (b_1,\cdots, b_n)\;   \Big|\; \wti{a}^d = \wti{b} \right) \in \negl(\lamb). $$ Since the Protocol \verb|EqDLog|$[(a,b),\; (\wti{a},\wti{b})]$ is secure under the strong-RSA and adaptive root\\ assumptions, it follows that the Protocol \verb|AggEqDLog|$[(a_1, b_1),\; (a_2, b_2)]$ is also secure under these assumptions.\end{prf}



\bigskip


\noindent We can also generalize the protocol \verb|EqDLog| in another direction. For a public polynomial {$f(X)\in \bz[X]$}, an honest Prover can provide a constant-sized proof that he possesses integers $d_1,d_2$ such that \vs $$a_1^{d_1} = b_1\;,\;a_2^{d_2} = b_2\;,\;f(d_1) = d_2.$$ We provide an argument of knowledge for the relation 

\[
  \mc{R}_{{\protect\verb|PolyDLog|}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    ((a_1, b_1), (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]);\\
    (d_1, d_2)\in\mb{Z}^2: \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_1 = a_1^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\] 

\vspace{0.2cm}


\begin{Prot} \normalfont \textit{Proof of Polynomial equation between discrete logarithms} (\verb|PoPolyDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, b_1, a_2, b_2\in \mb{G}$, a public polynomial $f(X)\in\bz[X]$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$ such that:

\noindent -$a_1^{d_1} = b_1,\;  a_2^{d_2} = b_2$\\
-$f(d_1) = d_2$

\begin{prf1}\normalfont 1. The Prover $\mc{P}$ computes $\wti{g}_1, \wti{g}_2$ and sends them to the Verifier $\mc{V}$.

\noindent 2. The Fiat-Shamir heuristic generates a $\lamb$-bit prime $l$.

\noindent 3. $\mc{P}$ computes elements $q_1, q_2, r_1, r_2$ such that \vs $$d_1 = q_1l+r_1,\; d_2 = q_1l+r_1,\;\; r_1,r_2\in [l].$$

\noindent 4. $\mc{P}$ computes the elements $Q_1:= a_1^{q_1},\;Q_2:= a_2^{q_2},\; g_1:= g^{q_1},\; g_2:= g^{q_2}\;\in\mb{G}$ and sends them to $\mc{V}$ along with the integer $r_1$.

\noindent 5. The Verifer verifies that $r_1\in [l]$. He independently computes $r_2:= f(r_1)\Mod{l}$.

\noindent 6. $\mc{V}$ verifies the equations \vs $$Q_1^{l}a_1^{r_1}\stackrel{?}{=} b_1\;\;\bigwedge\;\; Q_2^{l}a_2^{r_2}\stackrel{?}{=} b_2 \;\;\bigwedge\;\; (g_1)^lg^{r_1} \stackrel{?}{=} \wti{g}_1\;\;\bigwedge\;\; (g_2)^lg^{r_2} \stackrel{?}{=} \wti{g}_2 $$ and accepts the validity of the claim if and only if all equations hold.\end{prf1}

\noindent Thus, the proof consists of six elements of $\mb{G}$ and one $\lam$-bit integer.

\begin{Prop} The protocol \verb|PoPolyDLog| is an argument of knowledge in the generic group
model.\end{Prop}

\begin{prf} (Sketch) The Verifier independently computes $r_2:= f(r_1)\Mod{l}$ in Step 6. Hence, the equations $$Q_1^{l}a_1^{r_1}\stackrel{?}{=} b_1\;\;\bigwedge\;\; Q_2^{l}a_2^{r_2}$$ imply that with \op, the Prover possesses rationals $d_1,d_2$ such that $$a^{d_1} = b_1\;,\;a_2^{d_2} = b_2,\;,\;d_2\equiv f(d_1)\Mod{l}.$$ Furthermore, the equations \vs $$(g_1)^lg^{r_1} \stackrel{?}{=} g^{d_1}\;\;\bigwedge\;\; (g_2)^lg^{r_2} \stackrel{?}{=} g^{d_2} $$ imply that with \op, \vs $$\wti{g}_1 = g^{d_1}\;\bigwedge\;\wti{g}_2 = g^{d_2}. $$ The fractional root assumption now implies that with \op, $d_1,d_2\in \bz$.\end{prf}

\noin In the next section, we will generalize this protocol to multivariate polynomial relations for multiple discrete logarithms. We briefly discuss an application of the last protocol.\\

\noin \textbf{Multiset accumulators:} Let $a_1,a_2$ be elements of $\mb{G}$. Let \vs $$\mc{M} = \{\mf{m}_1\cdot d_1,\cdots, \mf{m}_m\cdot d_m \}\;,\;\mc{N} = \{\mf{n}_1\cdot e_1,\cdots, \mf{n}_n\cdot e_n \}$$ be multisets, where $\mf{m}_i,\;\mf{n}_j$ are the multiplicities of the elements. For brevity, we write \vs $$\Pi(\mc{M}):= \pl_{i=1}^m d_i^{\mfm_i}\;,\; \Pi(\mc{M}):= \pl_{j=1}^n e_j^{\mfn_j}.$$ Let \vs $$A_1:= g^{\Pi(\mc{M})}\;,\; A_2:= g^{\Pi(\mc{N})}$$ be the commitments of $\mc{M}$, $\mc{N}$.

Clearly, the relation $\mc{N}\sub \mc{M}$ can be demonstrated by the protocol \verb|PoKE|$[A_2, A_1]$. We now show that the protocol \verb|PolyDLog| allows a Prover to succinctly demonstrate the following relations between the underlying sets of $\mc{M}$, $\mc{N}$, the proofs for which can be publicly verified against the commitments to $\mc{M}$ and $\mc{N}$.\vspace{0.1cm}

\noin 1. $\sett(\mc{M})\sub \sett(\mc{N})$.

\noin 2. $\sett(\mc{M})\nsub \sett(\mc{N})$.

\noin 3. $\sett(\mc{M}) = \sett(\mc{N})$ \vspace{0.1cm}

\noin Before we describe the protocols, we note a few basic facts. Clearly, we have \vs $$\sett(\mc{M}) = \sett(\mc{N})\LRA \sett(\mc{M}) \sub \sett(\mc{N})\;\bigwedge\; \sett(\mc{N}) \sub \sett(\mc{M}).$$ Furthermore, with notations as before, we have \vs $$\sett(\mc{M})\sub \sett(\mc{N})\LRA \exists\; N:\;\Pi(\mc{M})^N\equiv 0\Mod{\Pi(\mc{N})}.$$ Likewise, to show that $\sett(\mc{M})\nsub \sett(\mc{N})$, it suffices to show that there exists an integer $p$ such that \vs $$p\notin \{-1,1\}   \;\bigwedge\;\Pi(\mc{M})\equiv 0\Mod{p} \;\bigwedge\; \Pi(\mc{N})\not\equiv 0\Mod{p}.$$ 


\begin{Prot} Protocol for the containment of underlying sets.\end{Prot} \vspace{-0.2cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noin \textbf{Input:} Multisets $\mc{M}$, $\mc{N}$.

\noin \textbf{Claim:} $\sett(\mc{N})\sub \sett(\mc{M})$.

\noin 1. The Prover $\mP$ computes $N:= \max\{\mf{n}_j:1\leq j\leq n \}$ and \vs $$A_3:= g^{(\pl_{i=1}^m d_i^{\mf{m}_i})^N}.$$ He sends $A_3$ and $N$ to the Verifier $\V$.

\noin 2. $\mP$ computes a non-interactive proof for \verb|PoPolyDLog|$[(g, A_1),\;(g, A_3),\;X^N]$ and sends it to $\V$.

\noin 3. $\mP$ computes a non-interactive proof for \verb|PoKE|$[A_2,A_3]$ and sends it to $\V$.

\noin 4. $\V$ verifies the two proofs and accepts if and only if both are valid.

\bigskip

\begin{Prot} Protocol for the non-containment of underlying sets.\end{Prot}\vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$. 

\noin \textbf{Input:} Multisets $\mc{M}$, $\mc{N}$ and commitments $[a_1, A_1]$, $[a_2, A_2]$ for $\mc{M}$, $\mc{N}$ respectively.

\noin \textbf{Claim:} $\sett(\mc{M})\nsub \sett(\mc{N})$.

\noin 1. The Prover chooses an integer $p$ such that $p\in \sett(\mc{M})\setminus \sett(\mc{N}).$ and computes $b_1: = a_1^p$. He sends $b_1$ to the Verifier $\V$ long with a non-interactive proof for \verb|PoKE|$[b_1, A_1]$.

\noin 2. $\mP$ computes a non-interactive proof for \verb|RelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$ and sends it to $\V$.

\noin 3. $\V$ verifies that $b_1\notin \{ a_1, a_1^{-1}\}$ and the proofs for \verb|PoKE|$[b_1, A_1]$, \verb|RelPrimeDLog|$[(a_1, b_1),\; (a_2, A_2)]$. He accepts if and only if both proofs are valid.


\bigskip



\subsection{\fontsize{11}{11}\selectfont Aggregating the knowledge of multiple exponents}

We call the following protocol the \textit{Proof of Aggregated Knowledge of the Exponent 1} or \verb|AggKE-1| for short. We provide an argument of knowledge for the relation:
\[
  \mc{R}_{{\protect\verb|AggKE-1|}}[a,\; \mc{B}] = \left\{\begin{array}{l}
    (a\in\mb{G}, \mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\ 
    (d_1,\cdots,d_n)\in\bz^n):  \\
    b_i = a^{d_i}\;\forall\; i
  \end{array}\right\}
\]


\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated knowledge of exponents} 1 (\verb|PoAggKE-1|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a\in\mb{G} $, $(b_1,\cdots,b_n)\in \mb{G}^n$ for some integer $n\geq 1$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that $a^{d_i} = b_i$ for $i = 1,\cdots, n$

\begin{prf1} \normalfont 1. The Fiat-Shamir heuristic generates $\lamb$-bit challenge $\gamma$.

\noin 2. The Prover $\mc{P}$ computes $\wti{g}:= g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends it to the Verifier $\mc{V}$.

\noindent 3. $\mc{P}$ computes \vs $$b:= \prod\limits_{i=1}^n b_i^{\gamma^i} \in \mb{G}.$$

\noin 4. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$. 

\noindent 5. $\mc{P}$ computes the integers $r_i:= d_i\Mod{l}$ and the integers $q, r,\wti{q},\wti{r}$ such that \vs $$\slim_{i=1}^n d_i\gamma^i = ql+r\;,\; \slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r},\;\;\;r,\wti{r}\in[l]$$ and \vs $$Q:= a^q\;,\; \weck{g}:= g^{\wti{q}}.$$ He sends $Q, \weck{g}, (r_1,\cdots,r_n)$ to the Verifier.

\noin 6. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 7. $\mP$ computes integers $q_0, r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0\;,\;r_0\in[l] .$$ He computes $Q_0:= a^{q_0}$ and sends it to $\V.$

\noindent 8. $\mc{V}$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$b := \prod\limits_{i=1}^n b_i^{\gamma^i}\;,\;b_0 := \prod\limits_{i=1}^n b_i^{\gamma_0^i}\;,$$ \vspace{-0.2cm} $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i\Mod{l}\;,\;r_0:=\slim_{i=1}^n r_i\gamma_0^i\Mod{l}.$$ 

\noin 9. $V$ verifies the equations \vs $$Q^la^r\sta b\;\bigwedge\;(Q_0)^la^{r_0}\sta b_0\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta\wti{g}.$$ He accepts if and only if all equations hold.\end{prf1}

Thus, the proof consists of three $\mb{G}$-elements and $n$ $\lam$-bit integers. In particular, the number of $\mb{G}$-elements is constant-sized and independent of the number of exponents. For the security of the protocol, it is necessary that the challenge $\gamma_0$ is generated \textit{after} the remainders $r_1,\cdots,r_n$ have been committed. In a non-interactive setting, this means the hashing algorithm that generates $\gamma_0$ takes the set of remainders modulo $l$ as one of its inputs. Hence, the remainders $r_i:= d_i\Mod{l}$ must be honestly computed to succeed at the additional task of computing the element $Q_0\in\mb{G}$ such that $(Q_0)^la^{r_0} = b_0$.



\vspace{0.2cm}

\begin{Prop} The protocol \verb|PoAggKE-1| is an argument of knowledge for the relation\\ $\mc{R}_{{\protect\verb|AggKE-1|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The equation $Q_0^la^{r_0} = b_0$ implies that $\mP$ possesses rationals $d_1,\cdots,d_n$ such that $r_i\equiv d_i\Mod{l}$ and 
$a_i^{d_i} = b_i$. Furthermore, we have $\wti{g} = (\weck{g})^lg^{\wti{r}}$ and hence, the adaptive root assumption implies that with \op, \vs $$\wti{g} = g^{(\slim_{i=1}^n d_i^{n\lam}\gamma^i)+lk} $$ for some integer $k$. Since the $\lam$-bit prime $l$ is randomly generated, the discrete logarithm between $g,\wti{g}$ is randomly and uniformly distributed modulo $l$. Hence, the Schwartz-Zippel lemma implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}.$$ Now, the fractional root assumption implies that with \op, $\slim_{i=1}^n d_i^{n\lam}\gamma^i\in\bz$. From Lemma 1.3, it follows that with \op, $(d_1,\cdots,d_n)\in\bz^n$.\end{prf}

\bigskip

In the next protocol, we generalize the protocol \verb|PolyDLog| to multiple discrete logarithms. We provide an argument of knowledge for the relation: 
\[
  \mc{R}_{{\protect\verb|MultPolyDLog|}}[a,\; (b_1,\cdots, b_n),\; f] = \left\{\begin{array}{l}
    (a\in\mb{G},\; (b_1,\cdots, b_n)\in\mb{G}^n);\\
    f\in\bz[X_1,\cdots,X_n];\\ 
    (d_1,\cdots,d_n)\in\bz^n)\;: \\
    b_i = a^{d_i}\;\forall\; i\;\bigwedge \;   f(d_1,\cdots,d_n) = 0 
  \end{array}\right\}
\] The soundness of the protocol hinges on the Schartz-Zippel lemma for multivariate polynomials, which we state here.

\begin{Lem} $\mr{(Schwartz\text{-}Zippel)}:$ Let $F$ be a field and let $f\in F[X_1,\cdots,X_n]$ be a polynomial. Let $r_1,\cdots,r_n$ be selected randomly and uniformly from a subset $S\sub F$. Then \vspace{-0.1cm}$$\mbf{Prob}[f(r_1,\cdots, r_n) = 0] \leq \frac{\deg(f)}{|S|}.$$\end{Lem}


\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of multivariate polynomial relation between discrete logarithms}\\ (\verb|PoMultPolyDLog|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a\in\mb{G} $, $(b_1,\cdots,b_n)\in \mb{G}^n$ for some integer $n\geq 1$; a public $n$-variate polynomial $f(X_1,\cdots,X_n)\in \bz[X_1,\cdots,X_n]$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that:

\noindent- $a^{d_i} = b_i$ for $i = 1,\cdots, n$.\\
- $f(d_1,\cdots,d_n) = 0$.

\begin{prf1} \normalfont 1. The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noindent 2. $\mc{P}$ computes $\wti{g}:=g^{\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends it to the Verifier $\mc{V}$.

\noindent 3. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.
 
\noindent 4. $\mc{P}$ computes the integers $r_i:=d_i\Mod{l}\;\; (i=1,\cdots, n)$ and the integers $\wti{q}, q, \wti{r}, r$ such that \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\slim_{i=1}^n d_i\gamma^i = ql+r\;,\;\;\;\wti{r}, r\in [l] .$$

\noin 5. $\mP$ computes $Q:= a^q\;,\;\weck{g}:= g^{\wti{q}}$ and sends $Q,\weck{g},(r_1,\cdots,r_n)$ to  $\V$. 

\noin 6. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 7. $\mP$ computes the integers $q_0, r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0\;,\;r_0\in[l] .$$ He computes $Q_0:= a^{q_{0}}$ and sends $Q_0$ to $\V$.

\noindent 8. $\mc{V}$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i\Mod{l}\;,\;r_0:= \slim_{i=1}^n r_i\gamma_0^i\Mod{l}.$$

\noin 9. $\V$ computes \vs $$b:= \pl_{i=1}^n b_i^{\gamma^i}\;,\;b_0:= \pl_{i=1}^n b_i^{\gamma_0^i}.$$

\noindent 10. $\mc{V}$ verifies the equations \vs $$ Q^{l} a^{r} \sta b \;\;\bigwedge\;\;(Q_0)^{l} a^{r_{0}} \sta b_0 \;\;\bigwedge\;\; (\weck{g})^lg^{\wti{r}} \stackrel{?}{=}\wti{g} \;\;\bigwedge\;\;f(r_1,\cdots,r_n) \stackrel{?}{\equiv} 0\Mod{l} .$$ He accepts the validity of the claim if and only if all equations hold.\end{prf1}


\vspace{0.1cm}

Thus, the proof consists of five $\mb{G}$-elements and $n$ $\lam$-bit integers. We note that the additional challenge $\gamma_0$ is necessary for the security of the protocol. A malicious Prover $\mP_{\mr{mal}}$ could forge a fake proof as follows.

\noin 1. $\mP_{\mr{mal}}$ computes integers $r_1,\cdots,r_n\in[l]$ such that \vs $$ \slim_{i=1}^n d_i^{n\lam}\gamma^i\equiv\slim_{i=1}^n r_i^{n\lam}\gamma^i\Mod{l} \;,\;f(r_1,\cdots,r_n) \equiv 0\Mod{l}.$$ but $d_i\not\equiv r_i\Mod{l}$ for some or all indices $i$. The malicious Prover can succeed in this task with non-negligible probability.

\noin 2. $\mP_{\mr{mal}}$ then sends $r_1,\cdots,r_n$ to the Verifier.

\noin 3. The Verifier is thus tricked into believing that $f(d_1,\cdots,d_n) = 0$, which might not necessarily be the case.

Now, in our protocol, $\gamma_0$ is randomly generated by the Fiat-Shamir heuristic \textit{after} the Prover sends $(r_1,\cdots,r_n)$. In a non-inertactive setting, this means the hashing algorithm that generates the challenge $\gamma_0$ takes the $\lam$-bit integers $(r_1,\cdots,r_n)$ as one of its inputs. Hence, we have \vs $$\Prob\Big(\slim_{i=1}^n d_i\gamma_0^i \equiv \slim_{i=1}^n r_i\gamma_0^i \Mod{l}\;\Big|\; d_i\not\equiv r_i\Mod{l}\;\text{for some } i\Big) = \negl(\lam). $$ Hence, the elements $(r_1,\cdots,r_n)$ must be honestly computed in order to succeed at the additional task of computing the element $\what{Q}_0$ such that \vs $$(\what{Q}_0)^la^{\what{r}_0} = \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ with a non-negligible probability.

\begin{comment} Although the proof is linear in size because of the $\lam$-bit integers $r_1,\cdots,r_n$, the number of $\mb{G}$-elements in this proof is constant. Since the group elements are much larger than $\lam$-bits, the communication complexity is substantially smaller that sending over $n$ separate arguments of knowledge. For instance, when $\lam = 128$, the group elements are of bit-size $3072$ with a RSA group, $6656$-bits with an imaginary quadratic class group and $3300$-bits with a Jacobian of a genus three hyperelliptic curve.\end{comment}

An important special case is where $f$ is the $(n+1)$-variate polynomial \vs $$f(X_1,\cdots,X_n, X_{n+1}) := \big(\pl_{i=1}^n X_i \big)- X_{n+1}.$$ We will need this case for one of the subsequent protocols. \vspace{0.2cm}


\begin{Prop} The protocol \verb|PoMultPolyDLog| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|MultPolyDLog|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) Since the equation $Q_0^l a^{r_0} = \pl_{i=1}^n b_i^{\gamma_0^i}$ holds, the adaptive root assumption implies that with \op, the Prover possesses rationals $d_1,\cdots,d_n$ such that: 

\noin - $a^{d_i} = b_i$ for $i=1,\cdots,n$ and 

\noin - $\sum\limits_{i=1}^n d_i\gamma_0^i\equiv \sum\limits_{i=1}^n r_i\gamma_0^i\Mod{l}.$ 

Since $\gamma_0$ is randomly generated after the Prover has committed $(r_1,\cdots,r_n)$, $\gamma_0$ is randomly and uniformly distributed modulo $l$. Hence, it follows that with \op,\\ $d_i\equiv r_i\Mod{l}$ for every index $i$. Now, \vs $$\Prob\left(f(d_1,\cdots,d_n)\equiv 0\Mod{l} \;\Big|\; f(d_1,\cdots,d_n)\neq 0 \right) = \negl(\lam) .$$ Thus, with \op, $f(d_1,\cdots,d_n) = 0$. Furthermore, the equation \vs $$\wti{g} = (\weck{g})^lg^{\wti{r}} $$ implies that $\wti{g} = g^{lk+\sum\limits_{i=1}^n d_i^{n\lam}\gamma^i}$ for some integer $k$. Since $l$ is randomly generated \textit{after} the Prover sends $\wti{g}$, the adaptive root assumption implies that with \op, $\wti{g} = g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$. The fractional root assumption implies that with \op, $\slim_{i=1}^n d_i^{n\lam}\gamma^i\in \bz$ and hence, with \op, $d_1,\cdots,d_n\in\bz$.\end{prf} 


\noindent We now discuss a relation that is a dual to the relation \verb|AggKE-1|. We provide an argument of knowledge for the following relation: 

\[
  \mc{R}_{{\protect\verb|AggKE-2|}}[\mc{A},\;A] = \left\{\begin{array}{l}
    (\mc{A} = (a_1,\cdots, a_n)\in \mb{G}^n,\; A\in\mb{G})\;\\ 
    (d_1,\cdots,d_n)\in\bz^n) :  \\
     A = a_i^{d_i}\;\forall\; i
  \end{array}\right\}
\]
\vspace{0.1cm}

\noin Given elements $a_1,\cdots,a_n$ such that \vs $$A = a_1^{d_1} =\cdots = a_n^{d_n} $$ where the integers $d_i$ are known to the Prover, the Prover can efficiently compute $d:= \LCM(d_1,\cdots,d_n)$ and  using Shamir's trick, an element $a\in\mb{G}$ such that $a^d = A$ in runtime $\mbf{O}(n\log(n))$. Now, the protocol \verb|PoAggKE-1|$[a,\;(a_1,\cdots,a_n)]$ and \verb|PoKE|$[a,\;A]$ would demonstrate that the Prover possesses the discrete logarithms between $a_i$ and $A$ for every $i$. However, these protocols do not prove that these discrete logarithms are, in fact, integers. To that end, a Prover needs to demonstrate that the rationals $d/d_i$ ($i=1,\cdots, n$) are integers. 

Unlike the protocol \verb|PoAggKE-1|, the proof for \verb|AggKE-2| is not constant-sized. Although the number of group elements is indeed constant, our proof contains $n$ $\lam$-bit integers arising from the remainders modulo the challenge.

\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated knowledge of exponents} 2 (\verb|PoAggKE-2|): \end{Prot}\vspace{-0.25cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$ 

\noindent \textbf{Inputs:} $(a_1,\cdots,a_n) \in \mb{G}^n$, $A\in\mb{G}$.

\noindent \textbf{Claim:} The Prover posseses integers $d_1,\cdots,d_n$ such that $a_i^{d_i} = A$.

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes the integers \vs $$D:= \LCM(d_1,\cdots,d_n)\;,\;\what{d}_i:= D/d_i\;(i=1,\cdots,n).$$ Using Shamir's trick, he computes an element $a\in\mb{G}$ such that $a^D = A$. He sends $a$ to the Verifier $\mc{V}$ along with a non-interactive \verb|PoKE|$[a,\;A]$.

\noin 2. The Fiat-Shamir heuristic generates a $\lam$-bit integer $\gamma$.

\noin 3. $\mc{P}$ computes $$\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$$ and sends it to the Verifier $\mc{V}$. 

\noin 4. $\mc{P}$ computes a non-interactive proof for \verb|AggKE-1|$[a,\;\{a_1,\cdots,a_n\}]$ and sends it to $\mc{V}$.

\noin 5. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 6. $\mc{P}$ computes $R:= D\Mod{l}$ and $\weck{a}:= a^{(D-R)/l}$. He sends $\weck{a}, R$ to $\mc{V}$.

\noin 7. $\mc{P}$ computes the integers $\what{r}_i:= \what{d}_i\Mod{l}$ ($i=1,\cdots,n$) and the integer $\what{q},\what{r}$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q} l + \what{r}\;,\;\what{r}\in [l].$$ He computes $\what{Q}:= a^{\what{q}}$ and sends $\what{Q}, (\what{r}_1,\cdots,\what{r}_n)$ to $\mc{V}$.

\noin 8. $\mc{P}$ computes the integers ${r}_i:= {d}_i\Mod{l}$ ($i=1,\cdots,n$) and the integers $q,r,\wti{q},\wti{r}$ such that \vs $$\slim_{i=1}^n d_i\gamma^i = ql+r\;,\;\slim_{i=1}^n {d}_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\;\;r,\wti{r}\in[l] $$ He computes ${Q}:= a^q$, $\weck{g}:= g^{\wti{q}}$ and sends ${Q}, \weck{g}$ to $\mc{V}$.

\noin 9. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 10. $\mc{P}$ computes the integers $\what{q}_0,\what{r}_0$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q}_0l+\what{r}_0\;,\;\what{r}_0\in[l].$$ He computes $\what{Q}_0:= a^{q_0}$ and sends ${Q}_0$ to $\mc{V}$.

\noin 11. $\mc{V}$ verifies that $(\what{r}_1,\cdots,\what{r}_n, R)\in [l]^{n+1}$ and independently computes $r_i\equiv \what{r}_i^{-1}R\Mod{l}$ ($i=1,\cdots,n$) and \vs $$\what{r}:= \slim_{i=1}^n \what{r}_i\gamma^i\Mod{l}\;,\;\wti{r}:= {\slim_{i=1}^n r_i^{n\lam}\gamma^i}\Mod{l}\;,\; \what{r}_0:= \slim_{i=1}^n \what{r}_i\gamma_0^i\Mod{l}$$

\noin 12. $\mc{V}$ verifies the equations \vs $$(\weck{a})^la^R\sta A  \;\bigwedge\; (\what{Q})^l a^{\what{r}}\sta \pl_{i=1}^{n} a_i^{\gamma^i}\;\bigwedge\;(\what{Q}_0)^la^{\what{r}_0}\sta \pl_{i=1}^{n} a_i^{\gamma_0^i} \;\bigwedge\; (\weck{g})^lg^{\wti{r}} \sta \wti{g}.$$ He accepts the validity of the claim if and only if all equations hold and the proofs for \verb|PoKE|$[a,\;A]$, \verb|AggKE-1|$[a,\;\{a_1,\cdots,a_n\}]$ are valid.\end{prf1}

\vspace{0.2cm}

We note that the additional challenge $\gamma_0$ is necessary for the security of this protocol. Note that the Prover commits the integer $\slim_{i=1}^n d_i^{n\lam}\gamma^i$ by computing $\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$ and sending it to the Verifier \textit{before} the challenge $l$ is generated by the Fiat-Shamir heuristic. However, a malicious Prover $\mP_{\mr{mal}}$ could forge a fake proof as follows:

\noin 1. $\mP_{\mr{mal}}$ chooses integers $e_1,\cdots,e_n$ and sends $g^{\slim_{i=1}^n e_i\gamma^i}$ to the Verifier instead of $g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$

\noin 2. $\mP_{\mr{mal}}$ chooses integers $r_1,\cdots,r_n\in [l]$ such that \vs $$\slim_{i=1}^n (Dd_i^{-1})\gamma^i \equiv \slim_{i=1}^n (Dr_i^{-1})\gamma^i \Mod{l}\;,\; \slim_{i=1}^n e_i\gamma^i\equiv \slim_{i=1}^n r_i\gamma^i \Mod{l},$$ but $d_i\not\equiv r_i\Mod{l}$ for some or all indices $i$. The Prover $\mP_{\mr{mal}}$ can do so  with non-negligible probability.

\noin 3. Thus, the Verifier is tricked into believing that $\slim_{i=1}^n d_i^{n\lam}\gamma^i$ is an integer, which  might not necessarily be the case. In fact, even if the Fiat-Shamir heuristic outputs the additional challenge $\gamma_0$ before the remainders $(r_1,\cdots,r_n, R)$ are committed, $\mP_{\mr{mal}}$ can forge a fake proof with non-negligible probability. 

Now, in our protocol, $\gamma_0$ is randomly generated by the Fiat-Shamir heuristic \textit{after} the Prover sends $(\what{r}_1,\cdots,\what{r}_n, R)$. Hence, we have \vs $$\Prob\Big(\slim_{i=1}^n d_i\gamma_0^i \equiv \slim_{i=1}^n r_i\gamma_0^i \Mod{l}\;\Big|\; d_i\not\equiv r_i\Mod{l}\;\text{for some } i\Big) = \negl(\lam). $$ Hence, the elements $(r_1,\cdots,r_n)$ must be honestly computed in order to succeed at the additional challenge of computing the element $\what{Q}_0$ such that \vs $$\what{Q}_0^la^{\what{r}_0}= \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ with non-negligible probability.

\noin 


\vspace{0.2cm}

\begin{Prop} The protocol \verb|PoAggKE-2| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggKE-2|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The subprotocol \verb|PoAggKE-1|$[a,\;\{a_1,\cdots,a_n\}]$ demonstrates that with \op, the Prover possesses integers $\what{d}_1,\cdots,\what{d}_n$ such that \vs $$a_i = a^{\what{d}_i}\; (i=1.\cdots,n)$$ Furthermore, since $\gamma_0$ is randomly generated and the equation \vs $$\what{Q}_0^la^{\what{r}_0} = \pl_{i=1}^{n} a_i^{\gamma_0^i} $$ holds, the adaptive root assumption implies that with \op, \vs $$\slim_{i=1}^n\what{r}_i\gamma_0^i\equiv \slim_{i=1}^n \what{d}_i\gamma_0^i\Mod{l}.$$ Hence, with \op, $\what{r}_i\equiv \what{d}_i\Mod{l}$ (Schwartz-Zippel).

The equation $(\weck{a})^la^R= A $ implies that with \op, the Prover possesses a rational $D\equiv R\Mod{l}$ such that $a^D = A$. Thus, with \op, the rationals $D\what{d_1}^{-1},\cdots,D\what{d_n}^{-1}$ satisfy \vs $$a_i^{D\what{d_i}^{-1}} = A \text{ for every }i.$$ Now, the Verifier independently computes \vs $$r_i:= R\what{r}_{i}^{-1}\equiv D\what{d}_i^{-1}\Mod{l}\;(i=1,\cdots,n),\;\;r:= \slim_{i=1}^n r_i\gamma^i\equiv \slim_{i=1}^n D\what{d}_i^{-1}\Mod{l},$$\vspace{-0.3cm} $$\wti{r}:= {\slim_{i=1}^n r_i^{n\lam}\gamma^i}\equiv {\slim_{i=1}^n (D\what{d}_i^{-1})^{n\lam}\gamma^i}\Mod{l}.$$ Hence, the equation $(\weck{g})^lg^{\wti{r}} = \wti{g}$ implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i}g^{kl} $$ for some integer $k$. Since the prime $l$ is randomly generated, the Schwartz-Zippel lemma implies that with \op, \vs $$\wti{g} = g^{\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i}. $$ The fractional root assumption implies that $\slim_{i=1}^n (D\what{d_i}^{-1})^{^{n\lam}}\gamma^i$ is a an integer and by lemma 1.3, it follows that with \op, the rationals $D\what{d_i}^{-1}$ are integers.\end{prf}

In what follows, we provide an argument of knowledge for the relation 

\[
  \mc{R}_{{\protect\verb|EqDLogPairs|}}[(a_1, \mc{B}),\; (a_2, \mc{C})] = \left\{\begin{array}{l}
  	((a_1, a_2)\in\mb{G}^2\\
    \mc{B} = (b_1,\cdots, b_n)\;,\;\mc{C} = (c_1,\cdots, c_n)\;\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\mb{Z}^n): \\
    b_i = a_1^{d_i}\;,\;c_i = a_2^{d_i} \;\forall\;i
  \end{array}\right\}
\]

\vspace{0.2cm}


\begin{Prot} \normalfont \textit{Proof of equalities of pairs of discrete logarithm} (\verb|PoEqDLogPairs|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs :} $a_1,a_2\in\mb{G}$  \;,\;$(b_1,\cdots, b_n), \;\;(c_1,\cdots, c_n)\;\in\; \mb{G}^n$.

%\noindent \textbf{Inputs:} $\mc{P}$ possesses

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that $a_1^{d_i} = b_i,\; a_2^{d_i} = c_i$.

\begin{prf1} \normalfont 1. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma$.

\noin 2. The Prover $\mP$ computes $\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends it to the Verifier $\V$.
 
\noin 3. $\mc{P}$ computes the elements \vs $$B:= \prod\limits_{i=1}^n b_i^{\gamma^i},\;\;C:= \prod\limits_{i=1}^n c_i^{\gamma^i}\;\in\; \mb{G}.$$

\noin 4. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 5. $\mP$ computes $r_i:= d_i\Mod{l}$ and the integers $q,\wti{q}, r,\wti{r}$ such that \vs $$\slim_{i=1}^n d_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\;\slim_{i=1}^n d_i\gamma^i = ql+r,\;\;\;r,\wti{r}\in[l]$$

\noin 6. $\mP$ computes $\weck{g}:= g^{\wti{q}}$, $Q:= a_1^q$ and sends $\weck{g}$, $Q$, $(r_1,\cdots,r_n)$ to $\V$.   
 
\noindent 7. $\mc{P}$ computes a non-interactive proof for \verb|EqDLog|$[(a_1, B),\; (a_2, C)]$ and sends it to $\mc{V}$.

\noin 8. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 9. $\mP$ computes integers $q_0,r_0$ such that \vs $$\slim_{i=1}^n d_i\gamma_0^i = q_0l+r_0,\;\;\;r_0\in[l] .$$ He computes $Q_0:= a_1^{q_0}$ and sends $Q_0$ to $\V$.

\noindent 10. $\V$ verifies that $(r_1,\cdots,r_n)\in [l]^n$ and independently computes \vs $$\wti{r}:= \slim_{i=1}^n r_i^{n\lam}\gamma^i \Mod{l}\;,\;r:= \slim_{i=1}^n r_i\gamma^i \Mod{l}\;,\;r_0:= \slim_{i=1}^n r_i\gamma_0^i \Mod{l} .$$

\noin 11. $\V$ independently computes the elements \vs $$B:= \prod\limits_{i=1}^n b_i^{\gamma^i},\;\;B_0:= \prod\limits_{i=1}^n b_i^{\gamma_0^i},\;\;   C:= \prod\limits_{i=1}^n c_i^{\gamma^i}\;\in\; \mb{G}.$$

\noin 12. $\V$ verifies the equations \vs $$Q^la_1^{r}\sta B\;\bigwedge\;(Q_0)^la_1^{r_0}\sta B_0\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta \wti{g} .$$ He then accepts the validity of the claim if and only if the proof for \verb|EqDLog|$[(a_1, B),\; (a_2, C)]$ is valid and all equations hold.\end{prf1}


\section{\fontsize{12}{12}\selectfont Protocols for arguments of disjointness}

The goal of this section is to provide protocols for demonstrating disjointness of multiple data multisets. The proofs can be publicly verified against the succinct commitments to these multisets. To that end, we first describe a protocol whereby an honest Prover can show that the GCD of two discrete logarithms equals a third discrete logarithm without revealing any further information about them. One obvious application is proving disjointness of sets in accumulators instantiated with the group $\mb{G}$. We formulate an argument of knowledge for the relation \vspace{-0.15cm} $$\mc{R}_{{\protect\verb|GCD|}}[(a_1,b_1),(a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} .$$ We construct a protocol that has communication complexity independent of the elements $a_i, b_i$. The protocol rests on the observation that \vs $$d_3 = \GCD(d_1, d_2)\;\; \LRA \;\;(d_1\equiv d_2\equiv 0 \Mod{d_3})\;\wedge \; \left(\exists \; (x_1,x_2)\in \bz^2:\; d_3 = x_1d_1+x_2d_2  \right).$$
 

\begin{Prot} \normalfont \textit{Proof of the greatest common divisor} (\verb|PoGCD|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2, a_3, b_1, b_2, b_3 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$, $d_3$ such that:

\noindent - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$, $a_3^{d_3} = b_3$\\
\noindent - $\GCD(d_1, d_2) = d_2$
 

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}$, $b_{1,3}:= a_1^{d_3}$ and sends them to the Verifier $\V$.

\noindent 2. He computes non-interactive proofs for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|EqDLog|$[(a_3, b_3),\; (a_1, b_{1,3})]$ and sends them to $\mc{V}$.

\noindent 3. $\mc{P}$ computes non-interactive proofs for \verb|PoKE|$[b_{1,3},\;b_1 ]$ and \verb|PoKE|$[b_{1,3},\;b_{1,2} ]$ and sends them to $\V$.

\noindent 4. $\mc{P}$ uses the algorithm \verb|Bezout|  to compute integers $e_1, e_2$ such that $e_1d_1 + e_2d_2 = d_3$.

\noindent 5. $\mc{P}$ computes \vs $$\wti{b}_1:= b_1^{e_1},\;\; \wti{b}_{1,2}:= b_{1,2}^{e_2} $$ and sends them to $\V$. He computes non-interactive proofs for \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$. He sends these proofs to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies all of the proofs he receives in addition to the equation $\wti{b}_1\wti{b}_{1,2}\stackrel{?}{=} b_{1,3}$. He accepts the validity of the claim if and only if all of these proofs are valid.\end{prf1}

\noindent An important special case is where $\GCD(d_1, d_2) = 1$. In this case, Step 3 is redundant and hence, the proof size is smaller. We call this special case the Protocol for \textit{Relatively Prime Discrete Logarithms} or \verb|RelPrimeDLog| for short: $$\mc{R}_{{\protect\verb|RelPrimeDLog|}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} .$$ 

\vspace{0.1cm}

\begin{Prot} \normalfont \textit{Proof of Relatively Prime Discrete Logarithms} (\verb|PoRelPrimeDLog|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2, b_1, b_2 \in \mb{G}$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1$, $d_2$ such that:

\noindent - $a_1^{d_1} = b_1$, $a_2^{d_2} = b_2$\\
\noindent - $\GCD(d_1, d_2) = 1$
 

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes $b_{1,2}:= a_1^{d_2}$ and sends it to the Verifier $\V$. 

\noindent 2. $\mP$ computes a non-interactive proof for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$ and sends it to $\mc{V}$.

\noindent 3. $\mc{P}$ uses the algorithm \verb|Bezout|  to compute integers $e_1, e_2$ such that $e_1d_1 + e_2d_2 = 1$.

\noin 4. $\mc{P}$ computes \vs $$\wti{b}_1:= b_1^{e_1}\;\;,\;\; \wti{b}_{1,2}:= b_{1,2}^{e_2} $$ and sends them to $\V$. 

\noin 5. $\mP$ computes non-interactive proofs for \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$ and sends them to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies the equation $\wti{b}_1\wti{b}_{1,2}\stackrel{?}{=} a_1$ and the proofs for \verb|EqDLog|$[(a_2, b_2),\; (a_1, b_{1,2})]$, \verb|PoKE|$[b_1,\; \wti{b}_1]$ and \verb|PoKE|$[b_{1,2},\; \wti{b}_{1,2}]$. He accepts the validity of the claim if and only if all of these proofs are valid.\end{prf1}

\vspace{0.2cm}

\begin{Prop} The Protocols \verb|PoGCD|, \verb|PoRelPrimeDLog| are arguments of knowledge for the relations $\mc{R}_{{\protect\verb|GCD|}}$, $\mc{R}_{{\protect\verb|RelPrimeDLog|}}$ respectively in the generic group model.\end{Prop}

\begin{prf} Since the relation \verb|RelPrimeDLog| is a special case of the relation \verb|GCD|, it suffices to show that the protocol \verb|PoGCD| is correct and sound. Furthermore, since we showed that \verb|PoEqDLog| is correct and sound, we may assume without loss of generality that - with notations as in the protocol \verb|PoGCD| - \vs $$a_1 = a_2 = a_3\;,\; {b}_{1,2} = b_2\;,\;{b}_{1,3} = b_3 .$$ Now, the protocols \verb|PoKE|$[b_3, b_1]$, \verb|PoKE|$[b_3, b_2]$, \verb|PoKE|$[a_1, b_3]$ imply that with \op, the Prover $\mP$ possesses integers $d_1,d_2,d_3$ such that \vs $$a_1^{d_1} = b_1\;,\;a_1^{d_2} = b_2\;,\;a_1^{d_3} = b_3\;,\;\GCD(d_1,d_2)\equiv 0\Mod{d_3}.$$ 

Furthermore, the Prover $\mP$ sends elements $\wti{b}_1, \wti{b}_2\in \mb{G}$ such that $\wti{b}_1\wti{b}_2 = b_3$ along with the non-interactive proofs for \verb|PoKE|$[b_1,\wti{b}_1]$, \verb|PoKE|$[b_2,\wti{b}_2]$. Hence, with \op, the Prover possesses integers $e_1,e_2$ such that $e_1d_1+e_2d_2 = d_3$. Hence, it follows that with \op, $d_3 = \GCD(d_1,d_2).$ 
\end{prf}


It is easy to see that the \verb|PoGCD| may be combined with the protcol \verb|PoMultPolyDLog| to provide an argument of knowledge for the relation \vs $$\mc{R}_{{\protect\verb|LCM|}}[(a_1,b_1),(a_2,b_2), \; (a_3, b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\LCM(d_1,d_2)=d_3 \} .$$ This argument of knowledge can demonstrate that for data multisets $\mc{D}_1,\mc{D}_2, \mc{D}_3$, we have \vs $$\mc{D}_3 = \mc{D}_1\cup \mc{D}_2 $$ by setting \vs $$ d_i = \prod\limits_{d\in\mc{D}_i} x\;\;(i=1,2,3).$$\vspace{0.2cm}


\noin \textbf{Multiplicities in multiset commitments:} As before, let $g$ be a randomly generated element in a hidden order group $\mb{G}$. Let $\mc{M}, \mc{N}$ be multiset and let \vs $$\protect{\verb|Com|}(M):= g^{\pl_{x\in \mc{M}} x^{\mr{mult(x,M)}}}\;,\;\protect{\verb|Com|}(N):= g^{\pl_{x\in \mc{N}} x^{\mr{mult(x,N)}}}$$ be the commitments to $\mc{M}$, $\mc{N}$ respectively.

For a set $\mc{D}$, a Prover can use the protocol \verb|PoGCD| to demonstrate that every element of $\mc{D}$ occurs with a higher multiplicity in $\mc{M}$ than in $\mc{N}$. This proof is public verifiable against the commitments to $\mc{M}$, $\mc{N}$ and $\mc{D}$. \vspace{0.15cm}

\noin 1. The Prover $\mP$ computes \vs $$\protect{\verb|Com|}(\mc{D}):= g^{\pl_{x\in \mc{D}} x}$$ and sends it to the Verifier $\V$ along with a \verb|PoE| for this exponentiation.

\noin 2. $\mP$ computes the multiplicities $m_x$, $n_x$ of every element $x\in\mc{D}$ in $\mc{M}$ and $\mc{N}$ respectively.

\noin 3. $\mP$ computes \vs $$a_1:= g^{{\pl_{x\in \mc{D}} x^{n_x}}}\;,\; a_2 := g^{{\pl_{x\in \mc{D}} x^{n_x+1}}} $$ and sends them to $\V$ along with a non-interactive proof for \verb|EqDLog|$[(g, \protect{\verb|Com|}(\mc{D})),\;(a_1,a_2)]$.

\noin 4. $\mP$ computes a non-interactive proof for \verb|PoGCD|$[(g, a_2),\;(g, \protect{\verb|Com|}(\mc{N})),\;(g,a_1)]$ and sends it to $\V$. 

\noin 5. $\mP$ computes a non-interactive proof for \verb|PoKE|$[a_2, \protect{\verb|Com|}(\mc{M})]$ and sends it to $\V$.

\noin 6. $\V$ verifies the three proofs and accepts if and only if they are all valid.
 





\subsection{\fontsize{11}{11}\selectfont Protocols for aggregated arguments of disjointness}

We now use the protocols \verb|AggKE-1| and \verb|AggKE-2| to generalize the protocol \verb|RelPrimeDLog| to multiple discrete logarithms. Consider a setting where we have $n$ accumulators $\Acc_1,\cdots,\Acc_n$ instantiated in the same group $\mb{G}$ and with the common genesis state $g\in\mb{G}$. Let $\mc{D}_i$ denote the data inserted into $\Acc_i$ and let $A_i$ denote the accumulated digest of $\Acc_i$. Thus, \vs $$A_i = g^{\Pi(\mc{D}_i)} .$$ 

Suppose a Prover needs to demonstrate to a Verifier (with access to the accumulated digests) that the data sets $\mc{D}_i$ are pairwise disjoint, while keeping the communication complexity to a bare minimum. In particular, the Verifier should not need to access the data sets $\mc{D}_i$. A straightforward way would be to provide the $n\choose 2$ proofs of pairwise disjointness. But this would entail $\mbf{O}(n^2)$ group elements and $\mbf{O}(n^2)$ $\lam$-bit integers. Instead, we provide a protocol whereby the Prover can demonstrate the pairwise disjointness with a constant number of $\mb{G}$-elements and $2n$ $\lam$-bit integers.

We call the next protocol the \textit{Aggregated Knowledge of Relatively Prime Exponents-1} or\\ \verb|AggRelPrimeDLog-1| for short. We provide an argument of knowledge for the following relation:

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-1|}}[a,\; \mc{A}] = \left\{\begin{array}{l}
    (a\in\mb{G},\;  \mc{A}:=(a_1,\cdots, a_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\bz^n): \\
    a_i = a^{d_i}\;\forall\;i\;\;,\;\; \GCD(d_i, d_j) = 1)\;\forall \;i\neq j   	
  \end{array}\right\}
\] 

\noin The protocol rests on the following elementary lemma.

\begin{Lem}\label{lcm} Let $d_1,\cdots,d_n$ be non-zero integers. Set \vs $$D:= \pl_{i=1}^n d_i\;,\; \what{d}_i:= \frac{D}{d_i}\;(i=1,\cdots,n) \;,\;\what{D}:= \slim_{i=1}^n \what{d}_i.$$ Then \vs $$\GCD(d_i,d_j)=1\;\forall\;i\neq j\; \LRA \GCD(D, \what{D}) = 1 .$$\end{Lem}

\begin{prf} First, suppose there exists a pair $i,j$ such that $\GCD(d_i,d_j)> 1$. Then $\GCD(d_i,d_j)$ divides $\what{d}_k$ for every index $k$ and in particular, $\GCD(d_i,d_j)$ divides $\what{d}$. Hence, $\GCD(D,\what{D})$ is divisible by $\GCD(d_i,d_j)$.

Conversely, suppose $\GCD(d_i,d_j)=1\;\forall\;i\neq j$. Then for every index $i$, $\what{D}\equiv \what{d}_i\Mod{d_i} $ and hence, $\GCD(\what{D}, d_i) = \GCD(\what{d}_i, d_i) = 1$. Thus, $\GCD(D,\what{D})$ = 1.\end{prf}

\noin Recall that given integers $d_1,\cdots,d_n$ and elements $a,A\in\mb{G}$ such that \vs $$a^D = a^{\pl_{i=1}^n d_i} = A ,$$ the \textbf{RootFactor} algorithm allows us to compute elements $a_i$ such that $a_i^{d_i} = A$ in runtime $\mbf{O}(n\log(n))$. Thus, a Prover can compute the element $\what{A}:= \pl_{i=1}^n a_i$ in runtime $\mbf{O}(\log(D)\log(\log(D)))$ with the \textbf{RootFactor} algorithm followed by $n$ group multiplications.

\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 1 \\(\verb|PoAggRelPrimeDLog-1|) :\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Element $a\in\mb{G}$, $(a_1,\cdots,a_n)\in \mb{G}^n$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_n$ such that:

\noindent - $a^{d_i} = a_i$ for $i = 1,\cdots, n$.

\noindent - $\GCD(d_i, d_j) = 1$ for every pair $i\neq j$.


\begin{prf1}\normalfont 1. The Prover $\mP$ computes the integers \vs $$D:=\pl_{i=1}^n d_i\;\;,\;\; \what{D}:= \slim_{i=1}^n \frac{D}{d_i}.$$

\noin 2. $\mP$ computes $A:= a^D,\;\what{A}:= a^{\what{D}} $ (the latter using the \textbf{RootFactor} algorithm) and sends $A,\what{A}$ to the Verifier $\V$.

\noin 3. $\mP$ computes a non-interactive proof for \verb|AggKE-1|$[a,\;(a_1,\cdots,a_n)]$ and sends it to $\V$.

\noin 4. $\mP$ computes a non-interactive proof for \verb|MultPolyDLog|$[a,\;(a_1,\cdots,a_n,A),\; f]$ where \vs $$f(X_1,\cdots,X_{n+1}):= \big(\pl_{i=1}^n X_i\big) -X_{n+1}$$ and sends the proof to $V$.

\noin 5. $\mP$ computes a non-interactive proof for \verb|MultPolyDLog|$[a,\;(a_1,\cdots,a_n,\what{A}),\; \what{f}]$ where \vs $$\what{f}(X_1,\cdots, X_{n+1}):= \big(\slim_{i=1}^n \pl_{\substack{1\leq j\leq n \\ j\neq i}} X_j\big) - X_{n+1}$$ and sends the proof to $\V$.

\noin 6. $\mP$ computes a non-interactive proof for \verb|RelPrimeDLog|$[(a,A),\;(a,\what{A})]$ and sends it to $\V$.

\noin 7. $\V$ verifies the four proofs and accepts the validity of the claim if and only if all proofs are valid.\end{prf1}

\noin Thus, the proof consists of a constant number of $\mb{G}$-elements and $2n$ $\lam$-bit integers.

\begin{Prop} The protocol \verb|PoAggRelPrimeDLog-1| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggRelPrimeDLog-1|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The two \verb|MultPolyDLog| proofs imply that with \op, $\mP$ possesses integers $D$, $\what{D}$, $d_1,\cdots,d_n$ such that \vs $$D = \pl_{i=1}^n d_i\;,\;\what{D} = \slim_{i=1}^n \frac{D}{d_i}   \;,\;a^{d_i} = a_i\;\forall\;i \;,\;a^{D} = A\;,\; a^{\what{D}} = \what{A} .$$ Furthermore, the proof for \verb|RelPrimeDLog|$[(a,A),\;(a,\what{A})]$ implies that $\GCD(D,\slim_{i=1}^n D/d_i) = 1$. Hence, by the preceding lemma, the integers $d_i$ are pairwise co-prime.\end{prf}



\bigskip

\noin Given elements $a_1, a_2\in \mb{G}$ and equations \vspace{-0.15cm}$$a_1^{d_1} = b_1,\cdots, a_1^{d_m}= b_m,\;\; a_2^{e_1} = c_1,\cdots, a_2^{e_n} = c_n,$$ a Prover may provide a proof that he possesses the integers \vspace{-0.15cm}$$d_1,\cdots, d_m,\;e_1,\cdots, e_n$$ and that every pair $d_i, e_j$ is relatively prime. Clearly, the latter part is equivalent to showing that the integers \vspace{-0.15cm}$$d:=\LCM(d_1,\cdots, d_m)\;,\;e:=\LCM(e_1,\cdots, e_n)$$ are relatively prime. Our approach is to compute elements $B = a_1^d,\;C:= a_2^{e}$. We then use the procols \verb|AggPoKE-1| and \verb|AggPoKE-2| to provide arguments of knowledge that $d, e$ are divisible by $\{d_1,\cdots, d_n \}$, $\{e_,\cdots,e_n \}$ repectively. We then  use the procol \verb|RelPrimeDLog| to show that $\GCD(d, e) = 1$.


We call the next protocol the \textit{Aggregated Knowledge of Relatively Prime Exponents 2} or\\ \verb|AggRelPrimeDLog-2| for short. We provide an argument of knowledge for the following relation:\vspace{-0.2cm}

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-2|}}[a_1, a_2, \mc{B}, \mc{C}] = \left\{\begin{array}{l}
    ((a_1,a_2)\in\mb{G}^2,\;\\
     \mc{B}:=(b_1,\cdots, b_m)\in\mb{G}^m,\;\mc{C}:= (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n)\;: \\
    (b_i = a_1^{d_i}\;\;\bigwedge\;\; c_j = a_2^{e_j}\;\bigwedge\; \GCD(d_i, e_j) = 1)\;\forall \;i,j   	
  \end{array}\right\}
\] 

\vspace{0.2cm}

\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms 2}\\ (\verb|PoAggRelPrimeDLog-2|) :\end{Prot}\vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $a_1, a_2\in \mb{G}$, Elements $\mc{B} = (b_1,\cdots, b_m)$, $\mc{C} = (c_1,\cdots, c_n)$ of $\mb{G}^n$.

\noindent \textbf{Claim:} The Prover possesses integers $d_1,\cdots, d_m$,\; $e_1,\cdots,e_n$ such that:

\noindent - $a_1^{d_i} = b_i$ for $i = 1,\cdots, m$.

\noindent - $a_2^{e_j} = c_j$ for $j = 1,\cdots, n$.

\noindent - $\GCD(d_i, e_j) = 1$ for every pair $i, j$.


\begin{prf1}\normalfont 1. The Prover $\mc{P}$ computes \vs $${d}:= \pl_{i=1}^m d_m\;\;,\;\; {e}:= \pl_{j=1}^n e_n.$$

\noindent 2. $\mc{P}$ computes $B:= a_1^{d},\;\;C:= a_2^{e}\;\in\mb{G}$ and sends $B, C$ to the Verifier $\mc{V}$.

\noindent 3. $\mc{P}$ computes non-interactive proofs for \verb|MultPolyDLog|$[a_1,\;(b_1,\cdots,b_m, B),\; (\pl_{i=1}^m X_i) -X_{m+1}]$, \verb|MultPolyDLog|$[a_2,\;(c_1,\cdots,c_n, C),\; (\pl_{j=1}^n X_j) -X_{n+1}]$ and sends them to $\mc{V}$.

\noindent 4. $\mc{P}$ computes non-interactive proofs for 
\verb|AggKE-1|$[a_1,\mc{B}]$ and \verb|AggKE-1|$[a_2,\mc{C}]$ and sends them to the Verifer.

\noindent 5. $\mc{P}$ computes a non-interactive proof for 
\verb|RelPrimeDLog|$[(a_1, B),\;(a_2, C)]$ and sends it to $\mc{V}$. 

\noindent 6. $\mc{V}$ accepts the validity of the claim if and only if all of these proofs are valid.\end{prf1}

\vspace{0.2cm}

\noindent \textbf{Remark:} The proof consists of the element $B, C \in \mb{G}$, two \verb|AggKE-1| proofs, two \verb|MultPolyDLog| proofs and one \verb|RelPrimeDLog| proof. Each of these proofs consists of a constant number of $\mb{G}$-elements and hence, the same is true regarding our proof for the Protocol\\ \verb|AggRelPrimeDLog-2|$[(a_1, \mc{B}), \; (a_2, \mc{C})]$. However, the \verb|AggKE-1| and \verb|PoMultPolyDLog| proofs result in $2(m+n)$ $\lamb$-bit integers in the proof. Hence, the size of the proof is $\mbf{O}(m+n)$. \vspace{0.2cm}


\begin{Prop} The Protocol \verb|AggRelPrimeDLog-2| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggRelPrimeDLog-2|}}$ in the generic group
model.\end{Prop}

\begin{prf} (Sketch) Since each of the subprotocols was shown to be correct and sound in the preceding seciton, this follows immediately.\end{prf}

\noindent \textbf{An example:} We discuss an example of an application of this last protocol. Consider two families \vspace{-0.1cm}$$\mc{A}_1 = \{\Acc_{1,1},\cdots,\Acc_{1, m}\}, \;\; \mc{A}_2 = \{\Acc_{2,1},\cdots,\Acc_{2, n}\} $$ of accumulators instantiated using the same group $\mb{G}$ of hidden order. As usual, each data element is represented by a $\lam$-bit prime. Let $g_1$, $g_2$ be the genesis states for all accumulators in $\mc{A}_1$ and $\mc{A}_2$, respectively. 

As usual, each data element is represented by a distinct $\lamb$-bit prime. Let $\mc{D}_{1, i}$ ($\mc{D}_{2, j}$) denote the data set inserted into the accumulator $\Acc_{1, i}$ (respectively, $\Acc_{2, j}$) and write $$\mc{D}_1 := \bigcup\limits_{i=1}^m  \mc{D}_{1,i}\;\; ,\;\;\mc{D}_2 = \bigcup\limits_{j=1}^n  \mc{D}_{2,j}.$$ Suppose a Verifier (with access to the accumulated digests) wants to verify that the unions are disjoint, i.e. $\mc{D}_1 \cap \mc{D}_2 = \emptyset.$ An honest Prover could simply provide a non-interactive proof for the protocol \verb|AggRelPrimeDLog-2|$[(g_1, \mc{D}_1) ,\;(g_2, \mc{D}_2)]$. In particular, the proof can be verified without access to the data sets $\mc{D}_{1}, \mc{D}_{2}$. \\


Consider a setting where we have data multisets $\mc{D}_1,\cdots, \mc{D}_n$ in an accumulator. Let $A$ denote the accumulated digest, $w_i$ the witness for $\mc{D}_i$ and $d_i$ the product of all elements of $\mc{D}_i$. 

Suppose a Prover needs to demonstrate that the multisets $\mc{D}_i$ are pairwise disjoint to a Verifier who has access to the witnesses $w_1,\cdots,w_n$ but not the data sets. A straightforward approach would be to provide a proof for \verb|RelPrimeDLog|$[(w_i, A),\;(w_j, A)]$. But such a proof would contain $\mbf{O}(n^2)$ $\mb{G}$-elements and $\mbf{O}(n^2)$ $\lam$-bit integers. 

Instead, we provide a protocol whereby the proof consists of a constant number of $\mb{G}$-elements and $n$ $\lam$-bit integers. The protocol rests on two simple observations. First, note that for integers $d_1,\cdots,d_n$, \vs $$\GCD(d_i,d_j)=1\;\forall\;i\neq j\; \LRA \pl_{i=1}^n d_i= \LCM(d_1,\cdots,d_n),$$ as can be easily proved by induction. Secondly, if an element $w\in \mb{G}$ can be expressed in the form \vspace{-0.15cm}$$w = \prod\limits_{i=1}^n w_i^{x_i},\;\;(x_1,\cdots,x_n)\in\bz^n,$$ then \vs $$w^{\LCM(d_1,\cdots,d_n)} = A^{k} $$ for some integer $k$. More precisely, \vs $$k = \slim_{i=1}^n x_i\frac{\LCM(d_1,\cdots,d_n)}{d_i}.$$ Furthermore, the Prover can efficiently compute the integers \vs $$d:= \pl_{i=1}^n d_i = \LCM(d_1,\cdots,d_n)\;,\;\what{d}_i:= \pl_{\substack{1\leq j\leq n\\ j\neq i}} d_j\;\; (i=1,\cdots,n)\;\;,\;\; \what{d} := \slim_{i=1}^n \what{d}_i.$$ Now, $d$ is relatively prime to $\what{d}$. Hence, the Prover can efficiently compute integers $e,\what{e}$ such that $$de+\what{d}\what{e} = 1\;,\; A^e(\pl_{i=1}^n w_i)^{\what{e}} = w.  $$ In particular, since $\pl_{i=1}^n w_i$ is publicly computable, the Prover can demonstrate, with constant communication complexity, that $w$ is expressible as a product $\pl_{i=1}^n w_i^{x_i}$ where the $x_i$ are integers known to him. If the Prover can also demonstrate that $$w^{\prod\limits_{i=1}^n d_i} = A,$$ (with a subprotocol virtually identical to \verb|MultPolyDLog|), then this implies that \vspace{-0.15cm}$$\LCM(d_1,\cdots,d_n)\equiv 0\Mod{ \prod\limits_{i=1}^n d_i},$$ which forces equality. In what follows, we provide an argument of knowledge for the relation 

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-3|}}[(w_1,\cdots, w_n), A] = \left\{\begin{array}{l}
    (A\in\mb{G},\; (w_1,\cdots, w_n)\;\in\mb{G}^n);\\
    ((d_1,\cdots,d_n)\in\bz^n)\;: \\
    w_i^{d_i} = A\;\forall\;i\\
   	\GCD(d_i, d_j) = 1\;\forall \;i,j: i\neq j
  \end{array}\right\}
\] 

\vspace{0.2cm}



\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 3\\ (\verb|PoAggRelPrimeDLog-3|):\end{Prot} \vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $(w_1,\cdots, w_n)\in \mb{G}^n$, $A\in\mb{G}$

\noindent \textbf{Claim:} The Prover possesses integers $ d_1,\cdots, d_n$ such that:

\noindent - $w_i^{d_i} = A$ for $i = 1,\cdots,n$.

\noindent - $\GCD(d_i, d_j) = 1$ for every pair $i\neq j$.

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes the integers \vs $$D := \prod\limits_{i=1}^n d_i\;\;,\;\;\what{d}_i = \pl_{\substack{1\leq j\leq n\\ j\neq i}} d_j\;(i=1,\cdots,n)\;\;,\;\; \what{D}:=\slim_{i=1}^n\what{d}_i.$$ 

\noin 2. Using Shamir's trick, $\mc{P}$ computes an element $w\in\mb{G}$ such that $w^D = A$ and sends $w$ to the Verifier $\mc{V}$.

\noin 3. $\mP$ uses the algorithm \verb|Bezout| to compute integers $e,\what{e}$ such that $eD+\what{e}\what{D} = \GCD(D,\what{D}) = 1.$

\noin 4. $\mP$ computes $$A_0:= A^{e}\;,\;W := \big(\pl_{i=1}^n w_i\big)^{\what{e}}.$$ He sends $A_0,W$ to $\V$ along with non-interactive proofs for \verb|PoKE|$[A,\; A_0]$ and \verb|PoKE|$[(\pl_{i=1}^n w_i),\; W]$.

\noin 5. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma$.

\noin 6. $\mc{P}$ computes $\wti{g}:= g^{\slim_{i=1}^n d_i^{n\lam}\gamma^i}$ and sends $\wti{g}$ to $\mc{V}$.

\noin 7. The Fiat-Shamir heuristic generates a $\lam$-bit prime $l$.

\noin 8. $\mc{P}$ computes \vs $$R:= D\Mod{l}\;,\; \weck{w}:= w^{(D-R)/l}$$ and sends $\what{w}$ to $\mc{V}$.

\noin 9. $\mc{P}$ computes the integers \vs $$\what{r}_i:= \what{d}_i\Mod{l}\;,\;{r}_i:= {d}_i\Mod{l}$$ and sends $(r_1,\cdots,r_n)$ to $\mc{V}$.

\noin 10. $\mP$ computes the integers $\wti{q},\what{q}, \wti{r}, \what{r}$ such that \vs $$\slim_{i=1}^n {d}_i^{n\lam}\gamma^i = \wti{q}l+\wti{r}\;,\; \slim_{i=1}^n \what{d}_i\gamma^i = \what{q}l+\what{r}\;,\;\;r,\what{r}\in [l].$$

\noin 11. $\mP$ computes \vs $$Q:= w^q\;,\; \what{Q}:= w^{\what{q}}\;,\;\weck{g}:= g^{\wti{q}}$$ and sends $Q, \what{Q}, \weck{g}$ to $\V$.

\noin 12. The Fiat-Shamir heuristic generates a $\lam$-bit challenge $\gamma_0$.

\noin 13. $\mP$ computes the integers $\what{q}_0, \what{r}_0$ such that \vs $$\slim_{i=1}^n \what{d}_i\gamma^i = \what{q}_0l+\what{r}_0\;,\;\what{r}_0\in [l]$$ He computes $\what{Q}_0:= w^{\what{q}_0} $ and sends it to $\V$.

\noin 14. $\V$ verifies that $(r_1,\cdots,r_n)\in [l]^{n}$. He independently computes \vs $$R:= \pl_{i=1}^n r_i\Mod{l} \;,\;\what{r}_i = Rr_i^{-1}\Mod{l}\;\;(i=1,\cdots,n),$$\vs $$\wti{r}:= \slim_{i=1}^n {r}_i^{n\lam}\gamma^i\Mod{l} \;,\; \what{r}:= \slim_{i=1}^n \what{r}_i\gamma^i\Mod{l}\;,\;\what{r}_0:= \slim_{i=1}^n \what{r}_i\gamma_0^i\Mod{l}.$$

\noin 15. $\V$ verifies the equations \vs $$(\what{Q})^lw^{\what{r}}\sta \pl_{i=1}^n w_i^{\gamma^i} \;\bigwedge\; (\what{Q}_0)^lw^{\what{r}_0}\sta \pl_{i=1}^n w_i^{\gamma_0^i}\;\bigwedge\; A_0W\sta w\;\bigwedge\; (\weck{w})^lw^R\sta A\;\bigwedge\; (\weck{g})^lg^{\wti{r}}\sta\wti{g}.$$

\noin 16. $\V$ verifies the two \verb|PoKE|s from Step 4. He accepts if and only if all equations hold and all proofs are valid.\end{prf1}

\vspace{0.1cm}


\begin{Prop} The protocol \verb|PoAggRelPrimeDLog-3| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggRelPrimeDLog-3|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The equations verified in step 15 imply that with \op, there exist integers $d_1,\cdots,d_n, D$ such that \vs $$D = \pl_{i=1}^n d_i\;,\;A = w^D\;,\; A= w_i^{d_i}\;\forall \;i .$$ Furthermore, since we have $A_0W = w$ and the proofs for \verb|PoKE|$[A,\;A_0]$ and \verb|PoKE|$[(\pl_{i=1}^n w_i),\; W]$, it follows that, in particular, $w$ is expressible as a product \vs $$w =\pl_{i=1}^n w_i^{x_i}\;,\;(x_1,\cdots,x_n)\in\bz^n.$$ Hence, \vs $$w^{\LCM(d_1,\cdots,d_n)} = A^k$$ for some integer $k$. Thus, $\LCM(d_1,\cdots,d_n)$ is divisible by the product $\pl_{i=1}^n d_i$ . Hence, the integers $d_i$ are pairwise co-prime.\end{prf}



\bigskip

Next, we discuss a dual to the Protocol \verb|AggRelPrimeDLog-2|. Given elements $B, C\in \mb{G}$ and subsets \vspace{-0.15cm}$$\mc{B} = \{b_1,\cdots, b_m\},\;\; \mc{C} = \{c_1,\cdots, c_n\}\in \mb{G}^n,$$ an honest Prover may provide a proof that he possesses integers \vs $$\{d_1,\cdots, d_m\}\;,\; \{e_1,\cdots, e_n\}$$ such that $b_i^{d_i} = B,\; c_j^{e_j} = C$ and every pair $d_i, e_j$ is relatively prime. We call this relation the \textit{Aggregated Relatively Prime Discrete Logarithms 4} or \verb|AggRelPrimeDLog-4| for short. We provide an argument of knowledge for the following relation:
\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-4|}}[\mc{B}, \mc{C}, B, C] = \left\{\begin{array}{l}
    ((B,C)\in\mb{G}^2,\;\\
     \mc{B} = (b_1,\cdots,b_m)\in\mb{G}^m,\;\mc{C} = (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n)\;: \\
    (B = b_i^{d_i},\; C = c_j^{e_j}\;\bigwedge \; \GCD(d_i, e_j) = 1)\;\forall \;i,j
  \end{array}\right\}
\] 

\noindent \textbf{An example:} Consider the case where $B$, $C$ are accumulated digests for accumulators $\Acc_1$ and $\Acc_2$ respectively. Let $\mc{D}_1,\cdots,\mc{D}_m$ and $\mc{E}_1,\cdots,\mc{E}_m$ be data sets inserted into the two accumulators. Let $w_i$, $u_j$ denote the membership witnesses for $\mc{D}_i$, $\mc{E}_j$ and let $d_i$, $e_j$ denote the products of elements of $\mc{D}_i$, $\mc{E}_j$ respectively($1\leq i\leq m$, $1\leq j\leq n$). Then $$w_i^{d_i} = B,\; u_j^{e_j} = C.$$ Suppose a Prover needs to prove the disjointness of the unions $$\mc{D} := \bigcup\limits_{i=1}^m \mc{D}_i\;\;,\;\;\mc{E} := \bigcup\limits_{j=1}^n \mc{E}_j$$ to a Verifier with access to the witnesses \vspace{-0.15cm}$$\mc{W}:= \{w_1,\cdots,w_m \}\;\;,\;\;\mc{U}:= \{u_1,\cdots,u_n \}.$$

A straightforward approach would be to provide $mn$ distinct proofs that $\GCD(d_i, e_j) = 1$ for every pair $d_i,e_j$. But such a proof would entail $\mbf{O}(mn)$ elements of $\mb{G}$ in addition to $\mbf{O}(mn)$ $\lamb$-bit integers. Instead, the Prover could simply send a non-interactive proof for\\ \verb|AggRelPrimeDLog-4|$[(\mc{W}, B),\;(\mc{U}, C)]$. The proof consists of a constant number of $\mb{G}$-elements and $(m+n)$ $\lamb$-bit integers.\vspace{0.1cm} 


\begin{Prot} \normalfont \textit{Proof of Aggregated Knowledge of Relatively Prime Discrete Logarithms} 4\\ (\verb|PoAggRelPrimeDLog-4|) :\end{Prot}\vspace{-0.3cm}

\noindent \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb), \; g\in \mb{G}$.

\noindent \textbf{Inputs:} Elements $B, C\in \mb{G}$,\;  $\mc{B} = (b_1,\cdots, b_m)\;\in\;\mb{G}^m$,\;\; $\mc{C} = (c_1,\cdots, c_n)\;\in\;\mb{G}^n$

\noindent \textbf{Claim:} The Prover possesses integers $ d_1,\cdots, d_m$,\; $e_1,\cdots,e_n$ such that:

\noindent - $b_i^{d_i} = B$ for $i = 1,\cdots, m$.

\noindent - $c_j^{e_j} = C$ for $j = 1,\cdots, n$.

\noindent - $\GCD(d_i, e_j) = 1$ for every pair $i, j$.

\begin{prf1} \normalfont 1. The Prover $\mc{P}$ computes \vs $${d}:= \LCM(d_1,\cdots,d_m),\;\; {e}:= \LCM(e_1,\cdots,e_n).$$

\noindent 2. Using Shamir's trick, $\mP$ computes elements $b, c \in \mb{G}$ such that \vspace{-0.15cm}$$b^{d} = B,\;\; c^{e} = C$$ and sends $b,c$ to the Verifier $\mc{V}$.

\noindent 3. $\mc{P}$ computes non-interactive proofs for \verb|AggKE-2|$[\mc{B}, B]$ and \verb|AggKE-2|$[\mc{C}, C]$ and sends them to $\mc{V}$.

\noindent 4. $\mc{P}$ computes non-interactive proofs for \verb|AggKE-1|$[b,\mc{B}]$ and \verb|AggKE-1|$[c, \mc{C}]$ and sends them to $\mc{V}$.

\noindent 5. $\mc{P}$ computes a non-interactive proof for \verb|RelPrime|$[(b,B),\;(c,C)]$ and sends the proof to $\mc{V}$.

\noindent 6. $\mc{V}$ verifies all of these proofs and accepts the validity of the claim if and only if all proofs are valid.\end{prf1}

\noindent Thus, the proof for \verb|AggRelPrimeDLog-4| consists of a constant number of $\mb{G}$-elements and $m+n$ $\lam$-bit integers arising from the proofs for \verb|AggKE-2|$[\mc{B}, B]$ and \verb|AggKE-2|$[\mc{C}, C]$.


\begin{Prop} The protocol \verb|AggRelPrimeDLog-4| is an argument of knowledge for the relation $\mc{R}_{{\protect\verb|AggRelPrimeDLog-4|}}$ in the generic group model.\end{Prop}

\begin{prf} (Sketch) The proofs for \verb|AggKE-2|$[\mc{B}, B]$ and \verb|AggKE-1|$[b,\mc{B}]$ imply that, with overwhelming probability, there exist integers $d,d_1,\cdots,d_m,\what{d}_1,\cdots,\what{d}_m$ such that \vs $$b^d = B\;,\; b^{\what{d}_i}= b_i\;,\; b_i^{d_i}= B\;\forall\; i.$$ Similarly, the proofs for \verb|AggKE-2|$[\mc{C}, C]$ and \verb|AggKE-1|$[c,\mc{C}]$ imply that with overwhelming probability, there exist integers $e,e_1,\cdots,e_n$, $\what{e}_1,\cdots,\what{e}_n$ such that \vs $$c^e = C\;,\; c^{\what{e}_j}= c_j\;,\;c_j^{e_j}= C\;\forall\; j.$$ 

Finally, the proof for \verb|RelPrimeDLog|$[(b,B),\;(c,C)]$ implies with \op, that $\GCD(d,e) = 1$. Hence, $\GCD(d_i,e_j) = 1\;\forall\;i,j$.

\end{prf}

\bigskip

\section{\fontsize{11}{11} Applications}



\noin \textbf{Verifiably outsourcing storage:} Consider a setting where a client $\mc{V}$ stores data sets (or multisets) $\mc{D}_1, \cdots, \mc{D}_n$ using a server node $\mc{S}$. The client stores the elements \vs $$h_i:= g^{\Pi(\mc{D}_i)},$$ which function as commitments for the data multisets. Suppose the client needs the intersection \vs $$\mc{D}_{\mr{int}}:=\bigcap\limits_{i=1}^n \mc{D}_i .$$ The server can verifiably send the intersection to the client through the following protocol, which is a minor generalization of \verb|PoGCD|. It hinges on the observation that \vs $$d = \gcd(d_1,\cdots,d_n)\; \LRA\; (d|d_i\;\forall\;i)\;\bigwedge\; (\exists\;(e_1,\cdots,e_n)\in\bz^n:\;\sum\limits_{i=1}^n e_id_i = d ).$$

\vspace{0.1cm}

\noin 1. The Prover $\mP$ computes integers \vs $$d_i:= \Pi(\mc{D}_i)\; (i=1,\cdots,n)$$ and integers $e_1,\cdots,e_n$ such that \vs $$\sum\limits_{i=1}^n d_ie_i = \GCD(d_1,\cdots,d_n).$$

\noin 2. $\mP$ computes $\wti{h}_i:= g^{d_ie_i} \; (i=1,\cdots,n)$ and sends $\wti{h}_1,\cdots, \wti{h}_n$ to the Verifier $\V$ along with non-interactive proofs for \verb|PoKE|$[h_i,\;\wti{h}_i]\; (i=1,\cdots,n)$ and \verb|PoKE|$[g, h]$.

\noin 3. $\mP$ computes \vs $$h:= g^{\GCD(d_1,\cdots,d_n)}\;\in\; \mb{G}$$ and sends $h$ to $\V$ along with a non-interactive \verb|PoE| for this exponentiation.

\noin 4. $\mP$ computes a non-interactive proof for \verb|PoAggKE-1|$[h,\;(h_1,\cdots,h_n)]$

\noin 5. $\V$ verifies the $n$ \verb|PoKE|s, the  \verb|PoE| and \verb|PoAggKE-1|$[h,\;(h_1,\cdots,h_n)]$. He verifies the equation \vs $$\pl_{i=1}^n \wti{h}_i\sta h.$$ He accepts if and only if all proofs are valid and the equation holds.\\

\noin \textbf{Frequencies of elements:} As before, let $\mc{M}_1,\cdots, \mc{M}_n$ be data multisets and let \vs $$A_i:= g^{\Pi(\mc{M}_i)}\;(i=1,\cdots,n) $$ be the commitments. Suppose the server storing the data needs to identify the data multiset with the highest frequency of a data set $\mc{D}$. The protocols we have developed so far allows him to do so with a proof that the client can verify against the commitments $A_1,\cdots,A_n$.\vspace{0.1cm}

\begin{Prot} Protocol for frequency of sets in multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a higher frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{prf1}\noin \normalfont 1. The Prover $\mP$ computes \vs $$A_1':= g^{\Pi\left(\bigcup\limits_{i=2}^n \mc{M}_i\right)} $$ and sends it to the verifier $\V$ along with a non-interactive proof for \verb|AggKE-2|$[(A_2,\cdots,A_n), A_1']$.

\noin 2. The Prover computes the integer \vs $$d':= \pl_{x\in \mc{D}} x^{\mr{mult(A_1', x)}} $$ and the group elements \vs $$B_1:= g^{d'}\;,\;B_2:= B_1^{\Pi(\mc{D})} .$$

\noin 3. $\mP$ computes a non-interactive proof for \verb|EqDLog|$[(g, g^{\Pi(\mc{D})}),\;(B_1,B_2)]$ and sends it to $\V$.

\noin 4. $\mP$ compute non-interactive proofs for \verb|PoKE|$[B_2,\;A_1]$, \verb|PoGCD|$[(g, A_1'),\;(g, B_2),\;(g, B_1)]$ and sends the to $\V$.

\noin 5. $\V$ verifies the three proofs and accepts if and only if all of them are valid.\end{prf1}



\begin{Prot} Protocol for frequency of sets in multisets.\end{Prot} \vspace{-0.3cm}

\noin \textbf{Parameters:} $\mb{G}\xleftarrow{\$} \mr{GGen}(\lamb)$,\; $g\in \mb{G}$.

\noin \textbf{Inputs:} Commitments $A_i := g^{\Pi(\mc{M}_i)}$ for multisets $\mc{M}_i$; a data set $\mc{D}$.

\noin \textbf{Claim:} Each element of $\mc{D}$ occurs with a lower frequency in $\mc{M}_1$ than in $\mc{M}_i\;\forall\;i\geq 2$.

\begin{prf1}\noin \normalfont 1. The Prover $\mP$ computes \vs $$B_1:= g^{\pl_{x\in\mc{D}} x^{\mr{mult(\mc{A_}, c)}}}\;,\; B_2 = B_1^{\Pi(\mc{D})}.$$

\noin 2. $\mP$ computes a non-interactive proof for \verb|EqDLog|$[(g, g^{\Pi(\mc{D})}),\;(b_1,B_2)]$ and sends it to the verifier $\V$.

\noin 3. $\mP$ computes non-interactive proofs for \verb|AggKE-1|$[B_2,\;(A_2,\cdots,A_n)]$, \verb|PoGCD|$[(g, A_1),\;(g, B_2),\;(g,B_1)]$ and sends them to $\V$.

\noin 4. $\V$ verifies the three proofs and accepts if and only if they are all valid.\end{prf1}






\bigskip

\noin \textbf{Sharded blockchains:} Consider the setting of a stateless sharded blockchain that, instead of a Merkle tree, hinges on a cryptographic accumulator instantiated with a hidden order group $\mb{G}$ ([BBF19]). Let $g$ be a randomly selected element of $\mb{G}$ and $S_1,\cdots, S_n$ the distinct shards. Let $\mc{D}_i$ denote the data in shard $S_i$ and $\mc{D}:= \bigcup\limits_{i=1}^n \mc{D}_i$. Then the accumulated digest (the analog of the Merkle root hash) of $S_i$ is given by \vs $$A_i:= g^{\Pi(\mc{D}_i)}.$$  The accumulated digest of the blockchain is given by \vs $$A:= g^{\Pi(\mc{D})}.$$

In order to demonstrate that the data sets in distinct shards are pairwise disjoint, a Prover (such as a miner or an untrusted server) can provide a proof for the relation\\ $\mc{R}_{{\protect\verb|AggRelPrimeDLog-1|}}[a, \mc{A}]$ where $\mc{A} = (A_1,\cdots,A_n)$.\vspace{0.2cm}

Let $\V_1,\cdots,\V_n$ be verifiers (such as light nodes) on the network. Let $\mc{E}_i$ denote the data set corresponding to $\V_i$. Suppose the verifiers need to verify that the data sets $\mc{E}_i$ are pairwise disjoint, but do not have access to the data sets outside their shards. A Prover $\mP$ (such as a miner or an untrusted server) can prove this pairwise disjointness as follows.\vspace{0.1cm}

\noin 1. $\V_i$ ($i=1,\cdots,n$) broadcasts the membership witness $w_i$ for $\mc{D}_i$ to the other $n-1$ nodes $\V_j$ ($j\neq i$). 

\noin 2. $\mP$ computes \vs $$d_i:= \pl_{d\in\mc{D}_i} d\;\;(i=1,\cdots,n)$$ and generates a non-interactive proof for the protocol \verb|PoAggRelPrimeDLog-3|$[(w_1,\cdots,w_n),\; A]$.



% \noin 2. Now suppose the Prover needs to convince a Verifier that 

\bigskip










\bigskip

\bigskip

\bigskip

\bigskip

\noin \textbf{Acknowledgements:} The author thanks Benedikt B\"{u}nz and Dimitris Kolonelos for helpful feedback.

\bigskip



\begin{center}\textbf{References} \end{center}
\footnotesize

\noindent [BBF19] D. Boneh, B. B\"{u}nz, B. Fisch, \textit{Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains.} In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology – CRYPTO 2019, pages 561–586, Cham, 2019. Springer International Publishing. \vspace{0.1cm}

\noindent [BFS19] B. B\"{u}nz, B. Fisch, A. Szepieniec, \textit{Transparent SNARKs from DARK Compilers}, Cryptology ePrint Archive, Report 2019/1229, 2019. https://eprint.iacr.org/2019/1229 \vspace{0.1cm}

\noindent [CFGKN20] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, L. Nizzardo \textit{Vector Commitment Techniques and Applications to Verifiable Decentralized Storage} \vspace{0.1cm}

\noin [CSV20] W. Castryck, J, Sotakova, F. Vercauteren, \textit{Breaking the decisional Diffie-Hellman problem for class group actions using genus theory}\vspace{0.1cm}

\noindent [Can87] D. Cantor. \textit{Computing in the Jacobian of a hyperelliptic curve. Mathematics of computation}, 48(177):95–101, 1987.\vspace{0.1cm}

\noindent [Can94] D. Cantor. \textit{On the analogue of the division polynomials for hyperelliptic curves}, Crelle's Journal, 447:91–146, 1994.\vspace{0.1cm}


\noindent [DGS20] S. Dobson, S. Galbraith, B. Smith, \textit{Trustless Groups of Unknown Order with Hyperelliptic Curves}, https://eprint.iacr.org/2020/196\vspace{0.1cm}

\noindent [FS87] A. Fiat, A. Shamir, \textit{How to prove yourself: Practical solutions to identification and signature problems.} In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987\vspace{0.1cm}

\noin [LLX07] J. Li, N. Li, and R. Xue,  \textit{Universal accumulators with efficient nonmembership proofs} In Jonathan Katz and Moti Yung, editors, ACNS 07, volume 4521 of LNCS, pages 253-269. Springer, Heidelberg, June 2007.

\noindent [Sut07] A. Sutherland, \textit{Order Computations in Generic Groups}, MIT Thesis, 2007 \vspace{0.1cm}

\noindent [STY01] T. Sander, A. Ta-Shma, M. Yung, \textit{Blind, auditable membership proofs}, In Yair Frankel, editor, FC 2000, volume 1962 of LNCS, pages 53{71. Springer, Heidelberg, February 2001.\vspace{0.1cm}

%\noindent [Th19] S. Thakur, \textit{Batching non-membership proofs with bilinear accumulators}, https://eprint.iacr.org/2019/1147\vspace{0.1cm}

\noindent [Th20] S. Thakur, \textit{Constructing hidden order groups using genus three Jacobians}, https://eprint.iacr.org/2020/348\vspace{0.1cm} 

\noindent [Wes19] B. Wesolowski, \textit{Efficient verifiable delay functions}. In Yuval Ishai and Vincent Rijmen, editors, Advances in Cryptology – Eurocrypt 2019, pages 379–407, Cham, 2019. Springer International Publishing.\vspace{0.1cm}




\bigskip

\normalsize
\noindent Steve Thakur\\
Axoni Research Group\\
New York City, NY\\
Email: stevethakur01@gmail.com


\newpage


\begin{center}\textbf{List of symbols/abbreviations:}\end{center}

\noindent $\mb{G}$: a group of hidden order in which we assume the adaptive root and strong-RSA assumptions to hold. \vspace{0.1cm}

\noindent $\lam$: The security parameter \vspace{0.1cm}

\noindent $\negl(\lam)$: The set of functions negligible in $\lam$. \vspace{0.1cm}

\noindent $[n]$: The set of integers $\{0,1,\cdots,n-1 \}$ \vspace{0.1cm}

\noin PPT: Probabilistic Polynomial Time \vspace{0.1cm}

\noindent $a\eqlam b$: The equivalence of $a,b\in\mb{G}$ with respect to the relation $\eqlam$ \vspace{0.1cm}

\noin $\mc{P}$: The Prover \vspace{0.1cm}

\noin $\mc{P}_{\mr{mal}}$: A malicious Prover \vspace{0.1cm}

\noin $\mc{V}$: The Verifier \vspace{0.1cm}

\noin $\impop$: Implies with overwhelming probability \vspace{0.1cm}

\noin $\sett(\mc{M})$: The underlying set of a multiset $\mc{M}$ \vspace{0.1cm}

\noin $\Pi(\mc{M})$: The product of all elements of a multiset $\mc{M}$

\bigskip \begin{center} \textbf{List of Protocols:}

\end{center}

The following is a list of the protocols in this paper and the relations that the protocols are arguments of knowledge for, in the generic group model.\\

\noin 1. \verb|PoEqDLog| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|EqDLog|}}[(a_1, b_1),\;(a_2,b_2)] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2\\
    d\in\mb{Z}): \\
    (b_1,b_2) = (a_1^d,a_2^d)
  \end{array}\right\}
\]

\noin 2. \verb|PoAggEqDLog| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|AggEqDLog|}}[(a, b),\;(\mc{A},\;\mc{B})] = \left\{\begin{array}{l}
  	((a, b)\in\mb{G}^2\\
    \mc{A} = (a_1, \cdots, a_n),\;\mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\
    d\in\mb{Z}): \\
    b_i = a_1^{d} \;\forall\;i
  \end{array}\right\}
\]
 

\noin 3. \verb|PoPolyDLog| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|PolyDLog|}}[(a_1, b_1),\;(a_2,b_2),\;f] = \left\{\begin{array}{l}
    ((a_1, b_1), \; (a_2,b_2)\in\mb{G}^2,\;f\in\bz[X]);\\
    (d_1, d_2)\in\mb{Z}^2: \\
    b_1 = a_1^{d_1}\; \bigwedge\; b_1 = a_1^{d_1}\; \bigwedge \;d_2 = f(d_1)
  \end{array}\right\}
\]

\noin 4. \verb|PoAggKE-1| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|AggKE-1|}}[a,\; \mc{B}] = \left\{\begin{array}{l}
    (a\in\mb{G},\; \mc{B} = (b_1,\cdots, b_n)\in\mb{G}^n);\\ 
    (d_1,\cdots,d_n)\in\bz^n):  \\
    b_i = a^{d_i}\;\forall\; i
  \end{array}\right\}
\]

\noin 5. \verb|PoAggKE-2| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|AggKE-2|}}[\mc{A},\;A] = \left\{\begin{array}{l}
    (\mc{A} = (a_1,\cdots, a_n)\in \mb{G}^n,\; A\in\mb{G})\;\\ 
    (d_1,\cdots,d_n)\in\bz^n) :  \\
     A = a_i^{d_i}\;\forall\; i
  \end{array}\right\}
\]

\noin 6. \verb|PoMultPolyDLog| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|MultPolyDLog|}}[a, (b_1,\cdots, b_n), f] = \left\{\begin{array}{l}
    (a\in\mb{G},\; (b_1,\cdots, b_n)\in\mb{G}^n);\\
    f\in\bz[X_1,\cdots,X_n]);\\ 
    (d_1,\cdots,d_n)\in \bz^n)\;: \\
    b_i = a^{d_i}\;\forall\; i\;\bigwedge \;   f(d_1,\cdots,d_n) = 0 
  \end{array}\right\}
\]

\noin 7. \verb|PoEqDLogPairs| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|EqDLogPairs|}}[(a_1, \mc{B}),\; (a_2, \mc{C})] = \left\{\begin{array}{l}
  	(a_1,a_2\in\mb{G};\\
    (b_1,\cdots, b_n),\;(c_1,\cdots, c_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in \bz^n)\;: \\
    b_i = a_1^{d_i}\;,\;c_i= a_2^{d_i} \;\forall\; i
  \end{array}\right\}
\]

\noin 8. \verb|PoGCD| \vspace{-0.2cm}
$$\mc{R}_{{\protect\verb|GCD|}}[(a_1,b_1),\; (a_2,b_2),(a_3,b_3)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=d_3  \} .$$


\noin 9. \verb|PoRelPrimeDLog| (special case of \verb|PoGCD|) \vspace{-0.7cm}

\[
\mc{R}_{{\protect\verb|RelPrimeDLog|}}[(a_1,b_1),\;(a_2,b_2)] = \{((a_i, b_i\in\mb{G});\;d_i\in\bz)\;:\; b_i = a_i^{d_i},\;\GCD(d_1,d_2)=1 \} .
\]

\noin 10. \verb|PoAggRelPrimeDLog-1| \vspace{-0.2cm}

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-1|}}[a, \mc{A}] = \left\{\begin{array}{l}
    \big(a\in\mb{G},\;  \mc{A}:=(a_1,\cdots, a_n)\in\mb{G}^n);\\
    (d_1,\cdots,d_n)\in\bz^n\big): \\
    a_i = a^{d_i}\;\forall\;i\;\;,\;\; \GCD(d_i, d_j) = 1)\;\forall \;i\neq j   	
  \end{array}\right\}
\] 

\noin 11. \verb|PoAggRelPrimeDLog-2| \vspace{-0.6cm}

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-2|}}[a_1, a_2, \mc{B}, \mc{C}] = \left\{\begin{array}{l}
    \big((a_1,a_2)\in\mb{G}^2,\;\\
     \mc{B}:=(b_1,\cdots, b_m)\in\mb{G}^m,\;\mc{C}:= (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n\big)\;: \\
    (b_i = a_1^{d_i}\;\;\bigwedge\;\; c_j = a_2^{e_j}\;\bigwedge\; \GCD(d_i, e_j) = 1)\;\forall \;i,j   	
  \end{array}\right\}
\] 

\noin 12. \verb|PoAggRelPrimeDLog-3| \vspace{-0.3cm}

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-3|}}[(w_1,\cdots, w_n), A] = \left\{\begin{array}{l}
    \big(A\in\mb{G},\; (w_1,\cdots, w_n)\;\in\mb{G}^n);\\
    ((d_1,\cdots,d_n)\in\bz^n\big)\;: \\
    w_i^{d_i} = A\;\forall\;i\;\bigwedge  \\
   	\GCD(d_i, d_j) = 1\;\forall \;i,j: i\neq j
  \end{array}\right\}
\] 

\noin 13. \verb|PoAggRelPrimeDLog-4| \vspace{-0.7cm}

\[
  \mc{R}_{{\protect\verb|AggRelPrimeDLog-4|}}[\mc{B}, \mc{C}, B, C] = \left\{\begin{array}{l}
    \big((B,C)\in\mb{G}^2,\;\\
     \mc{B} = (b_1,\cdots,b_m)\in\mb{G}^m,\;\mc{C} = (c_1,\cdots, c_n)\in\mb{G}^n);\\
    ((d_1,\cdots,d_m)\in\bz^m,\; (e_1,\cdots,e_n)\in\bz^n\big)\;: \\
    (B = b_i^{d_i},\; C = c_j^{e_j}\;\bigwedge \; \GCD(d_i, e_j) = 1)\;\forall \;i,j
  \end{array}\right\}
\] 


\bigskip

\newpage


\noin \textbf{Private Set Intersection:} Consider a setting where two parties $\mbf{A}$ and $\mbf{B}$ have two data sets $\mc{D} = \{d_1,\cdots,d_m \}$, $\mc{E} = \{e_1,\cdots,e_n \}$ and need to compute the intersection $\mc{D}\cap \mc{E}$. A design goal is for the parties to know as little as possible about the elements not in the intersection. To this end, we may proceed as follows. 

Let $\mb{G}$ be a hidden order group in which we assume the strong-RSA, adaptive root and Diffie-Hellman assumptions to hold. Let $g$ be a randomly generated element of $\mb{G}$. We represent the data elements by $2\lam$-bit primes, where $\lam$ is the security level. \vspace{0.15cm}

\noin 1. $\mbf{A}$, $\mbf{B}$ choose integers $\al$, $\be$ respectively and broadcast the elements $g^{\al}, g^{\be}$.

\noin 2.  $\mbf{A}$, $\mbf{B}$ compute and broadcast the commitments \vs $$\protect{\verb|Com|}(\mc{D})^{\al}:= g^{\al\pl_{d\in\mc{D}} d }\;,\; \protect{\verb|Com|}(\mc{E})^{\be}:=  g^{\be\pl_{e\in\mc{E}} e } $$ respectively. 

\noin 3. $\mbf{A}$ computes the set $\mc{D}_{\al} := \{g^{ d\al}\;:\; d\in\mc{D}\}$ and sends it to $\mbf{B}$ along with a non-interactive proof for \vs $$\protect{\verb|PoMultPolyDLog|}[g^{\al},\;(g^{d_1\al},\cdots, g^{d_m\al},\protect{\verb|Com|}(\mc{D})^{\al}),\; (\pl_{i=1}^m X_i)-X_{m+1}].$$ 

\noin 4. $\mbf{B}$ computes the set $\mc{E}_{\be}:= \{g^{ e\be}\;:\; e\in\mc{E}\}$ and sends it to $\mbf{A}$ along with a non-interactive proof for \vs $$\protect{\verb|PoMultPolyDLog|}[g^{\be},\;(g^{e_1\be},\cdots, g^{e_n\be},\protect{\verb|Com|}(\mc{E})^{\be}),\; (\pl_{i=1}^n X_i)-X_{n+1}].$$

\noin 5. $\mbf{B}$ computes the set $\mc{D}_{\al\be}:= \{g^{ d\al\be}\;:\; d\in\mc{D}\}$ and sends it to $\mbf{A}$ along with a non-interactive proof for \verb|PoAggEqDLog|$[(g, g^{\be}),\;\mc{D}_{\al},\;\mc{D}_{\al\be}]$.  

\noin 6. $\mbf{A}$ computes the set $\mc{E}_{\be\al}:= \{g^{ e\al\be}\;:\; e\in\mc{E}\}$ and the intersection $\mc{D}_{\al\be}\cap \mc{E}_{\be\al}$. He uses it to compute the intersection $\mc{D}\cap \mc{E}$ and the element \vs $$g_0:= g^{\pl_{x\in \mc{D}\cap \mc{E}} x}.$$

\noin 7. $\mbf{B}$ computes the set $\mc{D}_{\al\be}:= \{g^{ d\al\be}\;:\; d\in\mc{D}\}$ and the intersection $\mc{D}_{\al\be}\cap \mc{E}_{\be\al}$. He uses it to compute the intersection $\mc{D}\cap \mc{E}$ and the element $g_0$.

\noin 8. $\mbf{A}$ sends $\mbf{B}$ non-interactive proofs for \vs $$\protect{\verb|PoKE|}[(g_0^{\al}, \protect{\verb|Com|}(\mc{D})^{\al}]\;,\;\protect{\verb|PoEqDLog|}[(g,g^{\al}),\; (g_0, g_0^{\al})].$$ 

\noin 9. $\mbf{B}$ sends $\mbf{A}$ non-interactive proofs for \vs $$\protect{\verb|PoKE|}[(g_0^{\be}, \protect{\verb|Com|}(\mc{E})^{\be}]\;,\;\protect{\verb|PoEqDLog|}[(g,g^{\be}),\; (g_0, g_0^{\be})].$$ 

\bigskip


























\end{document}

















